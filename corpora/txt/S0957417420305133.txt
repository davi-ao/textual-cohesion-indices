With the wide application of positioning device, it is possible to record and store a great number of trajectory data for various moving objects, such as vehicle position data, mobile user activity data, animal migration data, and so on. Trajectory clustering is an effective method to analysis trajectory data, and has recently been applied in traffic condition analysis (Kan et al., 2019, Sun et al., 2019), pattern recognition (Augustin et al., 2018, Sharma et al., 2018), data analysis (Murça, Hansman, Li, & Ren, 2018), etc.
Trajectory clustering means that we partition trajectory data into groups. The trajectories in the same group are similar with each other, and in the different groups show different features. A lot of work has been done in trajectory clustering field. Gaffney and Smyth (1999) introduced a probabilistic mixture regression model for trajectory data and showed how to use the Expectation Maximization algorithm to cluster the trajectories. Lee, Han, and Whang (2007) proposed a trajectory clustering algorithm, named TRACLUS, based on partition-and-group framework. Liu and Wang (2017) put forward a general framework for trajectory clustering by diffusion modeling on multiple information sources. Zhang, Lee, and Lee (2018) proposed a hierarchical trajectory clustering based periodic pattern mining which considered semantic spatio-temporal information. Hung, Peng, and Lee (2015) presented a clue-aware trajectory clustering algorithm to cluster similar trajectories into groups to capture the movement behaviors of the user. Besse, Guillouet, Loubes, and Royer (2016) tackled the issue of clustering trajectories of geolocalized observations based on the symmetrized segment-path distance. However, most of the above methods only utilize the distance function to measure the similarity between the trajectories, and can only find the clusters with a specific shape determined by the distance function. Besides, most of existing methods focus on the spatial characteristic of the trajectory data, while ignore other distinguishing features, such as weather, users’ activities and users’ interests.
Nowadays, complex networks have received an increasing number of researchers’ attention all over the world. A variety of network analysis methods had been presented (Fortunato and Hric, 2016, Landherr et al., 2010, Liu et al., 2018) and were applied in many fields, such as disease prediction (Guille et al., 2013, Özgür et al., 2008), users’ interests recommendation (Hu et al., 2018, Shi et al., 2019), terrorism community detection (Qin et al., 2005, Saidi et al., 2018) and so on. Furthermore, recent works (Ferreira and Zhao, 2016, Gao et al., 2017, Marwan et al., 2009, Yang and Yang, 2008) demonstrate that the complex network analysis methods have been applied in time series data successfully. Traditional time series analysis methods only focus on identifying local relationship among neighbor data samples, and ignore the global relationship of the time series data (Ferreira & Zhao, 2016). However, the complex network is fit for revealing the relationship between data in the form of the graph, and can get global information of the time series data. Moreover, the network-based methods can capture the cluster with random shape (Gao et al., 2017). Thus, some researchers (Gao et al., 2017, Lacasa et al., 2008, Small et al., 2009) tried to convert the time series data into the network and leverage the network-based methods to analyze it. As a kind of time series data, the trajectory data can also be analyzed with the network analysis methods. Besides, a lot of network-based clustering methods (Ferreira and Zhao, 2016, Fortunato and Hric, 2016, Gao et al., 2017, Liu et al., 2016) had been proposed, and some of them have nearly linear time complexity when the constructed network is sparse, which are attractive to trajectory data clustering.
Recently, Ferreira and Zhao (2016) proposed a time series clustering method via community detection. As a new type of time series data, trajectory data can also be analyzed by using network analysis methods. However, the trajectory data is not the same with the traditional time series data (Chen, Özsu, & Oria, 2005). Generally speaking, most of time series data are one dimensional while most of trajectory data are two or more dimensional, such as spatial location, the object status and so on. Furthermore, the semantic characteristic of the trajectory data is always important in some applications while it sometimes is ignored in time series analysis.
In summary, the semantic trajectory clustering should take the spatio-temporal similarity and semantic similarity of the trajectory into account, while the semantic similarity includes the local and global relationship among trajectories. Different from previous work (Furtado et al., 2016, Liu and Wang, 2017), we deal with the semantic trajectory datasets from the perspective of the network, and utilize community detection methods to detect semantic trajectories partitions.
The contribution of this paper can be highlighted as follows:
On the basis of previous works (Petry et al., 2019, Furtado et al., 2016), the ontology theory is introduced to facilitate the computation of semantic trajectory similarity, which can better measure the semantic similarity between trajectories.
A semantic trajectory clustering algorithm is proposed from the perspective of the network. Firstly, a trajectory network is constructed based on the semantic similarity between trajectories. Then, we can utilize both local and global relationship among trajectories from the perspective of the network. Next, community detection algorithms are used to detect trajectory clusters, and similar trajectories are naturally assigned to the same group.
Extensive study has been conducted for the proposed method. Specifically speaking, we check the influence of different factors, such as the similarity functions, network construction parameters and community detection methods, on trajectory clustering results. Then, we demonstrate the network-based trajectory clustering methods can get better performance compared to traditional and current widely used methods.
How to measure the similarity between trajectories is the basis for trajectory clustering problem. Then, in this section, we firstly review some mainstream trajectory similarity approaches. Secondly, we take a review for some representative trajectory clustering methods. Lastly, we mainly present some classic and widely used community detection methods.
At present, there are mainly two kinds of methods for measuring trajectory similarity. The first is based on the spatial or temporal information of the moving objects. The second is based on multi-attribute of the moving objects, and not only limited to spatial–temporal information, which can improve the accuracy and rationality in measuring the trajectory similarity.
The Longest Common Subsequence (LCSS), proposed by Vlachos, Kollios, and Gunopulos (2002), was a well-known method for measuring the similarity between raw trajectories. It finds the longest common subsequence according to a matching threshold, which is set to determine the similarity between trajectories. Chen et al. (2005) put forward the Edit Distance on Real (EDR) sequence for trajectory similarity analysis. Yuan and Raubal (2014) developed a spatial–temporal Edit Distance method for measuring trajectory similarity of mobile phone users. The limits of the LCSS and EDR lie in the fact that they are based on the worst similarity value of the sequence elements, and are not accurate for measuring the multi-dimensional trajectory data.
The drawback of the spatial–temporal similarity measures lies in it ignores the semantic information of the trajectory data, while it is import in revealing the relation between trajectories. Then, some researchers began to study how to measure the semantic similarity of the trajectory data. The semantic similarity is mainly presented by attribute similarity, which can better describe the status of the moving object. Furtado et al. (2016) presented a multidimensional similarity measure, named MSM, for semantic trajectories. The MSM utilizes the multi-attribute information of the moving object besides the space and time. Meanwhile, it also defines the weight values for each attribute to represent the importance of them for different applications. Due to the ignorance of the MSM in revealing the relationship between attributes, Petry et al. (2019) proposed a multiple-aspect trajectory similarity measure MUITAS. The MUITAS takes into account the semantic relationship between attributes and can deal with trajectory data with heterogeneous semantic dimensions. It supports both independent and dependent attributes, a different distance function for each attribute, as well as a weight that represents the importance of each attribute. Pan, Ma, Zhang, and Wu (2018) put forward two trajectory similarity measures, MMTD and SUMTD, for multi-attributes trajectories, which support approximate similarity. Sharif and Alesheikh (2017) designed a modified version of dynamic time warping, named context-based dynamic time warping (CDTW), to contextually evaluate the multidimensional weighted similarities of trajectories.
Trajectory clustering, which aims at finding groups of similar trajectories, has received great attentions from an increasing number of researchers and it has become a basis for other important tasks. We will make a simple introduction to some recently proposed methods, and a detailed introduction can refer to the Ref. Bian, Tian, Tang, and Tao (2018). The trajectory clustering methods mainly include densely-based, hierarchical-based, spectral-based and community-based methods.
Mao, Zhong, Qi, Ping, and Li (2013) proposed an adaptive trajectory clustering approach based on the grid and density (ATCGD), which can realize adaptive parameter calibration and reduce the workload of trajectory clustering compared to the traditional TRACLUS algorithm (Lee et al., 2007). Hao et al. (2017) put forward an improved density-based K-means algorithm in trajectory data clustering, and demonstrated its better performance compared to the traditional K-means and the density-based spatial clustering algorithms. Zhang et al. (2018) proposed a trajectory clustering algorithm considering semantic spatial–temporal information such as direction, speed and time. Wu, Fu, Jiang, and Sigal (2016) utilized a kind of three-layer neural network, and proposed a novel clustering method for video understanding. Yao, Zhang, Zhu, Huang, and Bi (2017) leveraged the deep representation learning theory, and presented a new trajectory clustering method for finding clusters where the within-cluster similarity occurs in different regions and time periods. Rinzivillo et al. (2012) proposed a method for discovering the geographical borders of human mobility, and the novelty of their method lies in building a network representation of human movement and extract relevant clusters with community detection methods. Mahrsi and Rossi (2012) presented two approaches to cluster spatial trajectory data under constraints of an underlying road network. They first build a similarity graph by computing the number of common road segments between the individuals, then used the modularity-based community detection methods to cluster the graph. Liu and Wang, 2017, Liu et al., 2013 put forward a general framework, named TODMIS, for trajectory community discovery using multiple information sources. TODMIS combines additional information with raw trajectory data and construct the diffusion process on multiple similarity metrics. Then, dense sub-graph detection is used to discover the set of distinct communities.
Many real-world systems can be regarded as networks. In a network, a node means an object, and an edge represents the relation between the two nodes. A community is a subset of a collection of nodes in a network. The connections between nodes within subset are relatively close, while the connections between nodes among different subsets are relatively sparse. The community detection is a technology utilized to find these subsets.
At present, relevant scholars have carried out in-depth researches on the relevant characteristics of network structure, and proposed many effective community detection algorithms. These algorithms can be classified according to their research objects or purposes. Detailed reviews can be referred to Refs. Fortunato, 2010, Fortunato and Hric, 2016. In this section, we will classify the community detection methods into two kinds. According to the result of the divided communities, the community detection algorithms can be divided into non-overlapping community detection and overlapping community detection algorithms.
A non-overlapping community means that each node in the network can only belong to one community. Currently, some well-known non-overlapping community detection methods include: Fastgreedy algorithm (Clauset, Newman, & Moore, 2004), Louvain algorithm (Blondel, Guillaume, Lambiotte, & Lefebvre, 2008), Walktrap algorithm (Pons & Latapy, 2005), Infomap algorithm (Rosvall & Bergstrom, 2008) and Label Propagation algorithm (Raghavan, Albert, & Kumara, 2007). The Fastgreedy algorithm is a condensed community detection algorithm based on modularity optimization. The main idea is to merge two communities if they can achieve a higher modularity. Initially, treat each node as a separate community, and then continually merge them until the modularity of the network no longer increases. The Louvain algorithm is an improvement of the Fastgreedy algorithm by adding heuristic information to realize the division of the network community. The Walktrap algorithm and the Infomap algorithm are both community detection methods based on random walks. The difference is that the Infomap method introduces the coding technology, which transforms the partitioning problem of the network community structure into solving the expected coding length of the random path. The shorter the expected coding length, the better the community partitioning effect. The Label Propagation algorithm (LPA) initializes all nodes in the network into a different label, then assigns a random processing order to all nodes in the network, and updates the corresponding node according to the label with the largest number of nodes in its neighbors. Iterate until the labels of all nodes no longer change and reach a steady state. The weakness of the LPA is that the community partition results are not stable enough. The result of each partition depends on the initial label selection.
Later, some other famous community detection algorithms (Pons and Latapy, 2005, Raghavan et al., 2007, Rosvall and Bergstrom, 2008), which are based on random walk, were presented, and can get better results in some conditions. The key point of the random walk methods lies in choosing some metric functions so as to measure the distance between the nodes. Inspired by these methods, some novel community detection methods based on metric space have been put forward recently. De Meo, Ferrara, Fiumara, and Provetti (2014) utilized the edge centrality to compute all-pairs distances between nodes in networks, and then partitioned the network into clusters according to those distances. Saha and Ghrera (2015) transformed a graph into a metric space, and then detected communities by using K partitioning algorithm on the constructed space. You, Cheng, Ning, Shia, and Zhang (2016) mapped the network into a lower dimensional space, and then used density-based clustering algorithm to detect the community structures. Zarandi and Rafsanjani (2018) converted the network into several disconnected components, and merged these components and selected the best communities based on the proposed identified evaluation function.
As community detection technology continues evolving, researchers have found that many nodes in a real-world network tend to belong to multiple communities at the same time. That is, there exists overlap between communities. In 2005, Palla, Derényi, Farkas, and Vicsek (2005) proposed a factional filtering algorithm CPM based on overlapping community detection, which aroused people’s enthusiasm for overlapping communities. In the network, by expanding the local seed communities, overlapping communities can also be formed. Based on this idea, Lancichinetti, Fortunato, and Kertesz (2009) proposed the LFM algorithm based on local optimization. Based on the idea of greedy optimization, Jin, Gabrys, and Dang (2015) proposed an overlapping community detection method combining nodes and edges by using local extension. In the network structure, the edges in the network have natural non-overlapping characteristics. Based on this idea, Evans and Lambiotte (2009) and Ahn, Bagrow, and Lehmann (2010) proposed community detection methods based on edge partition.
In this section, we firstly propose a general similarity measure method for semantic trajectories, and then present a semantic trajectory clustering algorithm based on community detection in networks.
Lets consider an example presented in Fig. 1. There are five trajectories with different colors, named T1<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub></mrow></math> to T5<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">5</mn></mrow></msub></mrow></math>. For simplicity, we only consider three attributes of each point in each trajectory, which are position, time and weather. Take T1<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub></mrow></math> as an example. The person stayed at home at 7:00 AM, and the weather was sunny. Then, at 8:00 AM, this person got to the airport. After several hours later, he reached the bus station at 16:00 PM and arrived at a hotel at 18:00 PM. For traditional spatial–temporal trajectory similarity methods, trajectories T3<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">3</mn></mrow></msub></mrow></math> and T4<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">4</mn></mrow></msub></mrow></math> are obviously different from each other. That is because they do not have similar place sequence. However, if we take the hierarchical semantic information into account, there exists some similarities between them. That is because gym and park belong to places for entertainment at a higher level of semantics, and have similarities in some way. Therefore, it is necessary to take semantic information of the trajectory into account for similarity analysis in order to more accurately describe the similarity between trajectories. Next, we will illustrate the details of the proposed semantic similarity method and the trajectory clustering algorithm.
This part will introduce some concepts which will be used in this paper. The definitions of semantic trajectories and semantic trajectories similarity are described as follows:
A semantic trajectory Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> is a sequence of sample points, which is denoted by Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math>={ti,1,ti,2<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mn is="true">2</mn></mrow></msub></mrow></math>, …, ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math>, …, ti,n<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">n</mi></mrow></msub></mrow></math>}, n is the length of the Ti,ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math> (1⩽j⩽n<math><mrow is="true"><mn is="true">1</mn><mo is="true">⩽</mo><mi is="true">j</mi><mo is="true">⩽</mo><mi is="true">n</mi></mrow></math>) is the sample point, and can be represented as P dimensional tuple ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math>=(A1,A2<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub></mrow></math>, …, AP<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">P</mi></mrow></msub></mrow></math>), ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math> includes a series of attributes, such as space, time and other semantic attributes.
For a pair of semantic trajectories Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math>={ti,1,ti,2<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mn is="true">2</mn></mrow></msub></mrow></math>, …, ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math>, …, ti,n<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">n</mi></mrow></msub></mrow></math>} and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math>={tk,1,tk,2<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mn is="true">2</mn></mrow></msub></mrow></math>, …, tk,l<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></math>, …, tk,m<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">m</mi></mrow></msub></mrow></math>}, the similarity between Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math> is defined as (Petry et al., 2019, Furtado et al., 2016):(1)sim_T(Ti,Tk)=Σti,jmax({sim_t(ti,j,tk,l)|tk,l∈Tk})+Σtk,lmax({sim_t(tk,l,ti,j)|ti,j∈Ti})|Ti|+|Tk|<math><mi mathvariant="italic" is="true">sim</mi><mo is="true">_</mo><mi is="true">T</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo linebreak="goodbreak" is="true">=</mo><mfrac is="true"><mrow is="true"><msub is="true"><mrow is="true"><mi mathvariant="normal" is="true">Σ</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></msub><mrow is="true"><mi mathvariant="normal" is="true">max</mi></mrow><mo stretchy="false" is="true">(</mo><mo stretchy="false" is="true">{</mo><mi mathvariant="italic" is="true">sim</mi><mo is="true">_</mo><mi is="true">t</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">|</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo is="true">∈</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub><mo stretchy="false" is="true">}</mo><mo stretchy="false" is="true">)</mo><mo is="true">+</mo><msub is="true"><mrow is="true"><mi mathvariant="normal" is="true">Σ</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></msub><mrow is="true"><mi mathvariant="normal" is="true">max</mi></mrow><mo stretchy="false" is="true">(</mo><mo stretchy="false" is="true">{</mo><mi mathvariant="italic" is="true">sim</mi><mo is="true">_</mo><mi is="true">t</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">|</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">∈</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo stretchy="false" is="true">}</mo><mo stretchy="false" is="true">)</mo></mrow><mrow is="true"><mo stretchy="false" is="true">|</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo stretchy="false" is="true">|</mo><mo is="true">+</mo><mo stretchy="false" is="true">|</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub><mo stretchy="false" is="true">|</mo></mrow></mfrac></math>
The formula (1) is a general semantic trajectory similarity function on the basis of previous works (Petry et al., 2019, Furtado et al., 2016), and it consists of two parts. It measures the similarity between the two trajectories Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math> by calculating the sum of the maximum similarities between the sample points in each trajectory. The first part of (1) is Σti,jmax({sim_t(ti,j,tk,l)|tk,l∈Tk})<math><mrow is="true"><msub is="true"><mrow is="true"><mi mathvariant="normal" is="true">Σ</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></msub><mi mathvariant="normal" is="true">max</mi><mo stretchy="false" is="true">(</mo><mo stretchy="false" is="true">{</mo><mi mathvariant="italic" is="true">sim</mi><mo is="true">_</mo><mi is="true">t</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">|</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo is="true">∈</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub><mo stretchy="false" is="true">}</mo><mo stretchy="false" is="true">)</mo></mrow></math>. For each sample point ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math> in Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math>, find the sample point that is most similar to it in Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math>, and perform a summation operation.The second part of (1) is Σtk,lmax({sim_t(tk,l,ti,j)|ti,j∈Ti})<math><mrow is="true"><msub is="true"><mrow is="true"><mi mathvariant="normal" is="true">Σ</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></msub><mi mathvariant="normal" is="true">max</mi><mo stretchy="false" is="true">(</mo><mo stretchy="false" is="true">{</mo><mi mathvariant="italic" is="true">sim</mi><mo is="true">_</mo><mi is="true">t</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">|</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">∈</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo stretchy="false" is="true">}</mo><mo stretchy="false" is="true">)</mo></mrow></math>. For each sample point tk,l<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></math> in Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math>, seek the sample point that is most similar to it in Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math>, and also perform a summation operation. Then, add these two parts and normalize them by dividing the total number of samples in Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math>. The similarity between any two sample points ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math> and tk,l<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></math> can be defined as (Petry et al., 2019, Furtado et al., 2016):(2)sim_t(ti,j,tk,l)=w1match1(A1)+w2match2(A2),…,wpmatchp(Ap)<math><mi mathvariant="italic" is="true">sim</mi><mo is="true">_</mo><mi is="true">t</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo linebreak="goodbreak" is="true">=</mo><msub is="true"><mrow is="true"><mi is="true">w</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">match</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo stretchy="false" is="true">)</mo><mo linebreak="badbreak" is="true">+</mo><msub is="true"><mrow is="true"><mi is="true">w</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">match</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">w</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">match</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub><mo stretchy="false" is="true">)</mo></math>where wp<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">w</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math> defines a corresponding weight for each attribute, and Σp=1|p|wp=1<math><mrow is="true"><msubsup is="true"><mrow is="true"><mi mathvariant="normal" is="true">Σ</mi></mrow><mrow is="true"><mi is="true">p</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mrow is="true"><mo stretchy="false" is="true">|</mo><mi is="true">p</mi><mo stretchy="false" is="true">|</mo></mrow></msubsup><msub is="true"><mrow is="true"><mi is="true">w</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">1</mn></mrow></math>. The function matchp<math><mrow is="true"><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">match</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math> can measure the similarity degree of the attribute Ap<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math>. Two kinds of functions can be defined to do this. The first one is distance matching function, and the second one is the semantic matching function. Then, we will define these two functions.
Let Ti={ti,1,ti,2,…,ti,j,…,ti,n}<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mo stretchy="false" is="true">{</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">n</mi></mrow></msub><mo stretchy="false" is="true">}</mo></mrow></math> and Tk={tk,1,tk,2,…,tk,l,…,tk,m}<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mo stretchy="false" is="true">{</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">m</mi></mrow></msub><mo stretchy="false" is="true">}</mo></mrow></math> be a pair of trajectories. For any two sample points ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math> and tk,l<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></math>, the distance matching function between them on numeric attribute Ap<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math> is defined as follows (Petry et al., 2019, Furtado et al., 2016):(3)matchdistance(Ap)=1,ifdistAp(ti,j,tk,l)⩽δAp;0,otherwise.<math><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">match</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">distance</mi></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo linebreak="goodbreak" is="true">=</mo><mrow is="true"><mfenced open="{" close="" is="true"><mrow is="true"><mtable is="true"><mtr is="true"><mtd columnalign="left" is="true"><mn is="true">1</mn><mo is="true">,</mo><mspace width="2em" is="true"></mspace><mi mathvariant="italic" is="true">if</mi><mspace width="1em" is="true"></mspace><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">dist</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo is="true">⩽</mo><msub is="true"><mrow is="true"><mi is="true">δ</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></msub><mtext is="true">;</mtext></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><mn is="true">0</mn><mo is="true">,</mo><mspace width="2em" is="true"></mspace><mi mathvariant="italic" is="true">otherwise</mi><mtext is="true">.</mtext></mtd></mtr></mtable></mrow></mfenced></mrow></math>where distAp(ti,j,tk,l)<math><mrow is="true"><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">dist</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math> and δAp<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">δ</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></msub></mrow></math> are separately a distance function and a distance threshold for the attribute Ap<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math>. The distance function includes Euclidean, Dynamic Time Warp (DWT), Manhattan and so on. δAp<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">δ</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></msub></mrow></math> is set according to the specific application background.
Let Ti={ti,1,ti,2,…,ti,j,…,ti,n}<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mo stretchy="false" is="true">{</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">n</mi></mrow></msub><mo stretchy="false" is="true">}</mo></mrow></math> and Tk={tk,1,tk,2,…,tk,l,…,tk,m}<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mo stretchy="false" is="true">{</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">m</mi></mrow></msub><mo stretchy="false" is="true">}</mo></mrow></math> be a pair of trajectories. For any two sample points ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math> and tk,l<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></math>, the semantic matching function between them on attribute Ap<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math> is defined as follows:(4)matchsemantic(Ap)=1,ifCategoryAp(ti,j)=CategoryAp(tk,l);0,otherwise.<math><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">match</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">semantic</mi></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo linebreak="goodbreak" is="true">=</mo><mrow is="true"><mfenced open="{" close="" is="true"><mrow is="true"><mtable is="true"><mtr is="true"><mtd columnalign="left" is="true"><mn is="true">1</mn><mo is="true">,</mo><mspace width="2em" is="true"></mspace><mi mathvariant="italic" is="true">if</mi><mspace width="1em" is="true"></mspace><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">Category</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">Category</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mtext is="true">;</mtext></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><mn is="true">0</mn><mo is="true">,</mo><mspace width="2em" is="true"></mspace><mi mathvariant="italic" is="true">otherwise</mi><mtext is="true">.</mtext></mtd></mtr></mtable></mrow></mfenced></mrow></math>where CategoryAp(·)<math><mrow is="true"><msub is="true"><mrow is="true"><mi mathvariant="italic" is="true">Category</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></msub><mo stretchy="false" is="true">(</mo><mo is="true">·</mo><mo stretchy="false" is="true">)</mo></mrow></math> is a category hierarchy tree function concerning attribute Ap<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math>, which can measure if the attribute values of the Ap<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math> can be classified into the same category at a certain level or they are equal to each other on the leaf node. According to (4), we can judge whether the attribute values of Ap<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">A</mi></mrow><mrow is="true"><mi is="true">p</mi></mrow></msub></mrow></math> of any two trajectories match to each other in different hierarchy. For instance, Fig. 2 is a category hierarchy tree about location attribute based on ontology. Due to limited space, we only list some representative categories. A yellow node represents a location category. The green category nodes are subsets of their corresponding yellow category nodes, and specific locations may belong to their corresponding green category nodes. For example, the location Kentucky Fried Chicken (KFC) and McDonald belong to the fast food restaurant, and if they appear in different trajectories (Lee & Chung, 2011), there may exist some similarities between these trajectories if from a fast food perspective.
The basic idea of the semantic match method is inspired by the semantic similarity based on ontology theory. At present, there are mainly three measures for computing the semantic similarity, which are path-based methods (Wu and Palmer, 1994, Fellbaum and Miller, 1998), information-based methods (Meng et al., 2013, Jiang et al., 2017) and hybrid methods (Aouicha et al., 2016, Gao et al., 2015). Recent studies (Qu et al., 2018, Hussain et al., 2020) show that the latter two methods are more efficient and accurate compared to the first one. In some application scenarios, such as topic detection in literatures (Jayabharathy, Kanmani, & Parveen, 2011), web search (d’Amato, Fanizzi, Fazzinga, Gottlob, & Lukasiewicz, 2012) and online social network analysis (Zhang, Zheng, & Hu, 2015), the information-based ontology semantic similarity computation methods can get better results compared to others. That because some external knowledge resources, such as Wikipedia and WordNet, can be utilized to facilitate the computation process of the semantic similarity. According to these external data sources, we can construct a graph like the Fig. 2. All kinds of concepts are represented by the nodes of the graph, the edges denote the different taxonomic relations such as super-class and sub-class between them. Then, we can identify the single most informative common ancestor of given concepts so as to compute the semantic similarity.
From what has been analyzed above, we can see that many traditional trajectory similarity methods based on spatial–temporal information can be attributed to a special situation of formula (1). Besides, some recently proposed semantic trajectory similarity methods can be also regarded as an extended version of it by considering semantic attributes. For instance, Furtado et al. (2016) put forward a novel similarity measure for multidimensional sequences by considering the semantic dimensions. Petry et al. (2019) presented a novel similarity measure considering the relationship between attributes. Pan et al. (2018) proposed a maximum-minimum trajectory distance method and analyzed the correlation among the spatial–temporal similarity and textual similarity.
Currently, there are mainly two kinds of methods to construct a network based on the similarity among trajectories. The first is K-nearest neighbor network (K-NN) construction methods. In this way, each trajectory is represented as a node, and it is connected to its K most similar ones. The second is ε<math><mrow is="true"><mi is="true">ε</mi></mrow></math>-nearest neighbor network (ε<math><mrow is="true"><mi is="true">ε</mi></mrow></math>-NN) construction methods. In this case, each pair of trajectories will be connected if the similarity value between them is higher than threshold ε<math><mrow is="true"><mi is="true">ε</mi></mrow></math>.
However, recent studies (Berton and de Andrade Lopes, 2015, Berton et al., 2018, De Sousa et al., 2013) have pointed out that the ε<math><mrow is="true"><mi is="true">ε</mi></mrow></math>-NN method is very sensitive to the parameter ε<math><mrow is="true"><mi is="true">ε</mi></mrow></math>, and it is not widely used in practical situations. That is because it may generate networks with many disconnected parts for an improper value of ε<math><mrow is="true"><mi is="true">ε</mi></mrow></math>. Due to this fact, we utilize the K-NN method in our experiments.
The semantic trajectory clustering framework based on community detection (STCCD) in network is shown in Fig. 3. The framework consists of four modules, namely trajectory data processing, similar matrix construction, trajectory network construction and trajectory community detection. Since the trajectory data processing belongs to the data processing stage, it is not in the scope of our study, this paper mainly studies the latter three modules.
The execution process of the STCCD algorithm is shown in Algorithm 1, which will be described in detail as follows:
(1) Steps 1∼<math><mrow is="true"><mo is="true">∼</mo></mrow></math>7: Calculate the similarity of the sample points in each pair of semantic trajectories Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math> based on the distance matching function and semantic matching function defined above. Then, calculate the maximum similarity between each sample point in Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math>, and perform a summation operation in order to measure the overall similarity between Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math>. The similarity definition of Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math> is presented in formula (1).
(2) Steps 8∼<math><mrow is="true"><mo is="true">∼</mo></mrow></math>9: Construct a similarity matrix S, where sik<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">s</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">ik</mi></mrow></msub></mrow></math> is an element in S, representing the similarity between the trajectories Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math>.
(3) Steps 10∼<math><mrow is="true"><mo is="true">∼</mo></mrow></math>14: According to the similarity matrix S, the K-NN method is used to construct a trajectory network G. Firstly, construct a network G with N nodes and zero edges. Then, for each node vTi<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">v</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></msub></mrow></math> in G, based on the similarity matrix S, select K nodes most similar to the node vTi<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">v</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></msub></mrow></math>, add an edge between vTi<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">v</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></msub></mrow></math> and these nodes. Finally, a trajectory network G with N nodes is constructed. The nodes in G represent semantic trajectories, and the edges represent relationships between trajectories with higher similarity.
(4) Steps 15∼<math><mrow is="true"><mo is="true">∼</mo></mrow></math>16: On the constructed trajectory network G, the community detection algorithm is utilized to find the trajectory clusters.
Next, lets consider the time complexity of the Algorithm 1, which can be defined as the sum of the complexity of each step. Consider a dataset with n trajectories, and the average length of them is l. Construct a network based on the similarity computation for each trajectory needs a total of time complexity O(n2l)<math><mrow is="true"><mo stretchy="false" is="true">(</mo><msup is="true"><mrow is="true"><mi is="true">n</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msup><mi is="true">l</mi><mo stretchy="false" is="true">)</mo></mrow></math>. And the time complexity for community detection lies in the choice of the algorithm. Then, we list the time complexity of some widely used community detection methods in Table 1, which will be utilized in our experiments.Algorithm 1: Semantic Trajectory Clustering based on Community Detection (STCCD)Input: AsemantictrajectorysetT={T1,T2,…,Ti,…,TN},TiisanelementofT,NisthenumberofelementsinT.<math><mrow is="true"><mi is="true">A</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">semantic</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">trajectory</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">set</mi><mspace width="0.35em" is="true"></mspace><mi is="true">T</mi><mo linebreak="goodbreak" is="true">=</mo><mo stretchy="false" is="true">{</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">N</mi></mrow></msub><mo stretchy="false" is="true">}</mo><mo is="true">,</mo><mspace width="0.35em" is="true"></mspace><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">is</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">an</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">element</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">of</mi><mspace width="0.35em" is="true"></mspace><mi is="true">T</mi><mo is="true">,</mo><mspace width="0.35em" is="true"></mspace><mi is="true">N</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">is</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">the</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">number</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">of</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">elements</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">in</mi><mspace width="0.35em" is="true"></mspace><mi is="true">T</mi><mtext is="true">.</mtext></mrow></math>Output: AsetofsemantictrajectoryclustersC={C1,C2,…,CZ},Zisthenumberoftrajectoryclusters.<math><mrow is="true"><mi is="true">A</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">set</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">of</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">semantic</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">trajectory</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">clusters</mi><mspace width="0.35em" is="true"></mspace><mi is="true">C</mi><mo linebreak="goodbreak" is="true">=</mo><mo stretchy="false" is="true">{</mo><msub is="true"><mrow is="true"><mi is="true">C</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">C</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">C</mi></mrow><mrow is="true"><mi is="true">Z</mi></mrow></msub><mo stretchy="false" is="true">}</mo><mo is="true">,</mo><mspace width="0.35em" is="true"></mspace><mi is="true">Z</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">is</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">the</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">number</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">of</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">trajectory</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">clusters</mi><mtext is="true">.</mtext></mrow></math>1:/* Computethesimilarityforeachpairofsemantictrajectories<math><mrow is="true"><mi mathvariant="italic" is="true">Compute</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">the</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">similarity</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">for</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">each</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">pair</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">of</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">semantic</mi><mspace width="0.35em" is="true"></mspace><mi mathvariant="italic" is="true">trajectories</mi></mrow></math> */2: for allTi,Tj∈T<math><mrow is="true"><mi mathvariant="italic" is="true">all</mi><mspace width="0.35em" is="true"></mspace><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub><mo is="true">,</mo><mspace width="0.35em" is="true"></mspace><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">j</mi></mrow></msub><mo is="true">∈</mo><mi is="true">T</mi></mrow></math> do3: for all<math><mrow is="true"><mi mathvariant="italic" is="true">all</mi></mrow></math> Ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math> ∈<math><mrow is="true"><mo is="true">∈</mo></mrow></math> Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math>, tk,l<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></math> ∈<math><mrow is="true"><mo is="true">∈</mo></mrow></math> Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math> do4: compute<math><mrow is="true"><mi mathvariant="italic" is="true">compute</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> semantic<math><mrow is="true"><mi mathvariant="italic" is="true">semantic</mi></mrow></math> similarity<math><mrow is="true"><mi mathvariant="italic" is="true">similarity</mi></mrow></math> sim_t(ti,j,tk,l)<math><mrow is="true"><mi mathvariant="italic" is="true">sim</mi><mo is="true">_</mo><mi is="true">t</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math> between<math><mrow is="true"><mi mathvariant="italic" is="true">between</mi></mrow></math> ti,j<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub></mrow></math> and<math><mrow is="true"><mi mathvariant="italic" is="true">and</mi></mrow></math> tk,l<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub></mrow></math> based<math><mrow is="true"><mi mathvariant="italic" is="true">based</mi></mrow></math> on<math><mrow is="true"><mi mathvariant="italic" is="true">on</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> distance<math><mrow is="true"><mi mathvariant="italic" is="true">distance</mi></mrow></math> matching<math><mrow is="true"><mi mathvariant="italic" is="true">matching</mi></mrow></math> function<math><mrow is="true"><mi mathvariant="italic" is="true">function</mi></mrow></math> and<math><mrow is="true"><mi mathvariant="italic" is="true">and</mi></mrow></math> semantic<math><mrow is="true"><mi mathvariant="italic" is="true">semantic</mi></mrow></math> matching<math><mrow is="true"><mi mathvariant="italic" is="true">matching</mi></mrow></math> function<math><mrow is="true"><mi mathvariant="italic" is="true">function</mi></mrow></math>.5: end for6: compute<math><mrow is="true"><mi mathvariant="italic" is="true">compute</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> trajectory<math><mrow is="true"><mi mathvariant="italic" is="true">trajectory</mi></mrow></math> similarity<math><mrow is="true"><mi mathvariant="italic" is="true">similarity</mi></mrow></math> sim_T(ti,j,tk,l)<math><mrow is="true"><mi mathvariant="italic" is="true">sim</mi><mo is="true">_</mo><mi is="true">T</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mi is="true">k</mi><mo is="true">,</mo><mi is="true">l</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math> based<math><mrow is="true"><mi mathvariant="italic" is="true">based</mi></mrow></math> on<math><mrow is="true"><mi mathvariant="italic" is="true">on</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> sum<math><mrow is="true"><mi mathvariant="italic" is="true">sum</mi></mrow></math> of<math><mrow is="true"><mi mathvariant="italic" is="true">of</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> max<math><mrow is="true"><mi mathvariant="italic" is="true">max</mi></mrow></math> similarities<math><mrow is="true"><mi mathvariant="italic" is="true">similarities</mi></mrow></math> for<math><mrow is="true"><mi mathvariant="italic" is="true">for</mi></mrow></math> all<math><mrow is="true"><mi mathvariant="italic" is="true">all</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> sampling<math><mrow is="true"><mi mathvariant="italic" is="true">sampling</mi></mrow></math> points<math><mrow is="true"><mi mathvariant="italic" is="true">points</mi></mrow></math> in<math><mrow is="true"><mi mathvariant="italic" is="true">in</mi></mrow></math> Ti<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></math> and<math><mrow is="true"><mi mathvariant="italic" is="true">and</mi></mrow></math> Tk<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">k</mi></mrow></msub></mrow></math>.7: end for8:/* Construct<math><mrow is="true"><mi mathvariant="italic" is="true">Construct</mi></mrow></math> a<math><mrow is="true"><mi is="true">a</mi></mrow></math> similarity<math><mrow is="true"><mi mathvariant="italic" is="true">similarity</mi></mrow></math> matrix<math><mrow is="true"><mi mathvariant="italic" is="true">matrix</mi></mrow></math> */9: Store<math><mrow is="true"><mi mathvariant="italic" is="true">Store</mi></mrow></math> all<math><mrow is="true"><mi mathvariant="italic" is="true">all</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> similarity<math><mrow is="true"><mi mathvariant="italic" is="true">similarity</mi></mrow></math> values<math><mrow is="true"><mi mathvariant="italic" is="true">values</mi></mrow></math> between<math><mrow is="true"><mi mathvariant="italic" is="true">between</mi></mrow></math> semantic<math><mrow is="true"><mi mathvariant="italic" is="true">semantic</mi></mrow></math> trajectories<math><mrow is="true"><mi mathvariant="italic" is="true">trajectories</mi></mrow></math> in<math><mrow is="true"><mi mathvariant="italic" is="true">in</mi></mrow></math> T<math><mrow is="true"><mi is="true">T</mi></mrow></math> into<math><mrow is="true"><mi mathvariant="italic" is="true">into</mi></mrow></math> a<math><mrow is="true"><mi is="true">a</mi></mrow></math> matrix<math><mrow is="true"><mi mathvariant="italic" is="true">matrix</mi></mrow></math> S<math><mrow is="true"><mi is="true">S</mi></mrow></math>.10:/* Construct<math><mrow is="true"><mi mathvariant="italic" is="true">Construct</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> K<math><mrow is="true"><mi is="true">K</mi></mrow></math>-NN<math><mrow is="true"><mi mathvariant="italic" is="true">NN</mi></mrow></math> trajectory<math><mrow is="true"><mi mathvariant="italic" is="true">trajectory</mi></mrow></math> network<math><mrow is="true"><mi mathvariant="italic" is="true">network</mi></mrow></math> */11: Construct<math><mrow is="true"><mi mathvariant="italic" is="true">Construct</mi></mrow></math> a<math><mrow is="true"><mi is="true">a</mi></mrow></math> network<math><mrow is="true"><mi mathvariant="italic" is="true">network</mi></mrow></math> graph<math><mrow is="true"><mi mathvariant="italic" is="true">graph</mi></mrow></math> G<math><mrow is="true"><mi is="true">G</mi></mrow></math> with<math><mrow is="true"><mi mathvariant="italic" is="true">with</mi></mrow></math> N<math><mrow is="true"><mi is="true">N</mi></mrow></math> points<math><mrow is="true"><mi mathvariant="italic" is="true">points</mi></mrow></math> and<math><mrow is="true"><mi mathvariant="italic" is="true">and</mi></mrow></math> zero<math><mrow is="true"><mi mathvariant="italic" is="true">zero</mi></mrow></math> edge<math><mrow is="true"><mi mathvariant="italic" is="true">edge</mi></mrow></math>, N<math><mrow is="true"><mi is="true">N</mi></mrow></math> is<math><mrow is="true"><mi mathvariant="italic" is="true">is</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> number<math><mrow is="true"><mi mathvariant="italic" is="true">number</mi></mrow></math> of<math><mrow is="true"><mi mathvariant="italic" is="true">of</mi></mrow></math> T<math><mrow is="true"><mi is="true">T</mi></mrow></math>.12: For each<math><mrow is="true"><mi mathvariant="italic" is="true">each</mi></mrow></math> point<math><mrow is="true"><mi mathvariant="italic" is="true">point</mi></mrow></math> vTi<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">v</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></msub></mrow></math> in<math><mrow is="true"><mi mathvariant="italic" is="true">in</mi></mrow></math> G<math><mrow is="true"><mi is="true">G</mi></mrow></math> do13: choose<math><mrow is="true"><mi mathvariant="italic" is="true">choose</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> most<math><mrow is="true"><mi mathvariant="italic" is="true">most</mi></mrow></math> similar<math><mrow is="true"><mi mathvariant="italic" is="true">similar</mi></mrow></math> K<math><mrow is="true"><mi is="true">K</mi></mrow></math> trajectories<math><mrow is="true"><mi mathvariant="italic" is="true">trajectories</mi></mrow></math> of<math><mrow is="true"><mi mathvariant="italic" is="true">of</mi></mrow></math> vTi<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">v</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></msub></mrow></math> based<math><mrow is="true"><mi mathvariant="italic" is="true">based</mi></mrow></math> on<math><mrow is="true"><mi mathvariant="italic" is="true">on</mi></mrow></math> S<math><mrow is="true"><mi is="true">S</mi></mrow></math>, and<math><mrow is="true"><mi mathvariant="italic" is="true">and</mi></mrow></math> add<math><mrow is="true"><mi mathvariant="italic" is="true">add</mi></mrow></math> K<math><mrow is="true"><mi is="true">K</mi></mrow></math> edges<math><mrow is="true"><mi mathvariant="italic" is="true">edges</mi></mrow></math> between<math><mrow is="true"><mi mathvariant="italic" is="true">between</mi></mrow></math> vTi<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">v</mi></mrow><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mi is="true">i</mi></mrow></msub></mrow></msub></mrow></math> and<math><mrow is="true"><mi mathvariant="italic" is="true">and</mi></mrow></math> them<math><mrow is="true"><mi mathvariant="italic" is="true">them</mi></mrow></math>.14: end for15:/* Execute<math><mrow is="true"><mi mathvariant="italic" is="true">Execute</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> community<math><mrow is="true"><mi mathvariant="italic" is="true">community</mi></mrow></math> detection<math><mrow is="true"><mi mathvariant="italic" is="true">detection</mi></mrow></math> on<math><mrow is="true"><mi mathvariant="italic" is="true">on</mi></mrow></math> the<math><mrow is="true"><mi mathvariant="italic" is="true">the</mi></mrow></math> constructed<math><mrow is="true"><mi mathvariant="italic" is="true">constructed</mi></mrow></math> graph<math><mrow is="true"><mi mathvariant="italic" is="true">graph</mi></mrow></math>*/16: Apply<math><mrow is="true"><mi mathvariant="italic" is="true">Apply</mi></mrow></math> a<math><mrow is="true"><mi is="true">a</mi></mrow></math> community<math><mrow is="true"><mi mathvariant="italic" is="true">community</mi></mrow></math> detection<math><mrow is="true"><mi mathvariant="italic" is="true">detection</mi></mrow></math> algorithm<math><mrow is="true"><mi mathvariant="italic" is="true">algorithm</mi></mrow></math> on<math><mrow is="true"><mi mathvariant="italic" is="true">on</mi></mrow></math> G<math><mrow is="true"><mi is="true">G</mi></mrow></math> to<math><mrow is="true"><mi mathvariant="italic" is="true">to</mi></mrow></math> get<math><mrow is="true"><mi mathvariant="italic" is="true">get</mi></mrow></math> semantic<math><mrow is="true"><mi mathvariant="italic" is="true">semantic</mi></mrow></math> trajectory<math><mrow is="true"><mi mathvariant="italic" is="true">trajectory</mi></mrow></math> clusters<math><mrow is="true"><mi mathvariant="italic" is="true">clusters</mi></mrow></math> C=<math><mrow is="true"><mi is="true">C</mi><mo linebreak="newline" is="true">=</mo></mrow></math>{C1,C2,…,Cj,…,CZ}<math><mrow is="true"><mo stretchy="false" is="true">{</mo><msub is="true"><mrow is="true"><mi is="true">C</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">C</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">C</mi></mrow><mrow is="true"><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">C</mi></mrow><mrow is="true"><mi is="true">Z</mi></mrow></msub><mo stretchy="false" is="true">}</mo></mrow></math>.
Recent studies (Wagenseller, Wang, & Wu, 2018) have shown that the Infomap method presents a better performance in detecting community partitions in the social network data, and the results are more stable compared to other widely used methods. The basic idea behind the Infomap algorithm is to use community partitions of the network as a Huffman code that compresses the information about a random walker exploring the network. The random walker explores the network with the probability that the walker transitions between two nodes given by its Markov transition matrix. Then, we can effectively code the network with an individual codeword for each node. The Infomap links community detection with two-layer information coding. A good network partition can lead to shorter coding. Therefore, if the coding length can be quantified, and the community partitions with the shortest coding length are found, then we can say that this kind of network partition is the best.
From Table 1, we can see that some community detection methods are less time-consuming. For instance, the famous label propagation algorithm (Raghavan et al., 2007) and the Infomap algorithm (Rosvall & Bergstrom, 2008) even have a linear time complexity. Therefore, the overall time complexity for the STCCD is O(n2l)<math><mrow is="true"><mo stretchy="false" is="true">(</mo><msup is="true"><mrow is="true"><mi is="true">n</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msup><mi is="true">l</mi><mo stretchy="false" is="true">)</mo></mrow></math>.
In terms of evaluation methods (Liu, Li, Xiong, Gao, & Wu, 2010), we employ the Silhouette Coefficient (Rousseeuw, 1987), Baker–Hubert Gamma index (Baker & Hubert, 1975) and Hubert & Levin C index (Hubert & Levin, 1976) to evaluate the performance of the proposed algorithm. Next, let’s have a brief introduction to above evaluation methods.
Silhouette Coefficient: The Silhouette Coefficient (Rousseeuw, 1987) was firstly proposed by Peter J. Rousseeuw, and is widely used in many Refs. Wang and Xu, 2017, Tellaroli et al., 2016. It combines both cohesion and resolution, and can be used to measure the performance of clustering algorithms. The Silhouette Coefficient value is between −1 and 1, and the larger the value, the better the clustering results.
Baker–Hubert Gamma index: The Baker–Hubert Gamma index (Baker & Hubert, 1975) is an adaptation of Goodman & Kruskals Gamma statistics (Goodman & Kruskal, 1972), and it is a measure of compactness based on similarity between points in a cluster, compared to similarity with points in other clusters. The target value of this index is the maximum, and it is bounded by 1.
Hubert & Levin C index: The Hubert & Levin C index (Hubert & Levin, 1976) considers the distances between the pairs of points inside each cluster. It presents how much the observed within-cluster density is relatively close to such sum utmost maximal under the given number of within-cluster proximities. It varies between 0 and 1. The lower is the value, the better is the cluster partition.
In this section, we show a toy example utilizing the five trajectories presented in Fig. 1. According to Algorithm 1, the first step is to construct a similarity matrix. Here, we design an extended version (Petry et al., 2019) to compute the similarity between two trajectories. One weak of the Ref. Petry et al. (2019) is that it only regards the two semantic attributes are similar when they are exactly the same, which cannot fulfil the practical conditions if users need to consider the trajectory similarity from a higher level. Therefore, we use the concept of semantic matching function defined above to fill this gap. For instance, in Fig. 1, t1,1<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mn is="true">1</mn><mo is="true">,</mo><mn is="true">1</mn></mrow></msub></mrow></math> (location) = home, and t5,1<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">t</mi></mrow><mrow is="true"><mn is="true">5</mn><mo is="true">,</mo><mn is="true">1</mn></mrow></msub></mrow></math> (location) = hotel, so they do not match to each other. But if we take them into account from a higher semantic level, they are similar to each other because they are all belong to the place for living.
According to Algorithm 1, the similarity between semantic trajectories is firstly calculated, and then a similarity matrix is constructed. In this example, the Euclidean distance function is used for the time attribute with a threshold of 1 h, and the semantic matching functions for the position and weather attributes are used. Besides, some parameters are set below, w1=0.5<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">w</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">0.5</mn></mrow></math>, w2=0.4<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">w</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">0.4</mn></mrow></math>, w3=0.1<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">w</mi></mrow><mrow is="true"><mn is="true">3</mn></mrow></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">0.1</mn></mrow></math>.
The newly proposed MUITAS method is utilized to measure the similarity between trajectories, but it is improved by considering the hierarchical relationship between position and time attributes. For the location attribute, this paper uses the hierarchical tree of the location presented in Fig. 2. For the time attribute, this paper divides it into time periods, thus obtaining the hierarchical relationship of time attributes (6:00–12:00 for the morning, 12:00–18:00 for the afternoon and 18:00–06:00 for the evening).
For the above trajectories, each attribute is regarded as a feature. The constructed similarity matrix is presented in Table 2. Each element in the matrix represents the similarity degree between two trajectories. If we consider the attribute location and time from a high level, the similarity matrix is presented in Table 3, and the similarity degree between some trajectories become denser. Different semantic matching hierarchies can be selected according to practical needs. Furthermore, we also show the trajectory similarity heat maps obtained at different semantic levels corresponding to toy dataset in Fig. 4. There are 5 trajectories in total, the heat maps in Fig. 4 represent similarities between trajectories corresponding to the Tables 2 and 3. we label the column and row name for each trajectory with {T1,T2,T3,T4,T5<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">3</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">4</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">5</mn></mrow></msub></mrow></math>} in heat maps. The color of each small square indicates the strength of similarity between the two trajectories. The two trajectories with lower similarity are represented by small blue squares, and the higher similarity is represented by small red squares. The specific values are indicated by the gradient bars on the right side of the figure. The tree diagrams of the heatmap indicate that the trajectory similarity matrix is reordered by hierarchical clustering method according to the similarity degree between trajectories.
Different semantic matching hierarchies can be selected according to practical needs. In this example, based on the similarity matrix of Tables 2 and 3, we construct two semantic trajectory networks based on the K-NN method (K = 1), then the Infomap community detection algorithm is used on the constructed networks, and the obtained trajectory partitions are shown in Fig. 5(a) and (b), respectively. In Fig. 5(a), there are two trajectory partitions, the trajectories T2<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub></mrow></math> and T3<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">3</mn></mrow></msub></mrow></math> are in the yellow partition, and the tracks T1,T4<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">4</mn></mrow></msub></mrow></math> and T5<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">5</mn></mrow></msub></mrow></math> are in the green partition. In Fig. 5(b), there are two trajectory partitions, the trajectories T1<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub></mrow></math> and T5<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">5</mn></mrow></msub></mrow></math> are in the green partition, and the trajectories T2,T3<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">3</mn></mrow></msub></mrow></math> and T4<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">4</mn></mrow></msub></mrow></math> are in the yellow partition. Meanwhile, the trajectory clustering results are evaluated according to the widely used Silhouette Coefficient introduced in Section 4.1. For the trajectory clustering results of Fig. 5(a) and (b), the Silhouette Coefficient values are 0.26 and 0.49, respectively.
Besides, we can see from Fig. 4(a) that the hierarchical clustering results are different from the Infomap method presented in Fig. 5(a). In Fig. 4(a), the 5 trajectories can be divided into two partitions {T1,T2,T3<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">3</mn></mrow></msub></mrow></math>} and {T4,T5<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">4</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">5</mn></mrow></msub></mrow></math>}. In Fig. 5(a), there are also two partitions, which are {T2,T3<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">3</mn></mrow></msub></mrow></math>} and {T1,T4,T5<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">4</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">5</mn></mrow></msub></mrow></math>}. However, in Figs. 4(b) and 5(b), we can see that the cluster results of hierarchical clustering and Infomap are consistent with each other. In the latter experimental part, we will make detailed comparisons among different clustering methods.
As can be seen from what has been discussed above, we can see that the similarity between trajectories will change if we take the position and time attributes into account from a different category level, which may produce a different trajectory clustering results. For this example, Fig. 5(a) and (b) are divided into 2 partitions, but the clustering result of Fig. 5(b) has higher Silhouette Coefficient values, which indicates the trajectory clustering result is more reasonable. Of course, the user can measure the similarity between the trajectories from different semantic category levels according to their factual needs, and then can obtain the desired clustering result.
In this section, we evaluate the effectivity of the proposed algorithm and make a thorough comparison with traditional and some rival trajectory clustering methods. We apply the algorithm on three real datasets of semantic trajectories. The first one is the Foursquare check-ins dataset (Petry et al., 2019, Zhang et al., 2018, Yang et al., 2015) concerning the New York city collected between November 2012 and February 2013. We used the trajectory ID ranges from 126 to 947 with 1749 trajectory points, and its ID is not continuous. Besides, for the convenience of comparing the similarity of the time attribute for each point, we transform it into another time related attribute, which is time period (6:00–12:00 for the morning, 12:00–18:00 for the afternoon, and 18:00–06:00 for the evening). For the Foursquare dataset, the utilized attributes and their ranges are presented in Table 4. These attributes include latitude and longitude, time period, day, week, venue category and weather. The second and the third datasets are sets of users and their visits to various points-of-interest (POIs) (Lim et al., 2015, Lim et al., 2016), which come from the publicly available Yahoo! Flickr Creative Commons 100 M (YFCC100M) dataset (Thomee et al., 2015). In this paper, we separately use the subset dataset that the users visited to various points-of-interest (POIs) in the city of Delhi and Osaka. The Delhi dataset has 3993 trajectory points and the Osaka dataset has 7747 trajectory points. For the same reason, we transform the attribute date taken into other two new attributes, which are the day and time period. Then, the utilized attributes of these two datasets are shown in Tables 5 and 6 separately.
In this section, we study the influence of different conditions on semantic trajectory clustering. Firstly, we explored the influence of different similarity measures and semantic levels on the trajectory clustering results. Secondly, we checked whether community detection methods are overall better than traditional clustering methods in detecting semantic trajectory partitions. Thirdly, we studied the influence of different community detection methods on the constructed trajectory networks with the variation of network construction parameter K. Lastly, we made a comparison of the running time and clustering effect of each algorithm.
In this section, in the framework of our proposed STCCD algorithm, we make a comparison among different similarity measures by means of the Silhouette Coefficient (Rousseeuw, 1987), Baker-Hubert Gamma index (Baker & Hubert, 1975) and Hubert & Levin C index (Hubert & Levin, 1976). The similarity measures include the distance matching similarity measures EDR (Chen, 2005) and LCSS (Vlachos et al., 2002), and the semantic matching similarity measures MSM (Furtado et al., 2016) and MUITAS (Petry et al., 2019).
In the experiment, a series of parameters are needed to be set. On the Foursquare dataset, the attribute venue category is more important compared to other attributes in distinguishing the users’ check-in place. Therefore, we can give it more weight values in computing the semantic similarity between trajectories. For the EDR, LCSS and MSM, the weight values for attributes (time period, day, venue category and weather) listed in Table 4 are 0.05, 0.1, 0.8 and 0.05, separately. For the MUITAS, the attribute day and weather are considered as a feature, and the weight value for attribute time and venue category are 0.1 and 0.8, the weight value for the weather is 0.1. In the Delhi and Osaka datasets, for the EDR, LCSS and MSM, the weight value for the attribute POI theme listed in Tables 5 and 6 is 0.6, and the weight values for other attributes are 0.1, separately. For the MUITAS, the attributes POI ID, POI theme and POIFreq are considered as a feature, the attributes day and time period are regarded as another feature, then, the weight values for each feature are 0.8 and 0.2, separately. Besides, for the attributes with semantic information, we use the semantic matching function, and for attributes with numeric values, we utilized the distance matching function. Then, the Euclidean function is adopted as a distance function for the attribute POIFreq, and its threshold is set to 50 in this experiment.
Take MSM and MUITAS as examples, we show the trajectory similarity heat maps obtained at different semantic levels on the Foursquare, Delhi and Osaka datasets in Figs. 6, 7 and 8. Fig. 6 presents the heat map based on the location hierarchy on the Foursquare dataset. The low-level location attribute is Latitude (Longitude) and the high-level location attribute is Venue. For low-level location attributes, this paper uses latitude and longitude, and uses spherical semi-positive formula (haversine function) to calculate the spatial distance attribute between trajectory sample points. When judging the similarity between the trajectory sampling points, the threshold is set to 10 meters, that is, if the distance between the two sampling points is less than or equal to 10, it is considered that there exists similarity between them. Figs. 7 and 8 show the heat maps based on the time hierarchy on the Delhi and Osaka datasets. By converting the time attribute into the time period attribute (the conversion rule is the same as the Foursquare dataset), the semantic level based on the time attribute is constructed, and the low-level time attribute is the time point, the high-level location attribute is the time period.
A heat map is a graphical representation of dataset. It is used herein to represent similarities between trajectories which had been introduced in detail in Section 4.2. For the Foursquare dataset, the low-level location attribute adopts latitude and longitude, and the high-level position attribute adopts the venue. It can be seen from Fig. 6 that the trajectory similarity heat maps obtained at different semantic levels show obvious difference. Take the MSM method in Fig. 6(a) and (b) for example, the semantic similarity values between each pair of trajectories in Fig. 6(a) are often different from the values in Fig. 6(b). In addition we can also see from Fig. 6 that the discriminative power of semantic trajectory similarity in high semantic level is more obvious compared to the discriminative power in low semantic level. Here, the discriminative power means the similarity difference. It can be found from Figs. 7 and 8 that for the Delhi and Osaka datasets, since the time attribute occupies less weight, the similarity values between the low level and the high level is relatively closer to each other, but the discriminative power between trajectories in high level is relatively obvious compared to the discriminative power in low level. Next, we will take the higher semantic level as an example to study the semantic trajectory clustering effects of different trajectory clustering methods.
Tables 7 to 9 present the evaluation results of different clustering methods from a high semantic level for different similarity measures (EDR, LCSS, MSM, MUITAS) in the Foursquare, Delhi and Osaka datasets, respectively. In Tables 7, 8 and 9, the clustering methods include traditional algorithms, such as k-medoids, agglomerative clustering, cross-clustering (Tellaroli et al., 2016), improved density peak (Rodriguez and Laio, 2014, Wang and Xu, 2017) and Infomap community detection method. In addition, we also use three evaluation methods for evaluating various clustering methods, and the results can be found through Tables 7 to 9. According to these tables, we can see that the Infomap algorithm can achieve better results compared to other clustering methods in most cases. Besides, we can also see that for different evaluation methods, the Infomap method adopting the MUITAS can get better values compared to other clustering methods in most case. All these can prove that the Infomap also has a good performance in detecting trajectory partitions.
From Tables 7 to 9, we can also see that the EDR and LCSS get the worse results compared to MSM and MUITAS for different clustering methods in three datasets. That is because they only regard two points as similar when all their attributes match each other, which is too strict for measuring semantic trajectory similarity with multi-attributes. The MSM relaxes the limitation of the EDR and LCSS, and considers there exists some similarity when two points match on at least one attribute. Different from the MSM, the MUITAS considers relationships that may exist between attributes and their semantics. Therefore, the MUITAS can reasonably and accurately measure the similarity between different semantic trajectories in most case.
In addition, this section also compares the clustering effects of MSM and MUITAS at different semantic levels. The results are shown in Fig. 9. It can be seen from Fig. 9 that the MUITAS is better than the MSM at different semantic levels in most case. Then, we take the MUITAS for example, and also show the cluster size distribution for each clustering method at high semantic level in Fig. 10. Furthermore, for most trajectory clustering algorithms, clustering at higher semantic levels is better than lower semantic levels. Meanwhile, for different semantic levels and different trajectory clustering methods, the Infomap method is generally better compared to others. Based on these, the following part takes the higher semantic level as an example to study the relationship between various community detection algorithms under the framework of our proposed STCCD. Besides, the effects of network construction parameters on trajectory clustering are also be studied. Lastly, the running time of various algorithms and their clustering effects are presented and analyzed.
In order to verify the performance of community detection algorithm on the trajectory clustering results in the STCCD, we choose several widely used community detection algorithms (Fastgreedy (Clauset et al., 2004), Walktrap (Pons & Latapy, 2005), Label Propagation (Raghavan et al., 2007), Louvain (Blondel et al., 2008), Infomap (Rosvall & Bergstrom, 2008)) for a comparison according to the three evaluation methods. Tables 10 to 12 present the different values corresponding to each evaluation method for different community detection methods from a high semantic level in the Foursquare, Delhi and Osaka datasets, respectively.
In the process of constructing the three trajectory networks, the K is set to 15. Meanwhile, we also report the influence of the different similarity measures on community detection methods, which can also demonstrate that the MUITAS and MSM can better measure the similarity between semantic trajectories, and thus can get satisfactory results. From Tables 10 to 12, we can see that all these community detection methods can get better values compared to traditional clustering methods in most case. That is because these traditional methods only take the local relationship between trajectories into account, and thus ignore the global relationship among different trajectories. However, by transforming the semantic trajectory dataset into a network, we can not only get the local information between trajectories, but can also get global information to characterize relationship between any pair or any group of trajectories.
Besides, we can also see from Tables 10 to 12 that the Infomap method adopting the MUITAS can get better values compared to other community detection methods in most case.
Next, we investigate the influence of K on trajectory clustering results for different community detection methods in the Foursquare, Delhi and Osaka datasets, respectively. Taking the MUITAS as an example, Figs. 11 to 13 show the semantic trajectory partitioning effects with the Infomap under different K values. We can see from Figs. 11 to 13 that when K is very small, a disconnected network will be generated, which can not reveal the global relationship between different trajectories. When K increases, the disconnected parts decrease. For instance, in Fig. 11, there are 8 trajectory community partitions without disconnected parts when K = 5. And there are 4 partitions when K = 15. The same condition is also presented in Figs. 12 and 13 for other two trajectory networks. When K goes on increasing and is high enough, all pairs of trajectory points are connected, which leads to a fully-connected network with only a big community. Therefore, a proper K is needed to made according to the specific trajectory dataset.
Since the Silhouette Coefficient is a widely used method for evaluating clustering methods, we take it for example to study the impact of network construction parameters K on the trajectory clustering effects for different community detection algorithms under the framework of STCCD. The results are presented in Fig.14. We can see from Fig. 14 that with the increase of K, the Silhouette Coefficient values of different community detection methods also increase. However, when K arrives a proper value, the Silhouette Coefficient values begin to decrease. Besides, we can also find the Infomap method can get the highest Silhouette Coefficient values when K is bigger than 12, which illustrates its better performance in partitioning semantic trajectory networks among above methods.
In this part, we also take the Silhouette Coefficient for example so as to compare and study the running time and clustering effect for each algorithm. Because the EDR and LCSS are less effective in semantic trajectory clustering, this paper studies and analyzes the running time and clustering effects of each algorithm based on MSM and MUITAS. Figs. 15 to 17 show detailed comparisons of the running time of each algorithm and its clustering effect on the three datasets, respectively. In the above figures, the histogram stands for the running time of each algorithm. The left ordinate of each graph represents the running time values. The line graph is the Silhouette Coefficient values corresponding to each algorithm. The right ordinate of each figure is displayed with the Silhouette Coefficient values.
It can be seen from Figs. 15 to 17 that, in general, the community detection methods present higher Silhouette coefficient values compared to most of other methods. That is because they can capture the global and local relationship between the trajectories, and then get better clustering results. In addition, in the above various community detection methods under the framework of STCCD, the Infomap can obtain a better semantic trajectory clustering effect compared to others, and requires less time to run compared to most of other methods. That is to say, the Infomap method can make a good balance between the running time and cluster effects in semantic trajectory clustering. Therefore, the Infomap method should be recommended for semantic trajectory clustering in the framework of our proposed method.
Since STCCD is based on the semantic similarity, then the errors in the calculation of the semantic similarity will lead to improper and even erroneous semantic trajectory partitions. The errors may come from two points. The first one may be from the dataset itself. For instance, the information missing or data errors of some values. For this point, we should do some careful data preprocessing jobs before using the dataset. In data preprocessing field, there has appeared many new technologies (Alvares et al., 2007, Parent et al., 2013, Ruan et al., 2018) which can be utilized. The second one may be from external data sources or background knowledge that will be used for deriving semantic similarities. For instance, Wikipedia, WordNet and so on. Therefore, it is necessary to check these knowledges and their relations before using them to compute the semantic similarity between trajectories.
Besides, there is another point needed to be explained. In this paper, we disregarded the temporal order in the computing process of semantic trajectory similarity. That is because we mainly pay attention to semantic trajectories with multi-attribute. According to the intuitive concept of similarity (Lin, 1998), for two semantic trajectories T1<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">1</mn></mrow></msub></mrow></math> and T2<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">T</mi></mrow><mrow is="true"><mn is="true">2</mn></mrow></msub></mrow></math>, the more commonality they share, the more similar they are. Traditional similarity measures, such as LCSS and EDR, consider two points of a pair of trajectories as similar when all their attributes match, including temporal order match, which means a strong dependency relationship among all attributes. This is a problem in multiple-attribute trajectories where the number of attributes is very high, and requiring a match in all attributes significantly reduces the number of matchings, which may lead to fewer similar trajectories from the semantic perspective. Therefore, we relax this limitation, and do not take the temporal order into account in this paper.
In this paper, we introduced the ontology theory to facilitate the computation of semantic trajectory similarity, and proposed a semantic trajectory clustering algorithm STCCD based on community detection. We investigated the influence of similarity functions, network construction parameters and community detection methods on the semantic trajectory clustering results under the framework of STCCD, and made a comparison with some traditional and rival methods proposed recently. The experimental results on three real world trajectory datasets demonstrate the effectivity of the STCCD.
The methods and algorithms constructed in this paper can be applied to recommendation systems, for example, personalized tourism recommendation, which can not only help tourists make tourism decisions, but also provide tourists with tourist attractions recommendation and routes recommendation that meet their needs and preferences, and also reduce the operating cost of tourism enterprises and improve the profits of enterprises.
Although the STCCD can get better results in detecting trajectories partitions, one weak of it is it needs a lot of time to compute the similarity between trajectories. In our future work, we will pay attention to how to decrease the time complexity of our proposed method.
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.
This work was supported by the National Natural Science Foundation of China (Grant Nos.71771034, 71421001), Science and Technology Program of Jieyang (Grant No.2017xm041) and the Scientific and Technological Innovation Foundation of Dalian (No.2018J11CY009).