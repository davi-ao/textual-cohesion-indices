Oracle bone inscriptions are the earliest mature writing system discovered in China [1]. Oracle characters, which appeared in Shang Dynasty (circa 1,250–1,046BC) are the oldest characters in China. These characters are usually carved on cattle bones or turtle shells (Fig. 1). The research of oracle characters has a great significance to archeology and philology. Therefore, some computer technologies have been adopted to study oracle characters. These researches primarily focus on oracle character recognition, structure of oracle character analysis, oracle character dataset collection and oracle bone fragments rejoining.
Compared with modern Chinese characters, oracle characters also have structural characteristics. Therefore, some literatures have been appeared to recognize oracle characters [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11] or study structures of oracle characters [12], [13]. In 2015, Guo et al. [2] combined a Gabor-related low-level representation with a sparse-encoder-related mid-level representation into a novel hierarchical representation to recognize oracle characters. In 2018, Liu and Gao [3] extracted image features by 5 convolutional layers with small kernel size, obtained the final description of oracle characters with 2 fully-connected layers, and recognized oracle characters with the aid of convolutional neural network (CNN). In 2019, Meng et al. [4] first applied the pre-processing of binarization, changing brightness and contrast, and rotation in oracle bone images, and then employed single shot multibox detector to recognize oracle characters. In fact, getting oracle characters from the rubbings of oracle bones is the first step for recognizing them. To solve the problem, Liu et al [5] proposed an image segmentation method based on fully convolutional networks (FCN) to obtain oracle characters from images of oracle rubbings. In 2020, Chen et al. [6] proposed an encoding-based oracle bone script recognition (OBSR) system that applies image pre-processing techniques to encode oracle images into small matrices and recognize oracle characters in the encoding space, and the method achieved a high accuracy rate of 99% within a time range of milliseconds on the oracle bones from the Yin Ruins in XiaoTun village. Sun et al. [7] introduced a dual-view oracle bone script recognition system by combining the character recognition algorithm and temporal-spatial psychovisual modulation. The system recognized not only oracle bone inscription images but also handwriting oracle character images.
In order to recognize oracle variant characters which are different shapes of the same characters [1], Gao et al. [1] presented a two-stage method to distinguish them. In the method, the oracle variant characters were identified by computer related methods in the first stage, and then the unrecognized oracle variant characters in the first stage were further identified by multi-domain methods combining a priori knowledge. Likewise, Liu et al. [8] proposed an image retrieval method combining deep neural networks (DNN) and clustering technology to divide the oracle characters into different subsets of variants.
Like Arabic [14], the huge challenge for recognizing oracle characters are data limitation and imbalance [11]. Therefore, Yang et al. [9] used gaussian pyramid (GP) to preprocess oracle rubbing images, and analyze different generated models based on generative adversarial networks (GANs). Zhang et al. [10] used a convolutional neural network to map the character images to an euclidean space, and then nearest neighbor classification was performed for oracle character recognition. Han et al. [11] proposed a novel data augmentation approach, named Orc-Bert augmentor pre-trained by self-supervised learning, for few-shot oracle character recognition.
In the aspect of structure of oracle character analysis, Dress et al. [12] analyzed oracle characters for animals from the cognitive perspective, and applied the SplitsTree method as encoded in the NeighborNet algorithms, creating a family of dissimilarity-based networks. Yang et al. [13] used convolutional neural networks to analyze the evolution of the oracle characters based on oracle radicals. For oracle character dataset collection, Huang et al. [15] constructed a large dataset of oracle characters called OBC306, and evaluated the dataset based on the standard deep CNN, which serves as the benchmark model for oracle recognition. Li et al. [16] established a handwriting oracle character database called HWOBC, containing 83,245 character-level samples which are grouped into 3881-character categories. Both OBC306 and HWOBC are downloaded (http://jgw.aynu.edu.cn/DownPage) from the database ‘Qin Qi Wen Yuan’ (http://jgw.aynu.edu.cn). The database of ‘Qin Qi Wen Yuan’ is a specific database model (like the literature [17]) for oracle bone inscriptions, and can be performed semantic image retrieval [18], [19] between images of oracle rubbings and oracle characters. For oracle bone fragments rejoining, Chen et al [20] presented a multiregional convolutional neural network to classify the oracle rubbings, and these results made contributions to the progress of the study of oracle bone morphology and oracle bone fragments rejoining. Zhang et al. [21] developed a software tools named AI-powered OBI for the annotation of oracle bone inscriptions and rejoining of oracle bone fragments.
In fact, the biggest challenge to oracle bone inscriptions is that two-thirds of oracle characters have not been recognized. That is, the semantics of these oracle characters remain unknown. To study the semantics of unknown oracle characters, this paper abstracts the relationships among oracle characters as a language network, and classifies oracle characters with similar semantics by module structure. Actually, the human language, as a complex system, can be modeled and analyzed as a complex network [22] or a graph [23]. Many related words or other linguistic components can be constructed and examined within the context of semantics, syntactics, and co-occurrence.
In 2001, Cancho and Sole [24] first constructed the co-occurrence network of the English language, and discovered the small-world effect and scale-free degree distribution in the co-occurrence network. In 2004, Cancho [25] constructed a syntactical network for three languages, and statistically analyzed the network from the aspects of degree distribution, hierarchical organization, and clustering coefficient. Steyvers and Tenenbaum [26] investigated the large-scale structure of three types of semantic networks, namely, word associations, WordNet, and Roget’s Thesaurus, and found that, similar to other natural complex networks, these semantic networks have a small-world structure, characterized by sparse connectivity, short average path lengths between words, and strong local clustering. In 2009, Cech and Macutek [27] compared two syntactic dependency networks based on the same Czech language dataset, and obtained some interesting results. Rather than the structural features of language networks, Arbesman et al [28] explored the difference between English and Spanish in word formation, using language networks constructed by small components called islands, and drew the following conclusions: Spanish words in the islands tend to be phonologically and semantically similar, but English words in the islands only have phonological similarity. In 2017, Dautriche et al. [29] constructed and analyzed four language networks, and discovered that all the networks own minimal pairs, average Levenshtein distance, and several network properties. In 2019, Liang and Wang [30] constructed 206 co-occurrence networks of Chinese characters and words, discussed the relationships among the statistical parameters in these networks, and found the spectral behavior of the modern Chinese linguistic topology is consistent over time unless something having a major impact on Chinese language happen. To represent texts as network, Arruda et al. [31] proposed a network model based on the similarity between the content of the paragraphs in the text, and found that real texts tend to have a more well-defined community structure.
Although artificial intelligence algorithms have been applied to research oracle bone inscriptions and achieved some meaningful results, few algorithms were used to predict or analyze semantics of oracle characters. As an effective tool for abstracting complex systems, complex networks are widely used to study human language. For example, based on the concept of the module (or community) structure in the network, Siew [32] digged out 17 modules of different scales in the established phonological network, and found that larger communities tend to consist of short, frequent words of high degree and low age of acquisition ratings, and smaller communities tend to consist of longer, less frequent words of low degree and high age of acquisition ratings. From the results of literature [32], we can see that the words with similar attributes may tend to gather and form modular structure in language networks. According to this assumption, we employ module structure in oracle character network to analyze oracle characters with similar semantics.
This work firstly constructs two networks for oracle characters, including context network and shape network (the flow chart see Fig. 2). Then, two subnetworks in which nodes represent known oracle characters are abstracted from context network and shape network. Third, three module detection methods are employed to mine modules from each subnetwork, and the predicted modules are compared with metadata by normalization mutual information (NMI) [33]. At last, the factors including the context and shape of oracle characters are analyzed in predicting the semantics of oracle characters by fusing context and shape subnetworks. The research results can provide vital data support to the design of semantic prediction algorithms for unknown oracle characters.
Co-occurrence network is constructed by modeling the linear ordering of words in a corpus [34]. In a co-occurrence network, every node represents a word, and each pair of adjacent words are connected by an edge [31]. To generate a co-occurrence network, it is necessary to select a vital parameter window mn. The co-occurrence window mn of size n can be defined as a set of n subsequent words from a text [35]. Within a window, the edges need to be established between the first word and the n-1 subsequent words. Words are also linked according to the optional usage of specified delimiters. In the co-occurrence network, the parameter l is the length of sentence, and the edge is limited to the sentence borders. In general, the mn is set as 2 or l. Fig. 3 shows an example for constructing a co-occurrence network, where, w1,…,w6 are words in a sentence.
To build a co-occurrence network (named context network) for oracle characters, an oracle character network is established based on 72,151 pieces of oracle rubbings, and modeled into an oracle character network. The oracle characters in the same rubbing are treated as the words in a sentence of modern Chinese. Considering the serious damage of the oracle rubbings over 3,000 years, only the 71,455 oracle rubbings with oracle characters are selected. In total, these oracle rubbings contain 6,199 oracle characters, including 1,602 known semantics characters and 4,597 unknown semantics characters. Then, the weight (link) between two oracle characters is defined. The weight calculation depends on oracle rubbings, because each oracle rubbing depicts a complete semantic unit (e.g. a war or a hunting). In the same oracle rubbing with t oracle characters r=[O1,O2,⋯,Ot]<math><mrow is="true"><mi mathvariant="normal" is="true">r</mi><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mo stretchy="false" is="true">[</mo><msub is="true"><mi is="true">O</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">O</mi><mn is="true">2</mn></msub><mo is="true">,</mo><mo is="true">⋯</mo><mo is="true">,</mo><msub is="true"><mi is="true">O</mi><mi is="true">t</mi></msub><mo stretchy="false" is="true">]</mo></mrow></math>, the weight between two oracle characters can be obtained by Eqs. (1), (2) [36].(1)wij=101interal<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow></msub><mo linebreak="goodbreak" is="true">=</mo><msup is="true"><mn is="true">10</mn><mfrac is="true"><mn is="true">1</mn><mrow is="true"><mo is="true">int</mo><mi is="true">e</mi><mi is="true">r</mi><mi is="true">a</mi><mi is="true">l</mi></mrow></mfrac></msup></mrow></math>(2)interal=lj-liβ+(lj-li)<math><mrow is="true"><mo is="true">int</mo><mi is="true">e</mi><mi is="true">r</mi><mi is="true">a</mi><mi is="true">l</mi><mo linebreak="goodbreak" is="true">=</mo><mrow is="true"><mfenced close="" open="{" is="true"><mrow is="true"><mrow is="true"><mtable is="true"><mtr is="true"><mtd is="true"><mrow is="true"><msub is="true"><mi is="true">l</mi><mi is="true">j</mi></msub><mo is="true">-</mo><msub is="true"><mi is="true">l</mi><mi is="true">i</mi></msub></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mi is="true">β</mi><mo is="true">+</mo><mo stretchy="false" is="true">(</mo><msub is="true"><mi is="true">l</mi><mi is="true">j</mi></msub><mo is="true">-</mo><msub is="true"><mi is="true">l</mi><mi is="true">i</mi></msub><mo stretchy="false" is="true">)</mo></mrow></mtd></mtr></mtable></mrow></mrow></mfenced></mrow></mrow></math>where, wij is the weight between oracle characters i and j, interal is a parameter defined in formula (2); lj and li are locations of oracle characters i and j in the same oracle rubbing, i.e., lj > li and (i,j)∈r<math><mrow is="true"><mo stretchy="false" is="true">(</mo><mi mathvariant="normal" is="true">i</mi><mo is="true">,</mo><mi mathvariant="normal" is="true">j</mi><mo stretchy="false" is="true">)</mo><mo is="true">∈</mo><mi mathvariant="normal" is="true">r</mi></mrow></math>; β is a user-defined variable. If fragmentary oracle character(s) exist between oracle characters i and j, the value of interal includes two parts: lj-li, and β. The value of β is set to 2 through experiments.
Following formulas (1), (2), a weighted oracle character network (named context network, see Table 1) is constructed based on 71,455 oracle rubbings. The weighted network can be represented by a matrix M with 6,199 nodes. The network construction involves the following steps (see Fig. 4). Step 1, calculate the weight wijr1<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">1</mn></msup></msubsup></mrow></math> between oracle characters i and j in the same rubbing r1 by formulas (1), (2). Step 2, set the value of Mijr1<math><mrow is="true"><msubsup is="true"><mrow is="true"><mi mathvariant="bold-italic" is="true">M</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">1</mn></msup></msubsup></mrow></math> as wijr1<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">1</mn></msup></msubsup></mrow></math>. Step 3, if oracle characters i and j appear simultaneously in another oracle rubbing rm, calculate the weight wijrm<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mi is="true">m</mi></msup></msubsup></mrow></math> between them by formulas (1), (2). Then, update the value of Mijr1<math><mrow is="true"><msubsup is="true"><mrow is="true"><mi mathvariant="bold-italic" is="true">M</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">1</mn></msup></msubsup></mrow></math> to Mijrm<math><mrow is="true"><msubsup is="true"><mrow is="true"><mi mathvariant="bold-italic" is="true">M</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mi is="true">m</mi></msup></msubsup></mrow></math>(Mijrm=Mijrm+wijr1<math><mrow is="true"><msubsup is="true"><mrow is="true"><mi mathvariant="bold-italic" is="true">M</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mi is="true">m</mi></msup></msubsup><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><msubsup is="true"><mrow is="true"><mi mathvariant="bold-italic" is="true">M</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mi is="true">m</mi></msup></msubsup><mo linebreak="badbreak" linebreakstyle="after" is="true">+</mo><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">1</mn></msup></msubsup></mrow></math>). Step 4, repeat Steps 3, calculate all the weights between oracle characters i and j for the 71,455 rubbings, to get the final value of Mij<math><mrow is="true"><msub is="true"><mrow is="true"><mi mathvariant="bold-italic" is="true">M</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow></msub></mrow></math>. All the elements of matrix M can be obtained by the same method. Fig. 4 illustrates the calculation of elements in matrix M. The two oracle rubbings r1 and r2 in Fig. 4 have 6 and 5 oracle characters, respectively. Based on the two oracle rubbings, a matrix M can be constructed with 9 nodes. For example, the value of w24 can be calculated by formulas (1), (2): w24=101interal=101l4-l2=1012<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mn is="true">24</mn></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">1</mn><msup is="true"><mrow is="true"><mn is="true">0</mn></mrow><mfrac is="true"><mn is="true">1</mn><mrow is="true"><mi mathvariant="italic" is="true">int</mi><mi is="true">e</mi><mi is="true">r</mi><mi is="true">a</mi><mi is="true">l</mi></mrow></mfrac></msup><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">1</mn><msup is="true"><mrow is="true"><mn is="true">0</mn></mrow><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msub is="true"><mi is="true">l</mi><mn is="true">4</mn></msub><mo is="true">-</mo><msub is="true"><mi is="true">l</mi><mn is="true">2</mn></msub></mrow></mfrac></msup><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">1</mn><msup is="true"><mrow is="true"><mn is="true">0</mn></mrow><mfrac is="true"><mn is="true">1</mn><mn is="true">2</mn></mfrac></msup></mrow></math>. But the calculation of w56 is more complex than that of w24. First, the weight of w56r1<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mn is="true">56</mn></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">1</mn></msup></msubsup></mrow></math> is computed by oracle rubbing r1: w56=101interal=101l6-l5=1011<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mn is="true">56</mn></msub><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">1</mn><msup is="true"><mrow is="true"><mn is="true">0</mn></mrow><mfrac is="true"><mn is="true">1</mn><mrow is="true"><mi mathvariant="italic" is="true">int</mi><mi is="true">e</mi><mi is="true">r</mi><mi is="true">a</mi><mi is="true">l</mi></mrow></mfrac></msup><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">1</mn><msup is="true"><mrow is="true"><mn is="true">0</mn></mrow><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msub is="true"><mi is="true">l</mi><mn is="true">6</mn></msub><mo is="true">-</mo><msub is="true"><mi is="true">l</mi><mn is="true">5</mn></msub></mrow></mfrac></msup><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mn is="true">1</mn><msup is="true"><mrow is="true"><mn is="true">0</mn></mrow><mfrac is="true"><mn is="true">1</mn><mn is="true">1</mn></mfrac></msup></mrow></math>. Then, w56r2<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mn is="true">56</mn></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">2</mn></msup></msubsup></mrow></math> is also calculated by oracle rubbing r2. After that, the value of M56 is obtained as the sum of w56r1<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mn is="true">56</mn></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">1</mn></msup></msubsup></mrow></math> and w56r2<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mn is="true">56</mn></mrow><msup is="true"><mrow is="true"><mi is="true">r</mi></mrow><mn is="true">2</mn></msup></msubsup></mrow></math>.
The oracle characters are written by hand. Some of them are hieroglyphs. Therefore, the semantics of an oracle character can be reflected by its shape. To classify oracle characters with similar semantics, it is necessary to construct an oracle character shape network. First, 1,806 small components of oracle characters are collected. Each oracle character i can be represented by some small components: γ(i): g1, g2, g3…. Let γ(i) and γ(j) be the sets of small components of oracle characters i and j, respectively. Then, the weight between i and j can be calculated based on the hypothesis that two oracle characters are more likely to have similar semantics if they have many common small components. There are many similarity indexes to calculate the weight between i and j [37], here we adopt a simple index common neighbors (CN, formula 3 and Fig. 5) [37]. Based on the weights obtained by formula 3, an oracle character shape network (named shape network, see Table 1) of 5,890 nodes and 1,198,652 edges is established.(3)Sij=γ(i)∩γ(j)<math><mrow is="true"><msub is="true"><mi is="true">S</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow></msub><mo linebreak="goodbreak" is="true">=</mo><mrow is="true"><mfenced close="|" open="|" is="true"><mrow is="true"><mrow is="true"><mi is="true">γ</mi><mo stretchy="false" is="true">(</mo><mi is="true">i</mi><mo stretchy="false" is="true">)</mo><mo is="true">∩</mo><mi is="true">γ</mi><mo stretchy="false" is="true">(</mo><mi is="true">j</mi><mo stretchy="false" is="true">)</mo></mrow></mrow></mfenced></mrow></mrow></math>
To verify the semantics of the oracle characters in the same module, a subnetwork of oracle context network is extracted in the following steps. First, select 1,602 oracle characters with known semantics (i.e. known oracle characters). Second, retain each edge in the context network, if the two nodes connected by the edge are known oracle characters (formula 4). Third, repeat the second step until all edges are processed. In this way, a subnetwork (named context subnetwork, see Table 1) can be obtained with 1,392 nodes and 41,821 weighted edges by deleting the edges whose weight is smaller than 5. According to the scenes described by oracle characters, the 1,392 oracle characters in the context subnetwork are divided into 135 classes, creating a standard metadata to measure modules mined by other methods. Similarly, a subnetwork with 1,428 nodes and 57,985 weighted edges were abstracted from the oracle character shape network (named shape subnetwork, see Table 1). Then, the shape subnetwork are divided into 132 classes by semantics, providing the metadata to measure the modules detected by various methods.(4)eb=eijcsubjecto(i,j)∈Unullotherwise<math><mrow is="true"><msup is="true"><mi is="true">e</mi><mi is="true">b</mi></msup><mo linebreak="goodbreak" is="true">=</mo><mrow is="true"><mfenced close="" open="{" is="true"><mrow is="true"><mrow is="true"><mtable is="true"><mtr is="true"><mtd is="true"><mrow is="true"><msubsup is="true"><mi is="true">e</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mi is="true">c</mi></msubsup><mrow is="true"><mspace width="0.333333em" is="true"></mspace><mi is="true">s</mi><mi is="true">u</mi><mi is="true">b</mi><mi is="true">j</mi><mi is="true">e</mi><mi is="true">c</mi><mspace width="0.333333em" is="true"></mspace><mi is="true">t</mi><mi is="true">o</mi><mrow is="true"><mspace width="0.333333em" is="true"></mspace><mtext is="true">(</mtext></mrow><mi is="true">i</mi><mo is="true">,</mo><mi is="true">j</mi><mo stretchy="false" is="true">)</mo><mo is="true">∈</mo><mi is="true">U</mi></mrow></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mi is="true">n</mi><mi is="true">u</mi><mi is="true">l</mi><mi is="true">l</mi><mspace width="0.333333em" is="true"></mspace><mi is="true">o</mi><mi is="true">t</mi><mi is="true">h</mi><mi is="true">e</mi><mi is="true">r</mi><mi is="true">w</mi><mi is="true">i</mi><mi is="true">s</mi><mi is="true">e</mi></mrow></mtd></mtr></mtable></mrow></mrow></mfenced></mrow></mrow></math>where, eb is the set of edges of subnetwork, ec is the total edges in context network. U is the set of known oracle characters, and null denotes that eb is null.
In order to further understand the four oracle character networks constructed by this work, their basic properties [38] including link density (formula 5), diameter, average path length, average degree and clustering coefficient are calculated, and the results are shown in Table 1. From link density, we can see that the context network is sparser than other three networks, possibly because many isolated nodes exist in context network. The diameter and average path length can reflect the small-world effect [39] of network. Comparing other real-world networks [38], these four oracle characters also have small-world effect. As the diameter shows, the four networks may have the phenomenon of six degrees of separation [40]. For the average degree, the shape network is the largest in four networks. The values of link density and average degree imply that the shape network is the most densely network because different oracle characters have more overlapped small components. Unlike the properties mentioned above, clustering coefficient has been used to measure the local topology of network, that is the larger the clustering coefficient value, the stronger the local of the network. As the table shows, the clustering coefficients of four networks are quite large, which provides data support for designing module detection algorithms.(5)LD=2EN×(N-1)<math><mrow is="true"><mi mathvariant="italic" is="true">LD</mi><mo linebreak="goodbreak" is="true">=</mo><mfrac is="true"><mrow is="true"><mn is="true">2</mn><mi is="true">E</mi></mrow><mrow is="true"><mi is="true">N</mi><mo is="true">×</mo><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mo is="true">-</mo><mn is="true">1</mn><mo stretchy="false" is="true">)</mo></mrow></mfrac></mrow></math>where E and N are total number of edges and nodes in network, respectively.
In oracle bone inscriptions, the oracle characters with similar semantics tend to form a class. In order to mine the oracle characters with similar semantics, the oracle character subnetworks are divided into classes, and the predicted classes are evaluated against real classes using an index. Firstly, the modules are mined from the subnetworks. Module is a classic feature of complex network. As shown in Fig. 6 [41], each module is a subnetwork with dense intra-group connections and sparse inter-group connections. Module structure has been applied to many fields, ranging from biology, computer science, to sociology. Based on module structure, it is possible to predict new attributes of an object (or a node in a network). Suppose the attribute of node 12 in Fig. 6 is unknown, while that of nodes 8–11 are known. Then, node 12 is highly likely to have the same attribute as nodes 8–11, because nodes in the same module tend to have the same attribute. Next, the NMI [33] is employed to evaluate the classes predicted by different module detection methods. Let χ=(X1,X2,⋯,XnX)<math><mrow is="true"><mi is="true">χ</mi><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mo stretchy="false" is="true">(</mo><msub is="true"><mi is="true">X</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">X</mi><mn is="true">2</mn></msub><mo is="true">,</mo><mo is="true">⋯</mo><mo is="true">,</mo><msub is="true"><mi is="true">X</mi><msub is="true"><mi is="true">n</mi><mi is="true">X</mi></msub></msub><mo stretchy="false" is="true">)</mo></mrow></math> and γ=(Y1,Y2,⋯,YnY)<math><mrow is="true"><mi is="true">γ</mi><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mo stretchy="false" is="true">(</mo><msub is="true"><mi is="true">Y</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">Y</mi><mn is="true">2</mn></msub><mo is="true">,</mo><mo is="true">⋯</mo><mo is="true">,</mo><msub is="true"><mi is="true">Y</mi><msub is="true"><mi is="true">n</mi><mi is="true">Y</mi></msub></msub><mo stretchy="false" is="true">)</mo></mrow></math> be two partitions of a network, and nX and nY be the number of modules in the two partitions, respectively. Then, the NMI can be defined as:(6)NMI(χ,γ)=-2∑i=1nX∑j=1nYnijXYlog(nijXY·NniX·njY)∑i=1nXniXlog(niXN)+∑j=1nYnjYlog(njYN)<math><mrow is="true"><mi mathvariant="italic" is="true">NMI</mi><mrow is="true"><mo stretchy="false" is="true">(</mo><mi is="true">χ</mi><mo is="true">,</mo><mi is="true">γ</mi><mo stretchy="false" is="true">)</mo></mrow><mo linebreak="goodbreak" is="true">=</mo><mfrac is="true"><mrow is="true"><mo is="true">-</mo><mn is="true">2</mn><msubsup is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">i</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><msub is="true"><mi is="true">n</mi><mi is="true">X</mi></msub></msubsup><mrow is="true"><msubsup is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">j</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><msub is="true"><mi is="true">n</mi><mi is="true">Y</mi></msub></msubsup><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">XY</mi></mrow></msubsup><mo is="true">log</mo><mrow is="true"><mo stretchy="false" is="true">(</mo><mfrac is="true"><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">XY</mi></mrow></msubsup><mo is="true">·</mo><mi is="true">N</mi></mrow><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mi is="true">i</mi><mi is="true">X</mi></msubsup><mo is="true">·</mo><msubsup is="true"><mi is="true">n</mi><mi is="true">j</mi><mi is="true">Y</mi></msubsup></mrow></mfrac><mo stretchy="false" is="true">)</mo></mrow></mrow></mrow></mrow><mrow is="true"><msubsup is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">i</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><msub is="true"><mi is="true">n</mi><mi is="true">X</mi></msub></msubsup><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mi is="true">i</mi><mi is="true">X</mi></msubsup><mo is="true">log</mo><mrow is="true"><mo stretchy="false" is="true">(</mo><mfrac is="true"><msubsup is="true"><mi is="true">n</mi><mi is="true">i</mi><mi is="true">X</mi></msubsup><mi is="true">N</mi></mfrac><mo stretchy="false" is="true">)</mo></mrow><mo is="true">+</mo><msubsup is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">j</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><msub is="true"><mi is="true">n</mi><mi is="true">Y</mi></msub></msubsup><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mi is="true">j</mi><mi is="true">Y</mi></msubsup><mo is="true">log</mo><mrow is="true"><mo stretchy="false" is="true">(</mo><mfrac is="true"><msubsup is="true"><mi is="true">n</mi><mi is="true">j</mi><mi is="true">Y</mi></msubsup><mi is="true">N</mi></mfrac><mo stretchy="false" is="true">)</mo></mrow></mrow></mrow></mrow></mfrac></mrow></math>where, N is the number of nodes in network; niX<math><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mrow is="true"><mi is="true">i</mi></mrow><mi is="true">X</mi></msubsup></mrow></math> and njY<math><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mrow is="true"><mi is="true">j</mi></mrow><mi is="true">Y</mi></msubsup></mrow></math> are the number of nodes in modules Xi and Yj, respectively; nijXY<math><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">XY</mi></mrow></msubsup></mrow></math> is the number of nodes shared by modules Xi and Yj: nijXY=Xi∩Yj<math><mrow is="true"><msubsup is="true"><mi is="true">n</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mrow is="true"><mi mathvariant="italic" is="true">XY</mi></mrow></msubsup><mo linebreak="goodbreak" linebreakstyle="after" is="true">=</mo><mrow is="true"><mfenced close="|" open="|" is="true"><mrow is="true"><msub is="true"><mi is="true">X</mi><mi is="true">i</mi></msub><mo is="true">∩</mo><msub is="true"><mi is="true">Y</mi><mi is="true">j</mi></msub></mrow></mfenced></mrow></mrow></math>. The larger the NMI, the better the partitioning of modules.
In order to detect the modules in the oracle character subnetworks, three methods are adopted to detect the modules, namely, ClusterONE method [42], GCDanon method [43] and Moduarity method [44]. The ClusterONE method centers on a concept called the cohesiveness score (see formula 7). This method searches for modules in the network by a greedy growth process. It can detect partly overlapped modules from unweighted and weighted networks. Here, the ClusterONE method embedded in Cytoscape [45] is selected to detect the modules in oracle character networks. The parameter of minimum size in ClusterONE method is set to 3, the haircut threshold is set to 0.1, and the other parameters are as default. Both GCDanon and Modularity methods aim to optimize the modularity Q (see formula 8). The GCDanon method is extended from Newman’s algorithm for community detection, which treats communities of different sizes on an equal footing. The Modularity method, which is based on global structure of network, is immensely popular.(7)f(V)=win(V)win(V)+wbound(V)+pV<math><mrow is="true"><mi is="true">f</mi><mrow is="true"><mo stretchy="false" is="true">(</mo><mi is="true">V</mi><mo stretchy="false" is="true">)</mo></mrow><mo linebreak="goodbreak" is="true">=</mo><mfrac is="true"><mrow is="true"><msup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">in</mi></mrow></msup><mrow is="true"><mo stretchy="false" is="true">(</mo><mi is="true">V</mi><mo stretchy="false" is="true">)</mo></mrow></mrow><mrow is="true"><msup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">in</mi></mrow></msup><mrow is="true"><mo stretchy="false" is="true">(</mo><mi is="true">V</mi><mo stretchy="false" is="true">)</mo></mrow><mo is="true">+</mo><msup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">bound</mi></mrow></msup><mrow is="true"><mo stretchy="false" is="true">(</mo><mi is="true">V</mi><mo stretchy="false" is="true">)</mo></mrow><mo is="true">+</mo><mi is="true">p</mi><mrow is="true"><mfenced close="|" open="|" is="true"><mrow is="true"><mi is="true">V</mi></mrow></mfenced></mrow></mrow></mfrac></mrow></math>(8)Q=∑V=1nVWVW-SV2W2<math><mrow is="true"><mi is="true">Q</mi><mo linebreak="goodbreak" is="true">=</mo><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">V</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><msub is="true"><mi is="true">n</mi><mi is="true">V</mi></msub></munderover><mrow is="true"><mfenced close="]" open="[" is="true"><mrow is="true"><mrow is="true"><mfrac is="true"><msub is="true"><mi is="true">W</mi><mi is="true">V</mi></msub><mi is="true">W</mi></mfrac><mo is="true">-</mo><msup is="true"><mrow is="true"><mfenced close=")" open="(" is="true"><mrow is="true"><mfrac is="true"><msub is="true"><mi is="true">S</mi><mi is="true">V</mi></msub><mrow is="true"><mn is="true">2</mn><mi is="true">W</mi></mrow></mfrac></mrow></mfenced></mrow><mn is="true">2</mn></msup></mrow></mrow></mfenced></mrow></mrow></math>
In formulas (7), (8), V is a module, win(V) is the total weight of edges in V, wbound(V) is the total weight of edges that connect the module with the rest of the network, p|V| is a penalty. nV is the number of modules, W is the total weight of edges in the network, WV is the total weight of the internal edges in V and SV is the total strength of the nodes in V.
Using the three methods, the modules in context and shape subnetworks are detected. Then, the detected modules are compared against the metadata. Finally, the NMIs between the modules and metadata are calculated (see Fig. 7). As shown in Fig. 7, the highest NMIs of modules in context and shape subnetworks are discovered by ClusterONE method with 0.4642 and 0.5011. This means the module structure in the network can reveal the oracle characters with similar semantics. The NMIs of GCDanon and Modularity methods are lower than those of ClusterONE method, they are 0.3544 and 0.3006 in context subnetwork, and 0.3294 and 0.3032 in shape subnetwork. A possible reason is that ClusterONE is defined by the local structure of network, while Modularity and GCDanon are defined by the global structure of network.
Next is a detailed analysis on the semantics of oracle characters in the same modules. To measure the matching degree between the detected modules and real semantic units, a match degree index (C) can be defined as formula 9, and can be calculated as following steps. First, the i-th detected module is compared with all the real semantic units one by one, and then the maximum value of the intersection is the C value of i-th detected module. In the context subnetwork, the first example module 18 (see Fig. 8) with 0.5333 of C value contains 15 characters representing digits (e.g. 3, 4, 5, 6, 7, and 8) and digit-related oracle characters. Module 55 with 0.6829 of C value contains 82 oracle characters. These oracle characters describe a cross-shaped things, such as a cross-shaped weapon. Module 61 contains 10 characters and its C value is 0.5, these oracle characters depict edible plants like wheat and rice. The results show that the context is critical to the formation of semantics of non-hieroglyphs, and the semantics of unknown non-hieroglyphs can be predicted by context.(9)Ci=max1⩽j⩽nPi∩RjPi<math><mrow is="true"><msub is="true"><mi is="true">C</mi><mi is="true">i</mi></msub><mo linebreak="goodbreak" is="true">=</mo><munder is="true"><mo movablelimits="false" is="true">max</mo><mrow is="true"><mn is="true">1</mn><mo is="true">⩽</mo><mi is="true">j</mi><mo is="true">⩽</mo><mi is="true">n</mi></mrow></munder><mfrac is="true"><mrow is="true"><mfenced close="|" open="|" is="true"><mrow is="true"><mrow is="true"><msub is="true"><mi is="true">P</mi><mi is="true">i</mi></msub><mo is="true">∩</mo><msub is="true"><mi is="true">R</mi><mi is="true">j</mi></msub></mrow></mrow></mfenced></mrow><mrow is="true"><mfenced close="|" open="|" is="true"><mrow is="true"><msub is="true"><mi is="true">P</mi><mi is="true">i</mi></msub></mrow></mfenced></mrow></mfrac></mrow></math>where, Pi and Ri are the detected module and real semantic unit, respectively.
In the shape subnetwork, 101 modules are discovered by ClusterONE method. Among them, 43 modules have a C value greater than 0.5, revealing the importance of shape to the formation of semantics of oracle characters. For example, an interesting module is module 50 (Fig. 9), the module includes 12 oracle characters and its C values is 1. The results means that all the oracle characters in the module describe the door-related things or motions or some scenes, for example, some oracle characters have the meaning of protection mainly because the strong door can defend against enemies or beasts in ancient China. Likewise, some oracle characters in module 50 also describe warehouse because the things in the warehouse with solid door cannot be stolen. Module 8 (C value is 0.667) includes 24 characters, two-thirds of which depict the things related to the house, such as family (the people in the same family should live the same house in ancient China), room, and place. In addition, an oracle character in this module describes safeness because people living in a solid house means safeness in ancient China. Module 5 with C = 0.6721 has 61 oracle characters, most of which describe things or people related to woman, e.g. sister, and pregnancy. Module 23 contains 12 characters and its C value is 0.75. Most of them describe the things associated with money, e.g. greed, stored things, and jewelry. The other big module is module 36, this module contains 58 modules with C value of 0.5833. The oracle characters in the module describes foot-related things, motions, or scenes, for example, they describe the scenes that people run away from house or some children play or chase each other. The last instance of module is module 89, the module includes 8 oracle characters with high C value of 0.875. The oracle characters in the modules principally describe some fruits of cereals.
The above results demonstrate that the shape of oracle characters plays a more vital role in the formation of semantics than the context. In fact, many oracle characters are hieroglyphs that convey semantics in shape. Hence, it is possible to predict the fuzzy semantics of an unknown oracle characters by shape, and then infer accurate semantics by context.
To compare the importance of context and shape to semantic prediction of unknown oracle characters, the context subnetwork is fused with the shape subnetwork in the following steps. First, only the edges eijs<math><mrow is="true"><msubsup is="true"><mi is="true">e</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mi is="true">s</mi></msubsup></mrow></math> stratifying the condition that its two nodes i and j are overlapped with the nodes in the context subnetwork are selected from the shape subnetwork. Next, the weight (wijf<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mi is="true">f</mi></msubsup></mrow></math>) of edge between nodes i and j in the fusion subnetwork is calculated by equation (10). In this way, we can obtained a fusion subnetwork with 1,379 nodes and 83,066 edges.(10)wijf=αwijcmax(wc)+(1-α)wijsmax(ws)<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mi is="true">f</mi></msubsup><mo linebreak="goodbreak" is="true">=</mo><mi is="true">α</mi><mfrac is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mi is="true">c</mi></msubsup><mrow is="true"><mo movablelimits="true" is="true">max</mo><mo stretchy="false" is="true">(</mo><msup is="true"><mi is="true">w</mi><mi is="true">c</mi></msup><mo stretchy="false" is="true">)</mo></mrow></mfrac><mo linebreak="badbreak" is="true">+</mo><mrow is="true"><mo stretchy="false" is="true">(</mo><mn is="true">1</mn><mo is="true">-</mo><mi is="true">α</mi><mo stretchy="false" is="true">)</mo></mrow><mfrac is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mi is="true">s</mi></msubsup><mrow is="true"><mo movablelimits="true" is="true">max</mo><mo stretchy="false" is="true">(</mo><msup is="true"><mi is="true">w</mi><mi is="true">s</mi></msup><mo stretchy="false" is="true">)</mo></mrow></mfrac></mrow></math>where, α is a parameter in the range of (0, 1), wijc<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mi is="true">c</mi></msubsup></mrow></math> is the weight between nodes i and j in the context subnetwork, max(wc) is the maximum weight in the context subnetwork. wijs<math><mrow is="true"><msubsup is="true"><mi is="true">w</mi><mrow is="true"><mi mathvariant="italic" is="true">ij</mi></mrow><mi is="true">s</mi></msubsup></mrow></math> is the weight between nodes i and j in the shape subnetwork and max(ws) is the maximum weight in shape subnetwork.
Because of its excellence in module detection, ClusterONE method is adopted to detect the modules in the fusion subnetwork. The detected modules are compared with metadata, and subject to NMI calculation. Further, parameter α is adjusted into α1, α2, …, αn to obtain different network modules P1, P2, …, Pn. These modules are also compared with the metadata, and subject to NMI calculation (NMI1, NMI2, …, NMIn).
Fig. 10 illustrates the relationship between α, NMI, and the number of modules. It can be seen that, as α increased from 0.01 to 0.5, Both the number of modules and NMIs in the fusion subnetwork remained stable, suggesting that context plays the main role in predicting the semantics of non-hieroglyphic oracle characters, and that the property of module structure for context subnetwork is not disturbed by adding shape factor. When α increased from 0.6 to 0.9, the NMIs continued to grow, indicating that NMI accuracy can be improved by adding context information into the shape subnetwork. But the NMI accuracy was not good by adding shape information into the context subnetwork. Different from the values of NMI, the number of module is decreased rapidly when α is set from 0.6 to 0.9 because of two possible reasons. The first one is that the property of module structure for shape subnetwork become very weak by adding context factor. The other one is that the ClusterONE method may discard some nodes without module structure. Therefore, a reasonable way is to predict the semantics of unknown oracle characters by shape information, and then validate the semantics by context information. This step-by-step semantic prediction approach is consonant with the traditional way to infer semantics of unknown oracle characters. Specifically, shape and context information are not fused to predict semantics. For example, when α equaled 0.5, the NMI (0.4941) reached the minimum.
The module features in oracle character networks provide data and theoretical supports for algorithm design. Here, the multi-scale algorithm is introduced to divide oracle character networks into modules with different sizes. The modules are mined from oracle character networks through spectral factorization [46]. The greatest merit of the method is the flexible setting of the number of modules.
For context and shape subnetworks, the number of modules was adjusted from 1 to 200 for spectral factorization. Then, the two subnetworks are divided into different modules (1–200). Finally, the obtained modules are evaluated against metadata with NMIs. Fig. 11 shows the NMIs of the different number of modules (1–200) mined by spectral factorization. In general, when the number of modules mined is small (the size of module is large), the NMIs are relatively small for the two subnetworks mainly because the size of real modules in oracle character networks is small. In fact, only several oracle characters can describe an entire semantic scene in oracle bone inscriptions. The largest NMIs (0.5059 and 0.6094) appeared, when the number of modules reached 193 and 195 for context and shape subnetworks, respectively. Overall, the modules in oracle character networks have two main features: the modules reflect the local topology of the network, and the module accuracy depends on the quality of module detection method.
Oracle bone inscription is the oldest character system in China. In oracle bone inscriptions, the semantics of about two-thirds of oracle characters are still unknown. Inferring the semantics of unknown oracle characters would greatly promote the research into oracle bone inscriptions and the understanding of the ancient history of China. Considering the significance of context and shape to sematic formation of oracle characters, this work abstracts the context of oracle characters as a complex network based on oracle rubbings, and abstracts the shape of oracle characters as complex network based on the components in such characters. Next, two subnetworks, namely, context subnetwork and shape subnetwork, with known oracle characters are separately extracted from the context and shape networks. After that, three module detection methods are employed to mine modules from the context and shape subnetworks, and the modules with oracle characters of similar semantics are analyzed in details. Then, the roles of context and shape in the semantic prediction of oracle characters are investigated by fusing the two subnetworks. Finally, some features of the modules in oracle character network are examined, revealing that the modules reflect the local topology of the network, and the module accuracy depends on the quality of module detection method. The above results show that oracle characters, despite their long history, have laws of complex system like modern Chinese characters. Therefore, oracle bone inscriptions can be studied by computer-based methods.
Albeit the interesting results, there is ample room for improving the community detection methods in this work. In recent years, as an effective method of artificial intelligence, deep learning [47] is applied to different fields. Such as disease diagnosis [48], [49], intrusion detection [50] and image recognition [51]. Likewise, deep learning has become a new trend in community detection, because it can encode feature representations of high-dimensional data [52] and learn the pattern of nodes, neighborhoods, and subgraphs [53], and so on [54]. Several community detection methods have emerged based on deep learning. For example, Xin et al. [55] designed a structured deep convolutional neural network to detect communities from topologically incomplete networks (TIN). To deal with highly sparse matrices, Sperli [56] described a novel community detection method based on a deep learning. Apart from CNN, Generative adversarial network and graph neural network (GNN) have also been introduced to community detection. Jia et al. [57] first define an embedding that indicates the membership strength of vertices to communities. Second, a specifically designed GAN is adopted to optimize such embedding, and to mine communities. As with deep neural network, graph neural network is also adopted to detect communities. Chen et al. [58] propose a novel family of GNNs for solving community detection problems in a supervised learning setting. Jin et al. [59] solve the problem of semi-supervised community detection in attributed networks with semantic information by combining graph convolutional networks (GCNs) [60] and markov random fields (MRF) [61]. Likewise, Shchur and Gunnemann [62] propose a GNN-based model for overlapping community detection. Since the semantics of about a third oracle characters are known, it is possible to combine deep learning (especially GCNs) with the prior knowledge like the semantics of known oracle characters to improve the accuracy of semantic prediction.
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.
The authors acknowledge the supports from the National Natural Science Foundation of China (No. 61806007, U1804153), the National Social Science Fund Major Entrusted Project of China (No. 16@ZH017A3), the Program for Changjiang Scholars and Innovative Research Team in University (No. 2017PT35).