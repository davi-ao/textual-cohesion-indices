<div class="Body u-font-serif" id="body"><div><section id="sec0005"><h2 id="sect0020" class="u-h3 u-margin-l-top u-margin-xs-bottom">1. Introduction</h2><p id="p0030">Chemical and biochemical systems are typically composed of a large number (several hundreds or thousands) of species interrelated through a complex network of reactions. Computational tools and techniques are therefore necessary to construct, model, or elucidate the transformations occurring in such networks (<a name="bbib0025" href="#bib0025" class="workspace-trigger">Broadbelt &amp; Pfaendtner, 2005</a>). To this end, automated network generators have commonly been applied for network construction and subsequent kinetic modeling (NETGEN (<a name="bbib0030" href="#bib0030" class="workspace-trigger">Broadbelt, Stark, &amp; Klein, 1994</a>), RDL (<a name="bbib0215" href="#bib0215" class="workspace-trigger">Prickett and Mavrovouniotis, 1997a</a>, <a name="bbib0220" href="#bib0220" class="workspace-trigger">Prickett and Mavrovouniotis, 1997b</a>), RMG (<a name="bbib0300" href="#bib0300" class="workspace-trigger">Song, 2004</a>), RDL++ (<a name="bbib0120" href="#bib0120" class="workspace-trigger">Hsu et al., 2008</a>), Genesys (<a name="bbib0335" href="#bib0335" class="workspace-trigger">Vandewiele, Geem, Reyniers, &amp; Marin, 2012</a>), and COMGEN (<a name="bbib0255" href="#bib0255" class="workspace-trigger">Ratkiewicz &amp; Truong, 2003</a>)). Network construction, however, is also the starting point to qualitatively analyze the constituents of the network – the species and reactions – through identification of synthetic/degradation routes (<a name="bbib0075" href="#bib0075" class="workspace-trigger">Finley et al., 2009</a>, <a name="bbib0085" href="#bib0085" class="workspace-trigger">Gonzalez-Lergier et al., 2005</a>), metabolic flux analysis (<a name="bbib0105" href="#bib0105" class="workspace-trigger">Henry, Broadbelt, &amp; Hatzimanikatis, 2007</a>), mechanism identification (<a name="bbib0070" href="#bib0070" class="workspace-trigger">Fan et al., 2002</a>, <a name="bbib0165" href="#bib0165" class="workspace-trigger">Lin et al., 2009</a>), deducing possible functionality of specific sites (<a name="bbib0145" href="#bib0145" class="workspace-trigger">Kummel, Panke, &amp; Heinemann, 2006</a>), etc.</p><p id="p0035">We have developed Rule Input Network Generator (RING) (<a name="bbib0245" href="#bib0245" class="workspace-trigger">Rangarajan, Bhan, &amp; Daoutidis, 2012c</a>), a network generation and analysis tool that allows for both quantitative kinetic analysis and qualitative topological analysis of complex reaction networks. Specifically, RING exhaustively enumerates the reaction network consistent with the user specified initial reactants and reaction rules and provides options for analysis and reduction of the reaction network (see <a name="bsec0020" href="#sec0020" class="workspace-trigger">Section 2.2</a>). RING can handle a variety of chemistries, including gas-phase free-radical and homogeneous/heterogeneous catalytic chemistries (<a name="bbib0230" href="#bib0230" class="workspace-trigger">Rangarajan, Bhan, &amp; Daoutidis, 2010</a>).</p><p id="p0040">The central feature of RING – a reaction network generator – has already been discussed earlier (<a name="bbib0230" href="#bib0230" class="workspace-trigger">Rangarajan et al., 2010</a>). In this article, we discuss in detail the underlying algorithms and techniques for the other modules in RING. In <a name="bsec0025" href="#sec0025" class="workspace-trigger">Section 3</a>, the application of extensible domain-specific language (DSL) tools in developing a language user-interface for RING is discussed. <a name="bsec0060" href="#sec0060" class="workspace-trigger">Section 4.1</a> lays out the algorithm for identifying pathways to specific products in networks generated by RING while <a name="bsec0070" href="#sec0070" class="workspace-trigger">Section 4.2</a> discusses how RING identifies direct and complete mechanisms, or reaction cycles. The algorithm for lumping, or grouping together, of molecules based on constituent functional groups is presented in <a name="bsec0080" href="#sec0080" class="workspace-trigger">Section 4.3</a>, and its extension to accommodate thermochemistry estimation using group contributions is discussed in <a name="bsec0115" href="#sec0115" class="workspace-trigger">section 5</a>. The kinetic modeling feature in RING is presented in <a name="bsec0125" href="#sec0125" class="workspace-trigger">Section 6</a>. We begin our discussion with a brief description of RING and its network generation capabilities.</p></section><section id="sec0010"><h2 id="sect0025" class="u-h3 u-margin-l-top u-margin-xs-bottom">2. Overview of RING</h2><div><p id="p0045"><a name="bfig0005" href="#fig0005" class="workspace-trigger">Fig. 1</a> shows the overall structure of RING. Inputs into RING, written in a domain-specific reaction language, can be classified into three classes. First, the initial reactants of the system are written in a modified (<a name="bbib0245" href="#bib0245" class="workspace-trigger">Rangarajan et al., 2012c</a>) SMILES (<a name="bbib0345" href="#bib0345" class="workspace-trigger">Weininger, 1988</a>) format along with global molecular constraints, such as size and charge restrictions, that need to be satisfied at all times. Second, the reaction rules that describe the chemistry of the reaction system have to be specified either as elementary or as single-step overall reaction rules. The language compiler translates these inputs into internal instructions in the form of C++ functions that call other implemented functions for generating an exhaustive reaction network consistent with the initial reactants and reaction rules. The output of the network generator module is a list of species and reactions pertaining to the network.</p><figure class="figure text-xs" id="fig0005"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr1.jpg" height="119" alt="" aria-describedby="cap0005"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr1.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0005"><p id="spar0015"><span class="label">Fig. 1</span>. Overall structure of RING.</p></span><span>Adapted with permission from <a name="bbib0245" href="#bib0245" class="workspace-trigger">Rangarajan et al. (2012c)</a> Copyright© 2012 Elsevier Inc.</span></span></figure></div><section id="sec0015"><h3 id="sect0030" class="u-h4 u-margin-m-top u-margin-xs-bottom">2.1. Network generation procedure</h3><p id="p0050">The initial reactants and reaction rules are converted internally into molecular graphs and graph transformation rules, respectively. Molecular graphs are composed of atoms as nodes and bonds as edges. Transformation rules involve “reactant patterns” of atoms and bonds in the reaction center and information that describes how properties of these atoms and bonds have to be rewritten. The reactant patterns of the rule are identified on the molecular graphs using subgraph isomorphism (<a name="bbib0310" href="#bib0310" class="workspace-trigger">Ullmann, 1976</a>). Network construction is an iterative process wherein graph transformation rules are repeatedly applied to molecular graphs to generate new graphs. The transformation of the reactant graph to the product graph is a reaction and new molecular graphs, representing new species, are in turn subject to graph transformation rules. The procedure of graph transformation involves identifying molecular subgraphs corresponding to reactant patterns in reactant graphs through pattern matching and rewriting the properties of the nodes (atoms) and edges (bonds) of the reactant graphs. Casting network generation as a graph transformation problem makes it independent of the chemistry per se, thereby allowing for generating any chemical reaction network. The process for network generation continues until no new molecule is encountered; however, being combinatorial in nature this could lead to a very large number of reactions and species being generated. RING, therefore, provides rule constraints and rank-based termination features (<a name="bbib0230" href="#bib0230" class="workspace-trigger">Rangarajan et al., 2010</a>). RING also extensively adopts cheminformatics algorithms to represent molecules as unique SMILES and patterns as SMARTS strings, and to identify symmetry, rings, aromaticity, etc. in a molecule. A more detailed description of the network generation process is in <a name="bbib0230" href="#bib0230" class="workspace-trigger">Rangarajan et al. (2010)</a>. A summary of RING's network generation algorithm is included in the supporting information.</p></section><section id="sec0020"><h3 id="sect0035" class="u-h4 u-margin-m-top u-margin-xs-bottom">2.2. Network analysis with RING</h3><p id="p0055">Network generation, in itself, is the first step of complex network analysis. A third category of inputs – a set of post-processing instructions – to qualitatively and quantitatively analyze the network can be specified within RING. These inputs include: (a) network queries in terms of identifying specific reactions, species, pathways, and mechanisms, (b) instructions on lumping isomers, (c) thermochemistry specification in the form of group additivity methods, and (d) kinetic parameters for each chemistry rule in a conditional rule-based approach and reactor conditions. Pathways are output as a set of reactions connecting queried product molecules from initial reactants, while mechanism queries enumerate supersets of pathways such that the net transformation has no intermediates involved in the overall reaction. Querying for specific reactions and molecules leads to a desired list of these network components, while lumping (or grouping) of isomers results in lists of species lumps and lumped reactions. Providing group additivity rules allows for calculating species and reaction enthalpy, entropy, and free energy. This could, then, be used in conjunction with the querying features to identify energetically feasible pathways and mechanisms. When kinetic and reactor parameters are provided and thermochemistry estimation rules are made available, the kinetic modeling feature outputs yields of different species, overall conversion, sensitivities, and degree of rate control (<a name="bbib0040" href="#bib0040" class="workspace-trigger">Campbell, 1994</a>). RING is available open source (<a name="bbib0265" href="#bib0265" class="workspace-trigger">RING, 2013</a>) under the GNU Lesser GPL v2.1.</p></section></section><section id="sec0025"><h2 id="sect0040" class="u-h3 u-margin-l-top u-margin-xs-bottom">3. Reaction language and compiler</h2><div><p id="p0060">A language interface for network generation was first proposed and introduced by <a name="bbib0215" href="#bib0215" class="workspace-trigger">Prickett and Mavrovouniotis (1997a)</a>. <a name="bbib0120" href="#bib0120" class="workspace-trigger">Hsu et al. (2008)</a> expanded this language to include features specifically meant for heterogeneous catalysis. These are domain specific languages, or DSLs, and are custom languages developed specifically for describing reaction rules. Domain specific languages (DSLs) have several advantages (<a name="bbib0060" href="#bib0060" class="workspace-trigger">van Deursen, Klint, &amp; Visser, 2000</a>): (a) they allow for using high level notations as specifications that are well known to the domain expert, (b) programs are concise and “self-documenting”, and (c) domain knowledge-based validation and optimizations are possible. The reaction language in RING offers these advantages as well; specifically, the syntax is composed entirely of chemistry parlance making it easier to understand and debug compared to general purpose languages. <a name="bfig0010" href="#fig0010" class="workspace-trigger">Fig. 2</a> shows a sample reaction rule input to RING – protonation of a carbonyl group. The reaction rule consists of several parts: (a) declaration of the reaction center or reactant patterns (lines 2–6) that define the atoms and bonds participating in the rule, (b) specification of atom (curly brackets in line 3) and molecular constraints (lines 7 and 8) describing restrictions on the specific atoms in the reaction center or the entire reactant respectively, and (c) a list of transformations (lines 9–11) describing changes in the electronic configuration of the atoms or the order (single, double, etc.) of bonds</p><figure class="figure text-xs" id="fig0010"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr2.jpg" height="259" alt="" aria-describedby="cap0010"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr2.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0010"><p id="spar0020"><span class="label">Fig. 2</span>. Example reaction rule – protonation of a keto group.</p></span></span></figure></div><p id="p0065">High-level notations used in the language (<a name="bfig0010" href="#fig0010" class="workspace-trigger">Fig. 2</a>) such as “rule”, “neutral”, “reactant”, “single bond”, “positive”, etc. are derived from common chemistry terminology. Further, the structure of a reaction rule specification scheme – description of reaction center, stipulation of constraints, and description of transformations – closely mimics a chemist's description of the reaction rule. These two factors, thereby, allow for a one-to-one correspondence between how the user would perceive the reaction rule and write it down in the reaction language.</p><div><p id="p0070"><a name="bfig0015" href="#fig0015" class="workspace-trigger">Fig. 3</a> zooms in on the compiler in the overall structure of RING. The core of the reaction language of RING – reaction rule specification language – is an <em>extensible language</em> that focuses solely on describing the reaction rules of interest. These specifications are then transformed by the compiler into C++ code that makes use of the reaction network generator library. RING is equipped with a number of extensions, specifically those for specifying post-processing features such as pathways and mechanisms queries. Each new feature or module in RING can contribute a <em>language extension</em> to the compiler, usually with additional syntax for describing any specific additional inputs required. The compiler translates these instructions into appropriate C++ code that can then be compiled with RING's core C++ implementation.</p><figure class="figure text-xs" id="fig0015"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr3.jpg" height="140" alt="" aria-describedby="cap0015"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr3.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0015"><p id="spar0025"><span class="label">Fig. 3</span>. The overall structure of RING, zoomed in on the compiler component, using the pathways analysis module as an example of a post-processing module.</p></span></span></figure></div><p id="p0075">The core of the reaction language of RING bears some similarity to RDL++ (<a name="bbib0120" href="#bib0120" class="workspace-trigger">Hsu et al., 2008</a>), although the superficial syntax is quite different, as RING is not based on <em>S-expressions</em>. There are, however, some notable differences from that system. First, inputs into RING are compiled to C++, whereas RDL interprets them. This allows the RING compiler to perform many “optimizations” on the rules given by the user. This can potentially be a significant advantage in the specification of molecule constraints because these are directly translated to C++ Boolean functions that are optimized to fail fast (see <a name="bsec0030" href="#sec0030" class="workspace-trigger">Section 3.1</a>). Second, while both RING and RDL++ perform name-binding and basic type checking (for example, where a molecule is expected, ensuring that a name refers to a molecule and not a bond), RING further ensures that the transformations described are appropriate at compile time, checking for basic chemistry mistakes like valency violations. For example, in the sample rule in <a name="bfig0010" href="#fig0010" class="workspace-trigger">Fig. 2</a>, if either of the two <span class="monospace">modify atomtype</span> statements are missing, the reaction rule would not conserve charge, and the compiler would generate an appropriate error. Further, if <span class="monospace">double bond to c1</span> was erroneously written as <span class="monospace">double bond to c2</span> or <span class="monospace">aromatic bond to c1</span>, the compiler would generate errors stating that <span class="monospace">c2</span> is not a previously defined label and that aromatic bonds can only exist between two aromatic atoms.</p><p id="p0080">The extended Backus–Naur form (EBNF) of the grammar of the language is given in the supporting information. RING's distribution includes a complete manual with all the syntax. Interested readers can access the documentation available online (<a name="bbib0265" href="#bib0265" class="workspace-trigger">RING, 2013</a>).</p><section id="sec0030"><h3 id="sect0045" class="u-h4 u-margin-m-top u-margin-xs-bottom">3.1. Compiler optimizations</h3><p id="p0085">Three broad categories of optimizations are performed by the compiler to enhance the speed of execution. We discuss these categories first and then provide illustrative statistics to demonstrate the efficacy of these optimizations.</p><section id="sec0035"><h4 id="sect0050" class="u-margin-m-top u-margin-xs-bottom">3.1.1. Constraint categorization</h4><p id="p0090">The network generation algorithm needs to sift through candidate molecules for each of the reactants in a bimolecular reaction rule to identify potential co-reactants. Each possible pair of molecules must be considered for each rule. If the pair satisfies the constraints, a check for the presence of the relevant reaction patterns in the reactants can be done and subsequently new reactions generated. The constraints in a rule can be categorized as depending on one or the other reactant individually, and those “combined” constraints that unavoidably depend on both reactants. Ordering the constraints such that individual constraints are checked first can potentially speed up the network generation process. For example, if a molecule does not satisfy the constraints pertaining to the first reactant in the rule, then there is no need to check for a potential molecule pair. The RING compiler automatically classifies the constraints into these categories and emits them as separate constraint checking functions for the network generator. These functions are used in the specific order – individual constraints of the first reactant, individual constraints of the second reactant if the first set of constraints are satisfied, and combined constraints if individual reactant constraints are all satisfied. The order of specification of constraints by the user is, thus, immaterial.</p></section><section id="sec0040"><h4 id="sect0055" class="u-margin-m-top u-margin-xs-bottom">3.1.2. Constraint ordering</h4><p id="p0095">The order in which either individual or combined constraints are checked may also affect performance. For example, it is faster to check the number of heavy atoms or the charge of a molecule than to check if the molecule has a large functional group, such as acid anhydride. The compiler estimates heuristically the cost of checking each constraint, and orders them to attempt to verify those constraints that are quick and easy to check before those that are slower. For example, checking for molecule size or charge precedes any checks for molecular fragments.</p></section><section id="sec0045"><h4 id="sect0060" class="u-margin-m-top u-margin-xs-bottom">3.1.3. Pattern re-ordering</h4><p id="p0100">Checking constraints that involve identification of specific functional groups in a molecule and detecting reactant patterns require pattern matching of a fragment in a molecule. In such cases, the particular arrangement of atoms in the reactant patterns or functional groups can speed up the matching process. The compiler re-orders these patterns before presenting it to the network generator to try to fail to match as early as possible. Unlike constraints re-ordering, where there is a cost associated with checking each constraint, here the cost for each atom is roughly the same. Instead, the atoms and bonds are ordered roughly by likelihood that they occur at all in molecules. Most organic molecules derived from biomass/petroleum sources have more carbon atoms than oxygen atoms. Consider a six carbon ring and a pattern with two carbons and an oxygen, such as the fragment “C–C–O”. There are 12 different ways the two carbons could match this molecule before failing due to the lack of an oxygen, but matching the oxygen first would fail immediately. Placing rarer atoms first can thus make the matching fail early and thus speed up the pattern matching process. RING applies several empirical heuristics for the likelihood of occurrence, such as: (a) nitrogen, sulfur, and phosphorous atoms are rarer than oxygen atoms, which in turn are rare compared to carbon atoms, (b) charged atoms occur less frequently than neutral atoms in a network, and (c) stronger bonds (double and triple) are rarer than single bonds.</p><div><p id="p0105"><a name="btbl0005" href="#tbl0005" class="workspace-trigger">Table 1</a> lists the run-time ratios upon enabling: (a) only the constraint categorization optimization compared to having no optimizations (None→Constr. Cat), and (b) all the optimizations with respect to having constraint categorization alone (Constr. Cat→All) for five systems in a benchmarking study. The systems included in the study are: (a) the synthesis network for forming longer chain alcohols from smaller (C<sub>1</sub>-C<sub>2</sub>) oxygenates using base catalyzed carbon–carbon bond formation and metal catalyzed (de)hydrogenation chemistries, (b) acid catalyzed conversion of fructose to 5-hydroxymethylfurfural (HMF), (c) pyrolysis of glucose by neutral electrocyclic reaction steps, (d) conversion of HMF to levulinic acid in acidic medium, and (e) acid catalyzed aromatization of propane. The first system (base catalysis) consists of single-step non-elementary overall reaction rules, while the other systems are modeled in terms of elementary steps. The reaction rules are given in the supporting information. It can be noted that while optimizations do not lead to statistically significant speed-up in the first three cases, there is considerable savings in the run times for the last two systems – HMF-to-levulinic acid and propane aromatization. Specifically, the network generation time for the HMF-to-levulinic acid system speeds up by a factor of 60 upon enabling constraint categorization alone. This is attributable to the nature of constraints imposed in some of the reaction rules of this system wherein one of the reactants is restricted to being an oxygenate. Checking for this constraint early prevents RING from performing several unnecessary steps before eventually rejecting a molecule because it does not satisfy that constraint. This system, however, shows no further noticeable improvement upon subsequently enabling the other two optimizations. On the other hand, the propane aromatization system shows significant speed-up due to constraints categorization alone as well as all upon enabling all the optimizations. The additional improvement in the latter case is possibly due to the constraint ordering optimization because this system contains a greater number of constraints relative to the other systems. Pattern re-ordering, although not explicitly resulting in any statistically significant improvement in these five systems, can lead to about 15% speed-up (and potentially more) in identifying individual patterns in some cases (see data in supporting information). Thus, the statistics presented in <a name="btbl0005" href="#tbl0005" class="workspace-trigger">Table 1</a> suggest that systems with: (a) reaction rules having very restrictive constraints, and (b) large reaction networks (several tens of thousands of reactions) can benefit significantly from compiler optimizations.</p><div class="tables frame-topbot colsep-0 rowsep-0" id="tbl0005"><span class="captions"><span id="cap0050"><p id="spar0060"><span class="label">Table 1</span>. Benchmarking statistics: run-time ratios for successive compiler optimizations.</p></span></span><div class="groups"><table class="align-center"><thead class="valign-top"><tr><th scope="col" class="colsep-0 align-left">Benchmarks</th><th scope="col" class="colsep-0 align-left">Reactions</th><th scope="col" class="colsep-0 align-left">Species</th><th scope="col" class="colsep-0 align-left rowsep-1" colspan="2">Run-time ratio</th></tr><tr class="rowsep-1"><th scope="col" class="colsep-0 align-left"></th><th scope="col" class="colsep-0 align-char"></th><th scope="col" class="colsep-0 align-char"></th><th scope="col" class="colsep-0 align-left">None→Constr. Cat<a name="btblfn0005" href="#tblfn0005" class="workspace-trigger"><sup>a</sup></a></th><th scope="col" class="colsep-0 align-left">Constr. Cat→All</th></tr></thead><tbody><tr><td class="colsep-0 align-left">Base catalysis</td><td class="colsep-0 align-char">12,771</td><td class="colsep-0 align-char">4609</td><td class="colsep-0 align-char">1.02&nbsp;±&nbsp;0.08</td><td class="colsep-0 align-char">1.00&nbsp;±&nbsp;0.01</td></tr><tr><td class="colsep-0 align-left">Fructose-to-HMF</td><td class="colsep-0 align-char">1223</td><td class="colsep-0 align-char">546</td><td class="colsep-0 align-char">1.09&nbsp;±&nbsp;0.02</td><td class="colsep-0 align-char">0.99&nbsp;±&nbsp;0.02</td></tr><tr><td class="colsep-0 align-left">Glucose pyrolysis</td><td class="colsep-0 align-char">14,375</td><td class="colsep-0 align-char">3131</td><td class="colsep-0 align-char">1.00&nbsp;±&nbsp;0.01</td><td class="colsep-0 align-char">1.00&nbsp;±&nbsp;0.01</td></tr><tr><td class="colsep-0 align-left">HMF→Levulinic acid</td><td class="colsep-0 align-char">39,844</td><td class="colsep-0 align-char">14,875</td><td class="colsep-0 align-char">58.30&nbsp;±&nbsp;0.59</td><td class="colsep-0 align-char">1.00&nbsp;±&nbsp;0.01</td></tr><tr><td class="colsep-0 align-left">Propane aromatization</td><td class="colsep-0 align-char">2031</td><td class="colsep-0 align-char">594</td><td class="colsep-0 align-char">1.41&nbsp;±&nbsp;0.03</td><td class="colsep-0 align-char">1.21&nbsp;±&nbsp;0.00</td></tr></tbody></table></div><dl class="footnotes"><dt id="tblfn0005">a</dt><dd><p id="npar0005">Constraint categorization optimization.</p></dd></dl></div></div></section></section><section id="sec0050"><h3 id="sect0065" class="u-h4 u-margin-m-top u-margin-xs-bottom">3.2. Language extension</h3><p id="p0110">The RING compiler and language is capable of supporting independently developed post-processing modules due to its design and implementation in a domain-specific language called Silver (<a name="bbib0320" href="#bib0320" class="workspace-trigger">Van Wyk, Bodin, Gao, &amp; Krishnan, 2010</a>) that uses a parser generator called Copper (<a name="bbib0330" href="#bib0330" class="workspace-trigger">Van Wyk &amp; Schwerdfeger, 2007</a>). These two tools are designed to support implementing extensible languages. A language extension can add both new syntax and analysis of the existing language. For example, an extension can add new error checks for the sensibility of the reaction rules, or an entirely new syntax intended for a new post-processing option. The difficulty of accomplishing language extension lies in two areas: (a) a full range of extensions have to be possible without dramatically complicating the design of the compiler and (b) different extensions should not conflict so that a working compiler cannot be generated.</p><p id="p0115">Silver is a functional language based on attribute grammars, with a strong composition model for attribute grammars and is used to define the semantics (for error checking), optimization, and translation of RING programs. Thus, the main components of the RING compiler are written as an attribute grammar in Silver, and these make no reference to any extensions (post-processing options). Instead, Silver is simply able to take the extension grammars it is provided with and automatically compose them with the host language grammar, producing a working compiler with all the requested pieces combined. Host languages and extensions for Java (<a name="bbib0325" href="#bib0325" class="workspace-trigger">Van Wyk, Krishnan, Schwerdfeger, &amp; Bodin, 2007</a>), C, Promela (<a name="bbib0170" href="#bib0170" class="workspace-trigger">Mali &amp; Van Wyk, 2011</a>), and Modelica have been written in Silver, and in fact the Silver compiler is also written in Silver. These capabilities allow for post-processing modules to fully integrate with the RING compiler.</p><p id="p0120">Copper is a parser and context-aware scanner generator that is used to define the concrete (or surface) syntax of RING. Context-aware scanning solves a number of problems in composing language extensions, one being the problem with different extensions introducing the same keyword into the language (<a name="bbib0330" href="#bib0330" class="workspace-trigger">Van Wyk &amp; Schwerdfeger, 2007</a>). Context-aware scanners return only tokens that would not cause a syntax error and thus if two extensions introduce the same keywords but they appear in different contexts, the scanner will always return the appropriate one. This makes it somewhat easier to write the context-free grammars that define language syntax and to ensure that they exists in the LALR(1) sub-class of context-free grammars (<a name="bbib0010" href="#bib0010" class="workspace-trigger">Aho, Sethi, &amp; Ullman, 1986</a>) that are supported by Copper.</p><p id="p0125">The formalisms of attribute grammars, used by Silver, and context-free grammars, used by Copper, naturally compose and thus it is rather straightforward to take a host language specification and collection of language extension specifications to create the specification for a customized extended language. However, these compositions are not always well-defined, in the case of attribute grammars, or in the LALR(1) class, in the case of context free grammars. Both Silver and Copper have <em>modular</em> analyses that can be used by the language extension designer to check if their extension is of the form that it will later compose with other extensions that also pass this analysis. These analyses effectively <em>verify</em> an extension as one that is composable. A programmer that selects only verified extensions is assured that the composition of the host language and his or her selection of extensions will be well-defined. For further details on these analysis we refer the reader to the relevant papers (<a name="bbib0135" href="#bib0135" class="workspace-trigger">Kaminski and Van Wyk, 2012</a>, <a name="bbib0295" href="#bib0295" class="workspace-trigger">Schwerdfeger and Van Wyk, 2009</a>).</p><div><p id="p0130">The RING compiler comes with a number of post-processing extensions already, the organization of a representative part of which can be seen in <a name="bfig0020" href="#fig0020" class="workspace-trigger">Fig. 4</a>. The language extension, “pathway constraint language”, adds the syntax for expression pathway constraints to the host language (reaction rule specification language). Each post-processing analysis option further has a corresponding language extension that depends on the host language and the pathway constraint language extension, and adds a specific type of analysis expressible in the extended language. For example, “pathways analysis” language allows for expressing pathway queries in addition to specifying the reaction rules of a system. Each of these extensions is an independent (only those dependencies shown) grammar, and the full compiler is built by having Silver compose them all together.</p><figure class="figure text-xs" id="fig0020"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr4.jpg" height="176" alt="" aria-describedby="cap0020"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr4.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0020"><p id="spar0030"><span class="label">Fig. 4</span>. The host language, and a representative subset of extensions to it, implemented in Silver. The arrows represent dependencies between grammars.</p></span></span></figure></div></section></section><section id="sec0055"><h2 id="sect0070" class="u-h3 u-margin-l-top u-margin-xs-bottom">4. Post-processing</h2><p id="p0135">Instructions given subsequent to reaction rule description for identifying network information such as isomer lumps, specific reactions and molecules, and pathways and mechanisms, constitute post-processing options in RING. In this section, we discuss in detail the algorithms of these options.</p><section id="sec0060"><h3 id="sect0075" class="u-h4 u-margin-m-top u-margin-xs-bottom">4.1. Pathway identification</h3><div><p id="p0140">The pathway identification algorithm in RING finds all pathways between the initial reactants and specified products of the generated network. <a name="bfig0025" href="#fig0025" class="workspace-trigger">Fig. 5</a> shows a sample query for pathways to acetone of length less than six steps and not having more than two instances of the rule “HydrideShift” (assuming such a rule was specified earlier). The algorithm makes use of two sets of information identified and stored during network generation. First, RING keeps track of the rank of each species in the network – the minimum number of steps required for that molecule to form from any of the initial reactants. Second, the “closer” parent of each product molecule in a reaction is identified during network generation in a three-step process. The reactant with a larger rank (that is, the one further from the initial reactants) is the de facto closer parent; if all reactants have the same rank, however, the one that contributes most number of atoms to the product becomes its closer parent. In case of a tie, the first reactant is assumed to be the closer parent. The ranks and parent information are used in a reverse depth-first search starting from the product and traversing backwards along the network to reach the initial reactants. The details of the algorithm are given in <a name="benun0005" href="#enun0005" class="workspace-trigger">Algorithm 1</a>.</p><figure class="figure text-xs" id="fig0025"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr5.jpg" height="114" alt="" aria-describedby="cap0025"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr5.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0025"><p id="spar0035"><span class="label">Fig. 5</span>. Sample post-processing instruction written in the language: a query to obtain pathways to acetone.</p></span></span></figure></div><p id="p0145"><section><p id="enun0005"><strong>Algorithm 1</strong></p><p id="p0150"><strong>FindPathways</strong> (Molecule M<sub>0</sub>, integer MaxPathLength, PathwayConstraints P<sub><em>C</em></sub>) <span class="display"><div class="tables frame-topbot colsep-0 rowsep-0" id="tbl0010"><div class="groups"><table class="align-center"><tbody><tr><td class="colsep-0 align-left"><em>PathwayStack</em>&nbsp;←&nbsp;{} Stack of reactions constituting a pathway</td></tr><tr><td class="colsep-0 align-left"><em>AllPathways</em>&nbsp;←&nbsp;{} List of pathways</td></tr><tr><td class="colsep-0 align-left"><em>MoleculeStack</em>&nbsp;←&nbsp;M<sub>0</sub> Stack of molecules traversed</td></tr><tr><td class="colsep-0 align-left"><strong>while !</strong> <em>MoleculeStack</em>.empty() <strong>do</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>if</strong> <em>MoleculeStack</em>.top() is an initial reactant <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>if</strong> <em>MoleculeStack</em> has no repeating entry <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>AllPathways</em>.push (<em>PathwayStack</em>)</td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>PathwayStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>MoleculeStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>else</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;find new Reaction, R, that forms the Molecule <em>MoleculeStack</em>.top()</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>if</strong> found &amp; &amp; <em>PathwayStack</em>.size() &lt;MaxPathLength <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;  find closer parent Molecule, P, of <em>MoleculeStack</em>.top() in R</td></tr><tr><td class="colsep-0 align-left">&nbsp;  <strong>if</strong> P ∉ <em>MoleculeStack</em> &amp; &amp; <em>PathwayStack</em>.size() + Rank(P) ≤ MaxPathLength <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;<em>PathwayStack</em>.push(R)</td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;<em>MoleculeStack</em>.push(P)</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>else</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>PathwayStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>MoleculeStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left"><strong>return</strong> AllPathways satisfying constraints P<sub><em>C</em></sub></td></tr></tbody></table></div></div></span></p></section></p><p id="p0155">The inputs of the algorithm are the target molecule, the maximum path length desired and additional pathway constraints (<a name="bfig0025" href="#fig0025" class="workspace-trigger">Fig. 5</a>), while the output is a list of pathways, each of which, in turn, is a set of reactions. Since the rank of each molecule in the network is known through network generation, the shortest pathway to M<sub>0</sub> is already known. Therefore, for the algorithm to proceed, M<sub>0</sub> must satisfy the condition: Rank(M<sub>0</sub>) ≤ MaxPathLength. It is better to traverse backwards from the product to the initial reactant because the parent molecule of each product of a reaction is known. During the process of traversal, a stack of intermediate molecules, <em>MoleculeStack</em>, is maintained. The first, and hence the bottom, element of the stack is M<sub>0</sub>. The algorithm also maintains a stack of reactions that constitutes the pathway. At each step of the traversal, a reaction that produces the molecule at the top of <em>MoleculeStack</em> is found and the parent, ‘P’, of this molecule is chosen as the next intermediate molecule if P's rank permits that a pathway can be formed in MaxPathLength steps or less. The reaction is then added into the <em>PathwayStack</em>. Furthermore, at each step, the next molecule is chosen such that it is not already present in <em>MoleculeStack</em>. This ensures that cycles are avoided and only acyclic paths are returned by the algorithm. If, ultimately, a parent is reached within MaxPathLength steps such that it is one of the initial reactants, a pathway is deemed found, and the stack of reactions in <em>PathwayStack</em> is added to a list of pathways, <em>AllPathways</em>. The algorithm then backtracks to the previous molecule in <em>MoleculeStack</em> and proceeds as above. The algorithm terminates when <em>MoleculeStack</em> ultimately turns empty. The pathways, thus found, do not consider the co-reactants and products of a reaction and the relevant intermediate molecules of a pathway are determined by the parent–daughter relationship of each reaction. As shown in <a name="bfig0025" href="#fig0025" class="workspace-trigger">Fig. 5</a>, the user can specify constraints to describe the target molecule M<sub>0</sub> and subsequently provide pathway constraints. All pathways obtained are subsequently checked to ensure they satisfy other pathway constraints. These pathway constraints include: (a) the number of occurrences of specific rules, (b) bounds on the occurrence of specific molecules as reactants or products in the entire pathway or in a reaction belonging to a particular reaction rule in the pathway, and (c) upper bounds on the activation barrier (if available or can be calculated for individual reactions).</p><p id="p0160">Sometimes, several pathways may be found between an initial reactant and a specified product that have the same length, and the same number of reactions of each rule type. Such pathways differ only in the order of reaction within the pathway with intermediates of one pathway being isomers of that of another. Such pathways can be grouped together as a single pathway in RING by using the <span class="monospace">eliminate similar pathways</span> command, as shown in <a name="bfig0025" href="#fig0025" class="workspace-trigger">Fig. 5</a>.</p><section id="sec0065"><h4 id="sect0080" class="u-margin-m-top u-margin-xs-bottom">4.1.1. Comparison with other pathway finding algorithms</h4><p id="p0165">Pathways identification has extensive applications in biological network analysis and biological network reconstruction as it allows for understanding various complex biochemical processes such as metabolism. These pathway finding algorithms identify k-shortest paths (<a name="bbib0065" href="#bib0065" class="workspace-trigger">Eppenstein, 1998</a>) between source and target compounds or reactions of a directed weighted/unweighted network with or without tracking the destination of each of the atoms (<a name="bbib0055" href="#bib0055" class="workspace-trigger">Croes et al., 2006</a>, <a name="bbib0100" href="#bib0100" class="workspace-trigger">Heath et al., 2010</a>, <a name="bbib0130" href="#bib0130" class="workspace-trigger">Jeong et al., 2000</a>). These algorithms start with a given set of reactions typically constructed from databases. To assess the performance of our algorithm, we compare our algorithm with these state-of-the-art generic pathway finding algorithms. The comparisons are only qualitative because these algorithms cater to any assembled network of reactions while our algorithm is specific to networks generated from an initial set of reactants by successive application of reaction rules; our algorithms are therefore optimized for the specific case of analyzing automatically generated reaction networks.</p><p id="p0170">The algorithm in RING differs from these algorithms in several ways. First, because the network was constructed from initial reactants and reaction rules, it is safe to assume that each species in the network can be traced back to the initial reactant in at least as many steps as the rank of the species. This assumption, however, does not hold in the algorithms discussed above. Second, in RING, backtracking along any path from the products will ultimately lead to the initial reactants; this again does not hold in generic pathway identification algorithms. Indeed, in those algorithms, forward or reverse search of the network from the reactants or products respectively will have similar performance. Third, our pathway algorithm can, in effect, track atoms along the pathway because the information of the parent reactants for each reaction is available. For the generic pathway identification algorithms, tracking the destination of the atoms of a reactant in the network requires identification of atom mapping between the reactants and products.</p></section></section><section id="sec0070"><h3 id="sect0085" class="u-h4 u-margin-m-top u-margin-xs-bottom">4.2. Mechanism enumeration</h3><p id="p0175">In addition to pathways, RING can identify <em>direct</em> and <em>complete</em> mechanisms. Direct mechanisms represent reaction cycles containing a set of reactions such that the overall reaction has no reactive intermediates. Complete mechanisms represent, on the other hand, a set of direct mechanisms (or reaction cycles) that describe the complete transformation from the initial reactants to any products. Complete mechanisms are supersets of reaction pathways because they contain the additional information of reactions leading from/to co-reactants/co-products. We also note that both direct and complete mechanisms refer only to a set of reactions and their stoichiometry and not to their kinetics or thermochemistry, although these can be calculated if relevant information is available. Further, at this stage, we do not even consider possible rate-determining steps.</p><p id="p0180"><a name="benun0010" href="#enun0010" class="workspace-trigger">Algorithm 2</a> describes the procedure for finding direct mechanisms. The procedure is similar to that of finding pathways – a reverse depth-first search is employed with stacks for reactions and molecules that get populated along the traversal. At each step of the traversal, a reaction ‘R’ is chosen, like in pathways. However, ‘R’ is chosen on the basis of the stoichiometric coefficient of the current intermediate – top molecule of <em>MoleculeStack</em> – in the overall reaction, O<sub><em>R</em></sub>, of all the reactions in <em>ReactionStack</em>. Therefore, this reaction could form/consume the intermediate as appropriate. Further, the algorithm ensures that adding the new reaction will not lead to closed cycles that are net-zero in overall stoichiometry. The intermediate chosen for the next step of the traversal is a reactive intermediate in O<sub><em>R</em></sub>. A direct mechanism is found when no reactive intermediates are explicitly involved in the overall reaction. As the overall reaction is checked each time a reaction is added, this procedure ensures that the mechanism is composed of a minimal set of reactions and, hence, is direct. Further, the stoichiometric coefficient of a reactive intermediate in <em>ReactionStack</em> may not just be 1 (or −1) but could be higher or lower. Similarly, the stoichiometric coefficient of the intermediate in ‘R’ need not be 1 (or −1). In such cases, appropriate stoichiometric numbers, <em>ν</em><sub>1</sub> and <em>ν</em><sub>2</sub> in the algorithm, need to be found so that the overall reaction O<sub><em>R</em></sub>, of ‘R’ and reactions in <em>ReactionStack</em> taken together, does not explicitly involve the reactive intermediate at all. The algorithm terminates when <em>MoleculeStack</em> is empty.</p><p id="p0185"><section><p id="enun0010"><strong>Algorithm 2</strong></p><p id="p0190"><strong>FindDirectMechanisms</strong> (Molecule M<sub>0</sub>, integer MaxLength, MechanismConstraints M<sub><em>C</em></sub>) <span class="display"><div class="tables frame-topbot colsep-0 rowsep-0" id="tbl0015"><div class="groups"><table class="align-center"><tbody><tr><td class="colsep-0 align-left"><em>ReactionStack</em> ← {} Stack of reactions constituting a direct mechanism</td></tr><tr><td class="colsep-0 align-left"><em>AllDirectMechs</em> ← {} List of direct mechanisms</td></tr><tr><td class="colsep-0 align-left"><em>MoleculeStack</em> ← M<sub>0</sub> Stack of molecules traversed</td></tr><tr><td class="colsep-0 align-left"><strong>while !</strong> <em>MoleculeStack</em>.empty() <strong>do</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>if</strong> <em>ReactionStack</em> is a direct mechanism <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;<em>AllDirectMechs</em>.push (<em>ReactionStack</em>)</td></tr><tr><td class="colsep-0 align-left">&nbsp;<em>ReactionStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;<em>MoleculeStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>else</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;find new reaction, R, forming/consuming <em>MoleculeStack</em>.top()</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>if</strong> found &amp; &amp; # of unique reactions in <em>ReactionStack</em> + 1 ≤ MaxLength <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;  <strong>if</strong> adding R into the <em>ReactionStack</em> does not lead to cycles <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;determine the stoichiometric factors, <em>ν</em><sub>1</sub> and <em>ν</em><sub>2</sub>, of <em>ReactionStack</em> and R respectively</td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;get the overall reaction O<sub><em>R</em></sub> of <em>ν</em><sub>1</sub>×<em>ReactionStack</em> and <em>ν</em><sub>2</sub>× R</td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;<strong>if</strong> O<sub><em>R</em></sub>&nbsp;≠&nbsp;<em>φ</em> <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;  find reactive intermediate I ∈ <em>O</em><sub><em>R</em></sub></td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;  <strong>if</strong> found <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;&nbsp;<em>ReactionStack</em>.push(R)</td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;&nbsp;<em>MoleculeStack</em>.push(M<sub>1</sub>)</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>else</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>MechanismStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>MoleculeStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left"><strong>return</strong> AllDirectMechs satisfying M<sub><em>C</em></sub></td></tr></tbody></table></div></div></span></p></section></p><p id="p0195"><a name="benun0015" href="#enun0015" class="workspace-trigger">Algorithm 3</a> lays out the procedure adopted in RING for finding complete mechanisms. This algorithm also involves a reverse depth-first search strategy like in the identification of pathways and direct mechanisms, but at each step of the traversal, direct mechanisms are added instead of individual reactions. Note that direct mechanisms are also referred to as reaction cycles (“RxnCycles”, specifically) in the algorithm. The direct mechanisms are calculated on-the-fly when a new intermediate is encountered and stored until the end. This way, direct mechanisms of only the relevant intermediates need to be identified, and further, only once. At each step, the next intermediate is chosen from amongst all the non-initial reactants of the overall reaction O<sub><em>R</em></sub>. An overall reaction is found when the reactants of O<sub><em>R</em></sub> are all initial reactants of the given system. In this sense, mechanisms and pathways parallel stoichiometric and path-finding approaches in systems biology (<a name="bbib0210" href="#bib0210" class="workspace-trigger">Planes &amp; Beasley, 2008</a>).</p><p id="p0200"><section><p id="enun0015"><strong>Algorithm 3</strong></p><p id="p0205"><strong>FindCompleteMechs</strong>(Molecule M<sub>0</sub>, integer MaxLength, integer MaxRxnCycles, OverallConstraints M<sub><em>C</em></sub>) <span class="display"><div class="tables frame-topbot colsep-0 rowsep-0" id="tbl0020"><div class="groups"><table class="align-center"><tbody><tr><td class="colsep-0 align-left"><em>MechanismStack</em> ← {} Stack of direct mechanisms constituting a complete mechanism</td></tr><tr><td class="colsep-0 align-left"><em>AllMechanisms</em> ← {} List of complete mechanisms</td></tr><tr><td class="colsep-0 align-left"><em>MoleculeStack</em> ← M<sub>0</sub> Stack of molecules traversed</td></tr><tr><td class="colsep-0 align-left"><strong>while</strong>! <em>MoleculeStack</em>.empty() <strong>do</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>if</strong> <em>MechanismStack</em> is a complete mechanism <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;<em>AllMechanisms</em>.push (<em>MechanismStack</em>)</td></tr><tr><td class="colsep-0 align-left">&nbsp;<em>MechanismStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;<em>MoleculeStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>else</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;find direct mechanism, D<sub><em>m</em></sub>, forming <em>MoleculeStack</em>.top(), and not considered before</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>if</strong> found &amp; &amp; <em>MechanismStack</em>.size() + D<sub><em>m</em></sub>.size() ≤ MaxLength <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;  determine the stoichiometric factors, <em>ν</em><sub>1</sub> and <em>ν</em><sub>2</sub>, of <em>MechanismStack</em> and D<sub><em>m</em></sub> respectively</td></tr><tr><td class="colsep-0 align-left">&nbsp;  get the overall reaction O<sub><em>R</em></sub> of <em>MechanismStack</em> and D<sub><em>m</em></sub></td></tr><tr><td class="colsep-0 align-left">&nbsp;  find reactant M<sub>1</sub> ∈ <em>O</em><sub><em>R</em></sub> and ≠ any initial reactant</td></tr><tr><td class="colsep-0 align-left">&nbsp;  <strong>if</strong> found &amp; &amp; <em>MechanismStack</em>.NumberOfRxnCycles() ≤ MaxRxnCycles <strong>then</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;<em>MechanismStack</em>.push(D<sub><em>m</em></sub>)</td></tr><tr><td class="colsep-0 align-left">&nbsp;&nbsp;<em>MoleculeStack</em>.push(M<sub>1</sub>)</td></tr><tr><td class="colsep-0 align-left">&nbsp;<strong>else</strong></td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>MechanismStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left">&nbsp;  <em>MoleculeStack</em>.pop()</td></tr><tr><td class="colsep-0 align-left"><strong>return</strong> AllMechs satisfying M<sub><em>C</em></sub></td></tr></tbody></table></div></div></span></p></section></p><section id="sec0075"><h4 id="sect0090" class="u-margin-m-top u-margin-xs-bottom">4.2.1. Comparison with other mechanism identification algorithms</h4><p id="p0210">Algorithms for the construction of reaction mechanisms have been proposed, notably by <a name="bbib0095" href="#bib0095" class="workspace-trigger">Happel and Sellers (1982)</a>, <a name="bbib0200" href="#bib0200" class="workspace-trigger">Otarod and Happel (1992)</a>, <a name="bbib0190" href="#bib0190" class="workspace-trigger">Mavrovouniotis and Stephanopolous (1992)</a>, and <a name="bbib0185" href="#bib0185" class="workspace-trigger">Mavrovouniotis (1992)</a>. These algorithms construct <em>all</em> possible direct mechanisms from a given set of reactions. The underlying idea is to exhaustively consider all distinct combinations of reactions so that the set of reactions chosen have no net consumption/formation of reactive intermediates and is minimal in size, thus forming a direct mechanism. This is done, for example, in the case of the algorithm by <a name="bbib0190" href="#bib0190" class="workspace-trigger">Mavrovouniotis and Stephanopolous (1992)</a>, by finding all pairs of reactions for a reactive intermediate – one forming the reactive intermediate and another consuming it – and adding them together to get a new set of reactions without that intermediate. Subsequently, the reactions involving that reactive intermediate are replaced by this new set of reactions so that the intermediate is completely eliminated from the network. This procedure is done iteratively to obtain all direct mechanisms eventually.</p><p id="p0215">Our algorithm differs from these in several ways and, again, we provide only qualitative and descriptive comparison because the scope of the algorithms mentioned above are different from the ones proposed here. First, in RING, mechanisms – direct or overall – are sought for specified target molecules. That is, not all possible mechanisms are sought, only specific mechanisms that satisfy user-specified constraints are identified. This does not require the successive elimination of all intermediates, such as in the algorithm by <a name="bbib0190" href="#bib0190" class="workspace-trigger">Mavrovouniotis and Stephanopolous (1992)</a>; only those intermediates involved in the synthesis of the target molecules need to be eliminated. Second, algorithms mentioned above find only direct mechanisms; they, however, do not find the overall mechanism from initial reactants to final products. Third, our algorithm identifies empty cycles and eliminates them. The other algorithms mentioned above do not report a cycle detection and elimination method.</p><p id="p0220">Alternative mechanism identification methods involving constrained optimization have also been proposed (<a name="bbib0205" href="#bib0205" class="workspace-trigger">Planes &amp; Beasley, 2009</a>). These methods formulate an integer or mixed-integer linear programming problem to select reactions that taken together have no net consumption/production of reactive intermediates. Such algorithms offer the advantage of identifying a linearly independent set of overall mechanisms, for example, as in elementary modes and extreme pathways (<a name="bbib0140" href="#bib0140" class="workspace-trigger">Klamt &amp; Stelling, 2003</a>), or identifying alternative solutions (<a name="bbib0155" href="#bib0155" class="workspace-trigger">Lee, Phalakornkule, Domach, &amp; Grossmann, 2000</a>). These methods can also be used to identify cycles by setting that both reactants and products be net-zero. <a name="bbib0175" href="#bib0175" class="workspace-trigger">Marvin, Rangarajan, and Daoutidis (2013)</a> describe a method for identifying mechanisms that combines network generation using RING with constrained optimization algorithms. RING outputs the network in formats that can be exported into optimization software (specifically GAMS). The advantage of such a method is that in addition to identifying all mechanisms, they can be sorted or ranked according to any user-defined objective.</p></section></section><section id="sec0080"><h3 id="sect0095" class="u-h4 u-margin-m-top u-margin-xs-bottom">4.3. Lumping</h3><p id="p0225">The size of a complex reaction network can be reduced by lumping, or grouping, isomers. The reduced network can be more amenable to further analysis such as kinetic modeling. In RING, the process for identifying the lumps consists of three steps: (a) collation of molecules with the same number of different types of functional groups into one lump, or functional lumping, (b) assignment of a representative molecule to each lump based on user-input structural criteria for cyclic and acyclic species, and (c) further lumping of paraffins, olefins, naphthenes, hydrocarbon aromatics (PONA), or molecules satisfying user-defined properties based on molecular formula. Each of these steps is considered in detail below.</p><section id="sec0085"><h4 id="sect0100" class="u-margin-m-top u-margin-xs-bottom">4.3.1. Molecule collation</h4><div><p id="p0230">The first step in the process, if lumping is sought by the user, is to find and group all molecules that have the same number of each functional group. For example, 2-pentanol and 3-pentanol are lumped together because they both have two carbon atoms belonging to a methyl group (<strong>C</strong>H<sub>3</sub>), two methylene carbon atoms (<strong>C</strong>H<sub>2</sub>), and one carbon and oxygen of the <strong>C</strong>H<strong>O</strong>H group. <a name="bfig0030" href="#fig0030" class="workspace-trigger">Fig. 6</a>(a) shows collation of two groups of functionally equivalent molecules – secondary pentanols and xylenes. On the other hand, 1-pentanol is a separate lump because it has three methylene carbon atoms, one methyl carbon, and one carbon and oxygen atom of the <strong>C</strong>H<sub>2</sub><strong>O</strong>H group. It should be noted that functional groups have a specific combination of atoms and bonding. Thus, two molecules have exactly the same number of each functional group if there exists a mapping between each atom of one molecule and a unique atom in the other molecule. The mapping, in this case, is defined as possible when the two atoms are identical themselves and have identical nearest atoms and bonds. Thus, functional equivalence between two molecules can be established by keeping track of what kinds of atoms are present in the two. To do this, RING adopts a simplified hashing scheme.</p><figure class="figure text-xs" id="fig0030"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr6.jpg" height="315" alt="" aria-describedby="cap0030"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr6.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0030"><p id="spar0040"><span class="label">Fig. 6</span>. Three-step lumping process: (a) functional group-based equivalence is used to collate molecules, (b) a representative of each collated lump is identified, and (c) paraffins, olefins, naphthenes, and aromatics (PONA) lumps are further lumped based on molecular formula.</p></span></span></figure></div><p id="p0235">Hashing is a technique by which data objects can be referenced by a fixed-length object such as a bit-string. Within the context of molecular databases, <a name="bbib0365" href="#bib0365" class="workspace-trigger">Wipke, Krishnan, and Ouchi (1978)</a> and <a name="bbib0125" href="#bib0125" class="workspace-trigger">Ihlenfeldt and Gasteiger (1994)</a> used hashing predominantly for molecule indexing in databases and quick retrieval of molecular information. <a name="bbib0365" href="#bib0365" class="workspace-trigger">Wipke et al. (1978)</a> proposed and tested different hash functions generated by combining different parts of a canonical molecule name (SEMA) (<a name="bbib0360" href="#bib0360" class="workspace-trigger">Wipke &amp; Dyott, 1974</a>) through boolean operations such as XOR, to obtain different-sized (8, 9, or 10) bit-string hash values. These bit-strings, thereby, implicitly contain the structural and stereochemical information of the compound. <a name="bbib0125" href="#bib0125" class="workspace-trigger">Ihlenfeldt and Gasteiger (1994)</a>, on the other hand, use the complete molecular topology instead of only using the name for hashing. An atom hashing seed is first generated for each atom as the product of prime numbers corresponding to certain seed parameters. Subsequently, the atom hash is generated by combining the seed of each atom with its neighbors followed by equalization of bit distribution. The molecule hash is then obtained as a combination (logical XORs) of the atom hashes of the constituents. This procedure, thus, directly takes into account every atom and its neighboring environment and bonding in the molecule to generate a hash value. In RING, the hashing scheme exploits the properties of prime numbers and adapts ideas from <a name="bbib0125" href="#bib0125" class="workspace-trigger">Ihlenfeldt and Gasteiger (1994)</a> and <a name="bbib0365" href="#bib0365" class="workspace-trigger">Wipke et al. (1978)</a>, as discussed below. However, the use of molecule hashing in RING is different from that described above. In traditional hashing, hash functions are designed so as to minimize the chances of collision of hash values of different molecules. In contrast, the key requirements for lumping are that: (a) all molecules that are functionally equivalent – i.e., they have the same number of each type of functional group – <em>must</em> necessarily have the same hash value, and (b) collision between nonequivalent molecules should be <em>completely</em> avoided.</p><div><p id="p0240"><a name="benun0020" href="#enun0020" class="workspace-trigger">Algorithm 4</a> describes the algorithm for generating the hash value of molecules. The first step is the evaluation of atom hash seeds for each atom as the product of primes corresponding to various parameters such as the number of nearest non-hydrogen neighbors, element type of the atom (C, N, O, etc.), element type of the neighboring atoms, aromaticity, and bond orders of each bond connected to it (see supporting information). The final value of the seed is the product of each of these factors. For example, the hash seed of the tertiary carbon in 2-butanol is calculated as shown in <a name="bfig0035" href="#fig0035" class="workspace-trigger">Fig. 7</a>. The carbon atom has three neighboring atoms, hence the factor 2<sup>3</sup>, while the prime corresponding to carbon, prime(C), is cubed because the atom under consideration is carbon and it has two neighboring carbon atoms. Subsequently, each seed is assigned a prime number on-the-fly by RING during reaction network generation. This prime number constitutes the atom hash of that atom. It can be noted that two atoms of the same element having identical nearest neighbors have the same atom hash value. Thus, an atom hash value corresponds to a particular class/kind of atom, such as the tertiary carbon (Tert. C) shown in <a name="bfig0035" href="#fig0035" class="workspace-trigger">Fig. 7</a>. The molecule hash value is evaluated as the product of the atom hash values of each of the non-hydrogen atoms in the molecule (hydrogen atom hashes are, however, considered for purely hydrogenic species such as H+, H-, H· etc.). More information on the individual functions used in <a name="benun0020" href="#enun0020" class="workspace-trigger">Algorithm 4</a> is given in supporting information.</p><figure class="figure text-xs" id="fig0035"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr7.jpg" height="110" alt="" aria-describedby="cap0035"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr7.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0035"><p id="spar0045"><span class="label">Fig. 7</span>. An example of molecule hash value calculation. The steps are: (1) calculate hash seed of atom, (2) calculate hash of the atom using the hash seed, and (3) calculate molecule hash from the constituent atom hashes.</p></span></span></figure></div><p id="p0245"><section><p id="enun0020"><strong>Algorithm 4</strong></p><p id="p0250">(Integer, Integer) <strong>HashValue</strong> (Mol) <span class="display"><div class="tables frame-topbot colsep-0 rowsep-0" id="tbl0025"><div class="groups"><table class="align-center"><tbody><tr><td class="colsep-0">Hash ←1, ElectronicHash ←1</td></tr><tr><td class="colsep-0"><strong>for</strong> each non-Hydrogen atom a<sub><em>i</em></sub> of Mol <strong>do</strong></td></tr><tr><td class="colsep-0">&nbsp;AtomHash ←1</td></tr><tr><td class="colsep-0">&nbsp;<em>n</em>&nbsp;=&nbsp;# nearest neighbors of a<sub><em>i</em></sub></td></tr><tr><td class="colsep-0">&nbsp;AtomHashSeed = 2<sup><em>n</em></sup> × <strong>ElementPrimeValue</strong>(a<sub><em>i</em></sub>)</td></tr><tr><td class="colsep-0">&nbsp;<strong>if</strong> atom is aromatic <strong>then</strong></td></tr><tr><td class="colsep-0">&nbsp;  AtomHashSeed = AtomHashSeed ×3</td></tr><tr><td class="colsep-0">&nbsp;  ElectronicHash = ElectronicHash × <strong>AtomElectronicHash</strong>(a<sub><em>i</em></sub>)</td></tr><tr><td class="colsep-0">&nbsp;  <strong>for</strong> each neighbor, N, of a<sub><em>i</em></sub> <strong>do</strong></td></tr><tr><td class="colsep-0">&nbsp;&nbsp;AtomHashSeed = AtomHashSeed × <strong>ElementPrimeValue</strong>(N)<sup><em>bondorder</em></sup></td></tr><tr><td class="colsep-0">&nbsp;AtomHash = <strong>AtomPrimeValue</strong>(AtomHashSeed)</td></tr><tr><td class="colsep-0">Hash = Hash × AtomHash</td></tr><tr><td class="colsep-0"><strong>return</strong> (Hash, ElectronicHash)</td></tr></tbody></table></div></div></span></p></section></p><p id="p0255">An additional hash value accounting for the electronic configuration of the atoms of the molecule is also evaluated. For each atom not in its elemental ground-state electronic configuration, the product of its atom hash and a prime number corresponding to the electronic nature of the atom (magnitude of charge and presence/absence of unpaired electrons) is evaluated as an electron hash of the atom. The electronic hash of the molecule is the product of the electron hash values of the non-ground-state atoms. The molecule electronic hash of a neutral and stable molecule, such as 2-butanol, is 1 by definition. The hash value of the molecule is, hence, the integer pair of the molecule hash value and molecule electronic hash.</p><p id="p0260">The atom hash seed, being a product of primes, takes a unique value that can be obtained only by the specific combination of the identity of the atom, its neighbors, and the orders of the included bonds. This implies that the atom hash values, which are assigned prime numbers based on their hash values, are unique. The atom hash implicitly takes into account the associated functional group information the atom is a part of; therefore, the product of atom hashes leads to a hash value that is unique to the set of functional groups in the molecule. Thus, two molecules having the same set of functional groups will have the same hash values.</p><p id="p0265">The hashing technique for functional equivalence using an integer pair, calculated as products of prime numbers, is atypical when compared to the bit-strings-based hashing functions discussed in <a name="bbib0125" href="#bib0125" class="workspace-trigger">Ihlenfeldt and Gasteiger (1994)</a>. However, the utility of hash values in RING is similar to that of the bit-string technique as they both provide distinct identification for quick retrieval of molecular information. The hash value is implemented as a pair of unsigned integers in RING; there is, therefore, a finite possibility that hash values become large enough to cause a numerical overflow. The hash values can, in such a case, wrap to result in a different number, and thereby potentially lead to collisions. However, this is resolved by comparing the sizes of the two colliding molecules which will necessarily be different.</p></section><section id="sec0090"><h4 id="sect0105" class="u-margin-m-top u-margin-xs-bottom">4.3.2. Identifying a representative molecule</h4><p id="p0270">The representative molecule of functionally equivalent lumps is determined on the basis of user-defined criteria. Specifically: (a) the representative molecule of acyclic species lumps can have leaves (the end atoms of the molecule) closest to (or farthest apart from) each other, and (b) the representative molecule of lumps of cyclic species can have branches farthest apart from (or closest to) each other. <a name="bfig0030" href="#fig0030" class="workspace-trigger">Fig. 6</a>(b) shows that 3-pentanol and p-xylene are chosen as the representative molecule based on leaves and, hence, branches being farthest apart. Alternatively, the molecule with branch ends (or leaves) closest to each other could be set as the representative. In such a case, for example, o-xylene will be the lump representative of xylenes.</p></section><section id="sec0095"><h4 id="sect0110" class="u-margin-m-top u-margin-xs-bottom">4.3.3. Additional lumping</h4><p id="p0275">The lumps identified through functional lumping can be collapsed further to form fewer groups. At this stage, the lumping is according to the number of heavy and hydrogen atoms in the molecule. These molecule constituents should satisfy certain molecular characteristics set by the user. RING implements the additional lumping by sifting through each lump, determining each time if the lump representative matches the characteristics specified for additional lumping and then accordingly groups together the lumps to get the new set of lumps. There are four pre-specified classes for lumping hydrocarbons – paraffins, olefins, naphthenes, hydrocarbon aromatics, and their reactive intermediates. The user has a choice to represent this lump by the constituent having the most/least number of branches. <a name="bfig0030" href="#fig0030" class="workspace-trigger">Fig. 6</a>(c) shows an example where paraffins and aromatics are both lumped to most branched molecules. Alternatively, either or both of them could have been lumped to the least branched of the constituents.</p><p id="p0280">In addition to these pre-specified classes, there can be additional user-defined classes. The user can specify molecular characteristics involving size, shape, and/or presence/absence of a specified frequency of functional groups that describes the desired class of molecules and then further specify the representative nature (most/least branched). For example, surface alkoxide intermediates in solid Brønsted acid catalysis can be lumped using this method. Further, n- and iso-alcohols lumped separately by the functional lumping scheme can be further lumped together using this strategy.</p></section><section id="sec0100"><h4 id="sect0115" class="u-margin-m-top u-margin-xs-bottom">4.3.4. Comparison with other lumping methods</h4><p id="p0285">Methods to lump a reaction network fall into two broad categories: (a) mathematical lumping based on kinetics, and (b) chemical functionality-based lumping. Mathematical lumping methods (<a name="bbib0050" href="#bib0050" class="workspace-trigger">Coxson and Bischoff, 1987</a>, <a name="bbib0150" href="#bib0150" class="workspace-trigger">Kuo and Wei, 1969</a>, <a name="bbib0160" href="#bib0160" class="workspace-trigger">Li and Rabitz, 1989</a>) identify a lumping matrix “M” that groups one or more species so that the resultant model results are as close to the original. The constituents of such groups may or may not have physical meaning (<a name="bbib0115" href="#bib0115" class="workspace-trigger">Ho, 2008</a>). Chemical functionality-based lumping methods, on the other hand, group together molecules that have similar set of functional groups. These lumps have similar chemical and physical properties in addition to being related through several reactions in the network. RING's lumping scheme falls under this second category and we compare our algorithm with other similar methods.</p><p id="p0290">The vector-based representation of structure-oriented lumping (SOL) (<a name="bbib0225" href="#bib0225" class="workspace-trigger">Quann &amp; Jaffe, 1992</a>) offers a natural framework for lumping structural isomers that have the same set and number of different functional groups but have a different order or position of these groups in the molecule. However, molecules can only be represented as lumps and it is not always possible to get the structure of the individual molecules that constitute the lump from the vector. Further, the vector that stores the structural representation is fixed and pre-assigned. For each new chemistry, therefore, the internal representation vector must be expanded to appropriately account for new functional groups. RING offers the feature of SOL – functional groups-based lumping – through the functional lumping feature but is more generic as it is chemistry-independent and identifies and tracks functional groups dynamically. The software RDL++ (<a name="bbib0120" href="#bib0120" class="workspace-trigger">Hsu et al., 2008</a>) performs lumping of hydrocarbon isomers on the basis of molecular formula as a post-processing step. This method is not applicable for lumping oxygenates because even linear molecules with different functional groups can have the same molecular formula; for example, dimethyl ether and ethanol are both of the form C<sub>2</sub>H<sub>6</sub>O, even though they have different functional groups. The lumping technique in RING can distinguish these two molecules; however, provisions also exist to allow lumping of molecules based on the molecular formula for user-specified categories of molecules (such as paraffins, naphthenics, surface alkoxide intermediates, etc.).</p></section><section id="sec0105"><h4 id="sect0120" class="u-margin-m-top u-margin-xs-bottom">4.3.5. Lumped network</h4><p id="p0295">Once molecules are grouped together to their respective lumps, the reactions of the network can be lumped as well, on the basis of the lumps of the reactants and the products. A lumped reaction, then, is one wherein the reactants and products are represented by their respective lumps. A lumped network, consequently, is the network of lumped reactions. Several reactions, of a given reaction rule, can collapse to the same lumped reaction. The size of the lumped network, therefore, is significantly smaller compared to that of the parent network. This “reduced” network, in principle, contains distinct reactions of the different groups of molecules of the network.</p></section></section><section id="sec0110"><h3 id="sect0125" class="u-h4 u-margin-m-top u-margin-xs-bottom">4.4. Molecule and reaction queries</h3><p id="p0300">RING also allows querying for molecules and reactions. Such queries are implicitly part of the pathways and mechanism identification – for example, a query for a molecule is the first step (<a name="bfig0025" href="#fig0025" class="workspace-trigger">Fig. 5</a>) – but can also be sought independently. Molecule queries are input in the form of seeking all molecules that satisfy specified molecular constraints. Reaction queries, on the other hand, are input as reaction constraints by specifying the rule, reactant, product, or any combination of these.</p></section></section><section id="sec0115"><h2 id="sect0130" class="u-h3 u-margin-l-top u-margin-xs-bottom">5. Thermochemistry estimation</h2><p id="p0305">RING allows for estimating thermochemistry of species in the network through the group contribution methodology (<a name="bbib0015" href="#bib0015" class="workspace-trigger">Benson, 1976</a>). Specifically, RING provides two options for specifying the group additivity information. First, groups and their contributions to enthalpy, entropy, and specific heat capacity at different temperatures be specified. Second, corrections can be specified by defining fragments and their correction contributions. These corrections can account for non-nearest neighbor effects such as gauche or 1,5 interactions.</p><div><p id="p0310">The user specifies the groups and their contributions as shown in <a name="bfig0040" href="#fig0040" class="workspace-trigger">Fig. 8</a>. The first atom in the group additivity fragment is the central atom while the others are neighboring atoms. This is in accordance with Benson's definition of groups. No such differentiation is necessary for group corrections. The term “gasPhaseSpecies” is a characteristic defined by the user to describe molecules that are in the gas phase (and not surface bound). Including this characteristic will result in the fragment correction should being applied only if the molecule is gaseous. RING compiles the additivity inputs into multiple sets of group additivity specifications classified according to the first (or central) atomtype (C, O, C+, C, etc.). For each set of group fragments, a hash value pair, say (h1,h2), is calculated for the fragments similar to that in lumping. The first value of the hash pair, h1, takes into consideration the central atom and immediate neighbor information, while the second value, h2, takes into consideration the electronic configuration of the central and neighboring atoms. While most of Benson's groups only consider nearest neighbors, some groups have additional information about atoms twice-removed from the central atom; specifically, in cases of groups where neighboring carbon atoms are involved in C–C or C–O double bonds, the specific atoms are written as ‘Cd’ or ‘CO’ and are differentiated from the regular carbon atom. Note that a group such as C(C)(H)(H)(H) as defined in <a name="bfig0040" href="#fig0040" class="workspace-trigger">Fig. 8</a> is contained in C(Cd)(H)(H)(H). That is, if an atom matches the latter fragment, it will match the first as well. Therefore, any group additivity method needs to check the second fragment before it checks for the first fragment. Similarly, a group such as C(Cd)(Cd)C(H) needs to be checked prior to C(Cd)(C)(C)(H) which in turn needs to be checked prior to checking for C(C)(C)(C)(H). To distinguish neighboring C atoms from ‘Cd’ or ‘CO’, the hash value h2 that RING calculates is appropriately modified to reflect the number of double bonds of the neighboring atoms.</p><figure class="figure text-xs" id="fig0040"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr8.jpg" height="286" alt="" aria-describedby="cap0040"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr8.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0040"><p id="spar0050"><span class="label">Fig. 8</span>. Sample group additivity and corrections specification for thermochemistry estimation in RING.</p></span></span></figure></div><p id="p0315">When a thermochemistry value (enthalpy, entropy, or specific heat capacity) for a molecule has to be predicted, RING loops over all the atoms in the molecule to determine their contributions and adds them up. Specifically, for each atom, RING determines its atomtype, calculates the hash pair, and checks if the appropriate set of group fragments has a member with the same hash pair value. Note that the hash pair value of the atom takes into account any double bonds of the neighboring atoms. If a group with the atom's hash pair value is not found, then the hash value h2 is recalculated assuming one less double bond to check if the new hash pair has some matching group. This will be repeated successively, until h2 does not take into account any double bonds, at which point if no matching groups are available, RING will throw an error. This procedure ensures that a group with more information (in terms of having ‘Cd’ or ‘CO’ over just C) is checked prior to checking for groups with less information (and hence a more generic group). When a matching group is identified, RING checks for matches of the group in the entire molecule. For each match, RING identifies the corresponding central atom (the atom that matches the central atom of the group), finds if the atom's hash pair equals the original value of (h1,h2), accounts for the contribution of those atoms, and removes the atoms from further consideration.</p><p id="p0320">Once RING calculates the contributions of each additive group, corrections are calculated and added by going over each user-defined correction fragment and checking for matches in the molecule. For each distinct match, an appropriate correction is added. The final value is then the molecule thermochemical property value. If specific heat capacity values (cp) are available at different temperatures as shown in <a name="bfig0040" href="#fig0040" class="workspace-trigger">Fig. 8</a>, enthalpy and entropy at any temperature can be calculated. For this purpose, cp is calculated using linear interpolation; for example, cp at 450 K is calculated as an average of cp values at 400 and 500 K.</p><p id="p0325">This group contribution scheme has been used to calculate the thermochemical properties of gaseous phase stable and radical species, surface alkoxides arising in Brønsted heterogeneous catalysis, and surface intermediates in metal catalysis. The twin features of additivity and corrections enables defining non-standard Benson-like methods, such as for calculating thermochemistry of surface intermediates on metals (<a name="bbib0290" href="#bib0290" class="workspace-trigger">Salciccioli, Edie, &amp; Vlachos, 2012</a>). For example, <a name="bbib0290" href="#bib0290" class="workspace-trigger">Salciccioli et al. (2012)</a> distinguish CH<sub>2</sub> groups depending on whether the molecule is gaseous or surface intermediate. This can be handled by first defining the group in the additivity scheme as that for gaseous species and then adding a correction for the group applicable only for surface species (by an appropriately defined characteristic by the user) that is equal to the difference between the surface value and the gas phase value. This method has also been used to calculate thermochemistry of surface intermediates on one metal with that on another reference metal (<a name="bbib0250" href="#bib0250" class="workspace-trigger">Rangarajan, Brydon, Bhan, &amp; Daoutidis, 2014</a>) using linear scaling corrections proposed by Nørskov and coworkers (<a name="bbib0005" href="#bib0005" class="workspace-trigger">Abild-Pedersen et al., 2007</a>) and to calculate octanol–water partition coefficients (<a name="bbib0235" href="#bib0235" class="workspace-trigger">Rangarajan, Bhan, &amp; Daoutidis, 2012a</a>) using atom contribution methods (<a name="bbib0355" href="#bib0355" class="workspace-trigger">Wildman &amp; Crippen, 1999</a>), thereby indicating its generality.</p><section id="sec0120"><h3 id="sect0135" class="u-h4 u-margin-m-top u-margin-xs-bottom">5.1. Symmetry corrections</h3><p id="p0330">Benson's method also includes a configurational entropy correction term corresponding to the total symmetry number of the molecule. The total symmetry number is calculated in RING based on molecular graph automorphism orbits. The number of automorphic graphs are calculated using the algorithm proposed by <a name="bbib0020" href="#bib0020" class="workspace-trigger">Bohanec and Perdih (1993)</a>. Several corrections, however, are included because 3D molecular symmetry transformations are not directly obtained from 2D topological symmetry. Specifically, we include: (a) corrections to capture the symmetry number corresponding to the sp<sup>3</sup> C with two sets of topologically equivalent neighbors (as in group C(B1)<sub>2</sub>(B2)<sub>2</sub> in <a name="bbib0195" href="#bib0195" class="workspace-trigger">Muller, Scacchi, and Cme (1991)</a>), (b) reduction in symmetry in spiro compounds as noted by <a name="bbib0340" href="#bib0340" class="workspace-trigger">Walters and Yalkowsky (1996)</a>, and (c) reduction in internal symmetry number in the case of extended double bond sequence (based on the tabulation of <a name="bbib0300" href="#bib0300" class="workspace-trigger">Song (2004)</a>). It should be noted that these corrections are currently included only for species that are interpreted by RING to not be surface intermediates. It is common to calculate translational and rotational entropic contributions of heterogeneous surface intermediates from frustrated vibrational frequencies (<a name="bbib0080" href="#bib0080" class="workspace-trigger">Gokhale, Kandoi, Greeley, Mavrikakis, &amp; Dumesic, 2004</a>). Benson's method also requires the calculation of number of optical isomers, for which, RING adopts the methodology to calculate the number of enantiomers and meso compounds using the algorithm proposed by <a name="bbib0260" href="#bib0260" class="workspace-trigger">Razinger, Balasubramanian, Perdih, and Munk (1993)</a>.</p></section></section><section id="sec0125"><h2 id="sect0140" class="u-h3 u-margin-l-top u-margin-xs-bottom">6. Kinetic modeling</h2><div><p id="p0335">Kinetic modeling allows for obtaining quantitative insights, as opposed to qualitative topological network analysis results, by providing information on concentration, yield, and selectivity of each species at different stages (or at different times) in the reactor, sensitivity of outputs to kinetic parameters, and rate determining steps. RING calls the open source software IDAS (<a name="bbib0110" href="#bib0110" class="workspace-trigger">Hindmarsh et al., 2005</a>) to solve a differential-algebraic system representing the kinetic model of the complex system assuming each reaction is elementary and follows mass action kinetics. The user has to specify rules to calculate kinetic parameters. <a name="bfig0045" href="#fig0045" class="workspace-trigger">Fig. 9</a> shows how rules to calculate the kinetics of a particular reaction rule are written in RING in context of an example rule, viz., hydrogen abstraction. Conditional “if” statements can be written to assign different kinetic parameters depending on the nature of reactants and/or products. For example, in <a name="bfig0045" href="#fig0045" class="workspace-trigger">Fig. 9</a>, the rule specifies that if “r1”, which represents a reactant in the rule “Habstraction” as defined by the user while specifying reaction rules, is a methyl radical ([C.]), then assign kinetics on the basis of the nature of the product. The word “primaryRadical” is a molecule characteristic defined by the user to represent primary radicals. The rule, therefore, goes on to specify that if the product is a primary radical, use a particular value (in line 3) for pre exponential factor, activation barrier, and n (temperature exponent); otherwise use another value (given in line 4). If “r1” is not methyl, the values in line 5 are used. This scheme for kinetics specification allows for adding more rules to refine the estimation of kinetics. In addition, activation barriers can also be specified using linear free energy relationships such as the Brønsted-Evans-Polanyi relationships which estimate the barriers as a linear function of the enthalpy of the reaction (<a name="bbib0035" href="#bib0035" class="workspace-trigger">Brønsted, 1928</a>). Thermodynamic consistency can be forced by the user by specifying that the specific kinetics be calculated from the kinetics of the reverse step. For example, lines 6 and 7 in <a name="bfig0045" href="#fig0045" class="workspace-trigger">Fig. 9</a> define the kinetics of C–C scission step to be the reverse of that of C–C formation step.</p><figure class="figure text-xs" id="fig0045"><span><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr9.jpg" height="123" alt="" aria-describedby="cap0045"><ol class="links-for-figure"><li><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-gr9.jpg" target="_blank" download="" title="Download full-size image"><span class="anchor-text">Download : <span class="download-link-title">Download full-size image</span></span></a></li></ol></span><span class="captions"><span id="cap0045"><p id="spar0055"><span class="label">Fig. 9</span>. Sample rule inputs into RING for the estimation of kinetic parameters.</p></span></span></figure></div><p id="p0340">The user specifies reactor parameters – pressure, temperature, volume, and inlet flow rates of reactants – and RING solves for an isothermal steady state plug flow reactor PFR. Outputs are flow rate, <em>F</em><sub><em>i</em></sub>, of different species in the network at different stages of the reactor, sensitivity of species flow rates to kinetic rate constants (<em>dF</em><sub><em>i</em></sub>/<em>dk</em><sub><em>j</em></sub>), and degree of rate control or DORC (<a name="bbib0040" href="#bib0040" class="workspace-trigger">Campbell, 1994</a>). DORC is defined as <span class="math"><span class="MathJax_Preview" style=""></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub is=&quot;true&quot;><mrow is=&quot;true&quot;><mo stretchy=&quot;false&quot; is=&quot;true&quot;>(</mo><mrow is=&quot;true&quot;><mi is=&quot;true&quot;>d</mi><mo is=&quot;true&quot;>ln</mo><msub is=&quot;true&quot;><mi is=&quot;true&quot;>r</mi><mi is=&quot;true&quot;>i</mi></msub></mrow><mo is=&quot;true&quot;>/</mo><mrow is=&quot;true&quot;><mi is=&quot;true&quot;>d</mi><mo is=&quot;true&quot;>ln</mo><msub is=&quot;true&quot;><mi is=&quot;true&quot;>k</mi><mi is=&quot;true&quot;>j</mi></msub></mrow><mo stretchy=&quot;false&quot; is=&quot;true&quot;>)</mo></mrow><mrow is=&quot;true&quot;><msub is=&quot;true&quot;><mi is=&quot;true&quot;>k</mi><mi is=&quot;true&quot;>j</mi></msub><mo is=&quot;true&quot;>&amp;#x2260;</mo><msub is=&quot;true&quot;><mi is=&quot;true&quot;>k</mi><mi is=&quot;true&quot;>l</mi></msub><mo is=&quot;true&quot;>,</mo><msub is=&quot;true&quot;><mi is=&quot;true&quot;>K</mi><mi is=&quot;true&quot;>j</mi></msub></mrow></msub></math>" role="presentation" style="font-size: 90%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="21.674ex" height="3.445ex" viewBox="0 -847.3 9331.6 1483.2" role="img" focusable="false" style="vertical-align: -1.477ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g is="true"><g is="true"><g is="true"><use xlink:href="#MJMAIN-28"></use></g><g is="true" transform="translate(389,0)"><g is="true"><use xlink:href="#MJMATHI-64"></use></g><g is="true" transform="translate(690,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6E" x="278" y="0"></use></g><g is="true" transform="translate(1691,0)"><g is="true"><use xlink:href="#MJMATHI-72"></use></g><g is="true" transform="translate(451,-150)"><use transform="scale(0.707)" xlink:href="#MJMATHI-69"></use></g></g></g><g is="true" transform="translate(2877,0)"><use xlink:href="#MJMAIN-2F"></use></g><g is="true" transform="translate(3377,0)"><g is="true"><use xlink:href="#MJMATHI-64"></use></g><g is="true" transform="translate(690,0)"><use xlink:href="#MJMAIN-6C"></use><use xlink:href="#MJMAIN-6E" x="278" y="0"></use></g><g is="true" transform="translate(1691,0)"><g is="true"><use xlink:href="#MJMATHI-6B"></use></g><g is="true" transform="translate(521,-150)"><use transform="scale(0.707)" xlink:href="#MJMATHI-6A"></use></g></g></g><g is="true" transform="translate(5982,0)"><use xlink:href="#MJMAIN-29"></use></g></g><g is="true" transform="translate(6372,-331)"><g is="true"><g is="true"><use transform="scale(0.707)" xlink:href="#MJMATHI-6B"></use></g><g is="true" transform="translate(368,-107)"><use transform="scale(0.5)" xlink:href="#MJMATHI-6A"></use></g></g><g is="true" transform="translate(645,0)"><use transform="scale(0.707)" xlink:href="#MJMAIN-2260"></use></g><g is="true" transform="translate(1196,0)"><g is="true"><use transform="scale(0.707)" xlink:href="#MJMATHI-6B"></use></g><g is="true" transform="translate(368,-107)"><use transform="scale(0.5)" xlink:href="#MJMATHI-6C"></use></g></g><g is="true" transform="translate(1784,0)"><use transform="scale(0.707)" xlink:href="#MJMAIN-2C"></use></g><g is="true" transform="translate(1981,0)"><g is="true"><use transform="scale(0.707)" xlink:href="#MJMATHI-4B"></use></g><g is="true" transform="translate(600,-107)"><use transform="scale(0.5)" xlink:href="#MJMATHI-6A"></use></g></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub is="true"><mrow is="true"><mo stretchy="false" is="true">(</mo><mrow is="true"><mi is="true">d</mi><mo is="true">ln</mo><msub is="true"><mi is="true">r</mi><mi is="true">i</mi></msub></mrow><mo is="true">/</mo><mrow is="true"><mi is="true">d</mi><mo is="true">ln</mo><msub is="true"><mi is="true">k</mi><mi is="true">j</mi></msub></mrow><mo stretchy="false" is="true">)</mo></mrow><mrow is="true"><msub is="true"><mi is="true">k</mi><mi is="true">j</mi></msub><mo is="true">≠</mo><msub is="true"><mi is="true">k</mi><mi is="true">l</mi></msub><mo is="true">,</mo><msub is="true"><mi is="true">K</mi><mi is="true">j</mi></msub></mrow></msub></math></span></span><script type="math/mml" id="MathJax-Element-1"><math><msub is="true"><mrow is="true"><mo stretchy="false" is="true">(</mo><mrow is="true"><mi is="true">d</mi><mo is="true">ln</mo><msub is="true"><mi is="true">r</mi><mi is="true">i</mi></msub></mrow><mo is="true">/</mo><mrow is="true"><mi is="true">d</mi><mo is="true">ln</mo><msub is="true"><mi is="true">k</mi><mi is="true">j</mi></msub></mrow><mo stretchy="false" is="true">)</mo></mrow><mrow is="true"><msub is="true"><mi is="true">k</mi><mi is="true">j</mi></msub><mo is="true">≠</mo><msub is="true"><mi is="true">k</mi><mi is="true">l</mi></msub><mo is="true">,</mo><msub is="true"><mi is="true">K</mi><mi is="true">j</mi></msub></mrow></msub></math></script></span> wherein <em>r</em><sub><em>i</em></sub> and <em>k</em><sub><em>j</em></sub> are the rate of production/consumption of species <em>i</em> and the rate constant of reaction <em>j</em> respectively; this value is calculated assuming all other rate constants <em>k</em><sub><em>l</em></sub> are fixed except the reverse reaction whose kinetics is determined by <em>K</em><sub><em>j</em></sub>, the equilibrium constant, which is also fixed. An example of kinetic modeling of nonane pyrolysis with RING is discussed in the supporting information.</p><p id="p0345">The kinetic modeling module in RING is comparable to other network generators. RING offers the capability of modeling both homogeneous and heterogeneous chemistries. To formulate and solve kinetic models relevant for heterogeneous catalysis, RING invokes the quasi-steady state assumption (QSSA) for surface intermediates and solves the resultant differential-algebraic system of equations that takes into account a site balance for conserving the total number of surface sites. Consistent initial conditions are required to solve such systems, and assuming that initially all surface sites are free leads to inconsistencies because QSSA of other surface species will not hold. RING uses the consistent initial conditions calculation feature of IDAS (<a name="bbib0110" href="#bib0110" class="workspace-trigger">Hindmarsh et al., 2005</a>) to calculate the initial concentrations on the surface species. However, one limitation arises in solving systems such as metal catalysis – the equations corresponding to QSSA are nonlinear with the possibility of multiple solutions. A more robust method to obtain the correct initial conditions is therefore currently being pursued. Tools such as RMG (<a name="bbib0300" href="#bib0300" class="workspace-trigger">Song, 2004</a>, <a name="bbib0315" href="#bib0315" class="workspace-trigger">Van Geem et al., 2006</a>) offers apriori estimation of kinetic parameters (<a name="bbib0305" href="#bib0305" class="workspace-trigger">Sumathi &amp; Green, 2002</a>) taking into account pressure dependence for gas phase homogeneous chemistries (<a name="bbib0180" href="#bib0180" class="workspace-trigger">Matheu, Green, &amp; Grenda, 2003</a>). Semi-empirical estimation of Arrhenius parameters has been proposed especially for free radical chemistry. This includes: (a) group additivity schemes that can be used to estimate kinetic parameters based on the atoms in the reaction centers and their neighborhood for each reaction rule (<a name="bbib0090" href="#bib0090" class="workspace-trigger">Green, 2007</a>, <a name="bbib0280" href="#bib0280" class="workspace-trigger">Sabbe et al., 2007</a>, <a name="bbib0270" href="#bib0270" class="workspace-trigger">Sabbe et al., 2008</a>, <a name="bbib0275" href="#bib0275" class="workspace-trigger">Sabbe et al., 2010</a>, <a name="bbib0285" href="#bib0285" class="workspace-trigger">Saeys et al., 2006</a>, <a name="bbib0350" href="#bib0350" class="workspace-trigger">West and Allen, 2011</a>) and (b) pre-defined elaborate rule-based kinetics assignment scheme (<a name="bbib0045" href="#bib0045" class="workspace-trigger">Carstensen &amp; Dean, 2009</a>). Both these methods are derived from high-level quantum chemical calculations. These features reduce the dependence on the quality of user-inputs for kinetic modeling. However, such schemes have so far been extensively documented only for gas phase free radical chemistry rules and are not universally used or available across other chemistries. RING provides the option of user specification of kinetics which can accommodate both schemes.</p><p id="p0350">NETGEN (<a name="bbib0030" href="#bib0030" class="workspace-trigger">Broadbelt et al., 1994</a>) and RMG (<a name="bbib0300" href="#bib0300" class="workspace-trigger">Song, 2004</a>, <a name="bbib0315" href="#bib0315" class="workspace-trigger">Van Geem et al., 2006</a>) also employ rate-based construction of reaction networks. This method combines network generation and kinetic modeling whereby species and corresponding reactions are added only when their rates are larger than a threshold value; once a new reaction and species are added, the integration of the model is re-started. This method has been demonstrated to significantly reduce the size of the reaction mechanism. RING does not currently have rate-based construction. However, we have demonstrated using RING that the size of the reaction of complex systems such as alkane aromatization on solid Brønsted acid catalysts can be pruned down significantly (up to two or three orders of magnitude) by (a) imposing constraints in reaction rules based on inputs from computational chemistry studies, and (b) lumping molecules that are not experimentally distinguished (<a name="bbib0240" href="#bib0240" class="workspace-trigger">Rangarajan, Bhan, &amp; Daoutidis, 2012b</a>).</p></section><section id="sec0130"><h2 id="sect0145" class="u-h3 u-margin-l-top u-margin-xs-bottom">7. Discussion</h2><p id="p0355">Several salient and distinctive characteristics of RING can be noted. RING has been demonstrated to be versatile for network generation and querying a broad spectrum of chemistries, such as gas phase free radical, liquid phase acid/base catalyzed, and heterogeneous solid acid/base/metal catalyzed chemistries (<a name="bbib0230" href="#bib0230" class="workspace-trigger">Rangarajan et al., 2010</a>). Several options are provided to the users such as (a) constraints on reaction rules, (b) query features, (c) lumping strategies, (d) group additivity-based thermochemistry calculations, and (e) kinetic modeling. These options, further, have a common underlying theme – they are all rule-based. For example, the chemistry is specified through reaction rules, pathway queries in the form of rules to identify molecules and particular type of pathways, and kinetic parameters are specified in the form of rules involving conditional statements. This rule-based feature enables translating expert knowledge into specific instructions, thereby lending the tool flexibility. The domain-specific language used as input to RING provides a high-level, declarative language for describing chemistries to the system. This allows the inputs to be described as conceived rather than translating them into abstractions in general purpose programming languages, and further offers features such as error-checking and optimizations.</p><p id="p0360">DSLs, however, also have several general disadvantages (<a name="bbib0060" href="#bib0060" class="workspace-trigger">van Deursen et al., 2000</a>). In particular, one of the biggest is balancing between domain-specific and general purpose language features – offer too few general-purpose language features and the DSL's applicability is very constrained and limited, but offer too many and the DSL turns into just another general purpose language. The language extension model offers a solution to these problems. Instead of needing to design the core reaction rule specification language to handle any possible future development – something that would necessitate many general purpose language features – instead, the core of the language can be kept declarative and simple, intended only to describe the chemistry. Adapting the language to serve new purposes and provide new analyses can instead be accomplished through language extension. While RING already comes with several extensions – molecule, reaction, pathways and mechanisms queries, and kinetic modeling – new modules can be added. Each of these new features can be developed independently as separate extensions that end-users can compose with the RING compiler automatically using Silver, resulting in a language and compiler tailored to their needs.</p><p id="p0365">RING can be used to model and analyze a variety of biomass and hydrocarbon processing systems including homogeneous and heterogeneous chemistries. If only general chemistry of the system is known, topological network analysis can be performed using RING to identify possible pathways and products prior to experimentation, or to identify plausible pathways to experimentally observed products that is consistent other experimental observations. For example, we showed that glycerol dehydration to acrolein on Brønsted acid catalysts necessarily involves 3-hydroxypropanal, consistent with experimental observations that it was a primary product which was observed at low conversions only (<a name="bbib0240" href="#bib0240" class="workspace-trigger">Rangarajan et al., 2012b</a>). Further, RING could also be used for mechanism hypothesis and for proposing experiments to discriminate multiple candidate mechanisms. For example, for acetone conversion on Brønsted acid catalysts, we identified among several possible mechanisms one plausible route that was able to match the experimental inference of overall stoichiometric reaction through which two molecules of acetone got converted into one molecule each of acetic acid and isobutene. Based on this pathway, we could propose experiments such as isotope labeling studies that could confirm our predictions (<a name="bbib0240" href="#bib0240" class="workspace-trigger">Rangarajan et al., 2012b</a>). In addition to an understanding of the chemistry, if it is possible to determine the energetics (activation barrier and thermochemistry) for each reaction step, then plausible energetically feasible mechanisms can be identified using RING. For example, we have used RING to identify plausible mechanisms for glycerol decomposition and hydrogenolysis to form syn gas or 1,2 propane diol respectively, by using RING's pathway identification features along with semi-empirical estimation of thermochemistry (using group additivity) and activation barriers (using linear free energy relationships) given in the literature (<a name="bbib0250" href="#bib0250" class="workspace-trigger">Rangarajan et al., 2014</a>). As a parallel concept within the context of chemical synthesis, RING was used to identify synthetically feasible fatty alcohols from biomass derived oxygenates using heterogeneous catalysis that have potential application in developing nonionic surfactants (<a name="bbib0235" href="#bib0235" class="workspace-trigger">Rangarajan et al., 2012a</a>). Networks generated by RING have also been embedded into mixed-integer linear programming problems to simultaneously identify desirable compounds and their optimal synthesis routes in terms of economic, energetic, and reaction rate objectives (<a name="bbib0175" href="#bib0175" class="workspace-trigger">Marvin et al., 2013</a>) Finally, if kinetic parameters can be estimated for each reaction step apriori, RING could be used to formulate and solve kinetic models so that quantitative results such as yields, selectivity, rate determining steps, and dominant reactions can be identified.</p></section><section id="sec0135"><h2 id="sect0150" class="u-h3 u-margin-l-top u-margin-xs-bottom">8. Conclusion</h2><p id="p0370">The algorithm and implementation details of RING, a rule-based reaction network generation and analysis tool, are discussed. RING takes in as input the initial reactants and reaction rules, written as instructions in an English-like reaction language, and generates as output the reaction network in the form of reactions and species lists. In addition, post-processing modules allow: (a) lumping functionally equivalent structural isomers to reduce size of the network, (b) querying the network for specific molecules, reactions, pathways, and mechanisms, (c) estimating thermochemical properties of species and reactions in the network, and (d) kinetic modeling. Algorithms and methods from computer science, graph theory, and cheminformatics have been adapted and implemented to (a) develop a domain specific reaction language compiler that acts as a user-interface for RING, (b) represent molecules externally as strings based on SMILES, (c) represent molecules internally as molecular graphs and reactions and graph transformation, (d) match patterns of fragments in molecular graphs, (e) identify pathways and mechanisms as a modified depth-first traversal, and (f) identify lumps and groups in a group additivity scheme using a modified hashing technique. The reaction language provides chemistry-specific syntax, catches semantic inconsistencies in the form of erroneous chemistry rules, and performs problem-specific optimizations to speed up the processing of reaction rules. RING has been applied to construct and analyze a wide variety of chemistries such as homogeneous free radical and acid/base chemistry, and heterogeneous acid, base, or metal catalyzed transformations. RING is available open source (<a name="bbib0265" href="#bib0265" class="workspace-trigger">RING, 2013</a>).</p></section></div><section id="ack0005"><h2 id="sect0155" class="u-h3 u-margin-l-top u-margin-xs-bottom">Acknowledgements</h2><p id="p0375">Financial support from the <span id="gs0005">National Science Foundation</span> (CBET <a href="#gs0005"># 1307089</a>, IIS grant <a href="#gs0005"># 0905581</a>) and from the <span id="gs0010">University of Minnesota Digital Technology Center</span> is gratefully acknowledged. The authors also acknowledge partial support from the <span id="gs0015">Initiative for Renewable Energy</span> (Large Grant: <a href="#gs0015">RL-0004-09</a>), <span id="gs0020">Digital Technology Center</span>, and the doctoral dissertation fellowship at the University of Minnesota.</p></section><div class="Appendices"><section id="sec0145"><h2 id="sect0165" class="u-h3 u-margin-l-top u-margin-xs-bottom">Appendix B. Supplementary Data</h2><p id="p0385">The following are the supplementary material of this article. <span class="display"><span class="e-component e-component-mmc1" id="mmc0005"><span class="article-attachment"><a class="icon-link" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc1.pdf" title="Download Acrobat PDF file (487KB)" target="_blank" rel="noreferrer noopener"><svg focusable="false" viewBox="0 0 95 128" width="17.8125" height="24" class="icon icon-pdf-download"><path d="m82 108h-7e1v-49c0-6.08 4.92-11 11-11h17v-2e1h-6c-2.2 0-4 1.8-4 4v6h-7c-3.32 0-6.44 0.78-9.22 2.16 2.46-5.62 7.28-11.86 13.5-17.1 2.34-1.98 5.3-3.06 8.32-3.06h46.4v4e1h1e1v-5e1h-56.4c-5.38 0-10.62 1.92-14.76 5.4-9.1 7.68-18.84 20.14-18.84 32.1v70.5h9e1v-18h-1e1v8zm-25.94-39.4c-0.84-0.38-1.84-0.56-2.98-0.56h-9.04v23.6h5.94v-9h2.18c2.48 0 4.36-0.62 5.66-1.84s1.92-3.06 1.92-5.5c0-1.04-0.12-2-0.4-2.88-0.26-0.88-0.66-1.64-1.22-2.3s-1.22-1.14-2.06-1.52zm-3.12 8.94c-0.4 0.46-0.98 0.7-1.74 0.7h-1.22v-5.76h1.22c1.56 0 2.34 0.96 2.34 2.88 0 0.98-0.2 1.72-0.6 2.18zm21.84-8.52c-0.96-0.66-2.32-0.98-4.06-0.98h-8.72v23.6h8.72c1.74 0 3.1-0.32 4.06-0.98s1.7-1.52 2.18-2.62 0.78-2.34 0.88-3.76 0.16-2.9 0.16-4.44-0.06-3.02-0.16-4.44-0.4-2.68-0.88-3.76c-0.48-1.1-1.2-1.96-2.18-2.62zm-2.78 14.66c-0.06 0.96-0.18 1.72-0.38 2.24s-0.48 0.88-0.84 1.04-0.86 0.24-1.48 0.24h-1.32v-14.74h1.32c0.62 0 1.12 0.08 1.48 0.24s0.64 0.52 0.84 1.04 0.32 1.28 0.38 2.24c0.06 0.98 0.08 2.24 0.08 3.84s-0.02 2.9-0.08 3.86zm13.98-6.58v-4.02h7.74v-5.04h-13.7v23.6h5.96v-9.72h7.26v-4.82z"></path></svg></a><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc1.pdf" target="_blank" download="" title="Download Acrobat PDF file (487KB)"><span class="anchor-text">Download : <span class="download-link-title">Download Acrobat PDF file (487KB)</span></span></a></span><span class="article-attachment"><a class="icon-link" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc2.txt" title="Download text file (5KB)" target="_blank" rel="noreferrer noopener"><svg focusable="false" viewBox="0 0 94 128" width="17.625" height="24" class="icon icon-text-document"><path d="m35.6 1e1c-5.38 0-10.62 1.92-14.76 5.4-9.1 7.68-18.84 20.14-18.84 32.1v70.5h9e1v-15.99-2.01-4e1 -17.64-32.36h-56.4zm0 1e1h46.4v22.36 17.64 4e1 2.01 5.99h-7e1v-49c0-6.08 4.92-11 11-11h17v-2e1h-6c-2.2 0-4 1.8-4 4v6h-7c-3.32 0-6.44 0.78-9.22 2.16 2.46-5.62 7.28-11.86 13.5-17.1 2.34-1.98 5.3-3.06 8.32-3.06zm-13.6 38v1e1h5e1v-1e1h-5e1zm0 2e1v1e1h5e1v-1e1h-5e1z"></path></svg></a><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc2.txt" target="_blank" download="" title="Download text file (5KB)"><span class="anchor-text">Download : <span class="download-link-title">Download text file (5KB)</span></span></a></span><span class="article-attachment"><a class="icon-link" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc3.txt" title="Download text file (65KB)" target="_blank" rel="noreferrer noopener"><svg focusable="false" viewBox="0 0 94 128" width="17.625" height="24" class="icon icon-text-document"><path d="m35.6 1e1c-5.38 0-10.62 1.92-14.76 5.4-9.1 7.68-18.84 20.14-18.84 32.1v70.5h9e1v-15.99-2.01-4e1 -17.64-32.36h-56.4zm0 1e1h46.4v22.36 17.64 4e1 2.01 5.99h-7e1v-49c0-6.08 4.92-11 11-11h17v-2e1h-6c-2.2 0-4 1.8-4 4v6h-7c-3.32 0-6.44 0.78-9.22 2.16 2.46-5.62 7.28-11.86 13.5-17.1 2.34-1.98 5.3-3.06 8.32-3.06zm-13.6 38v1e1h5e1v-1e1h-5e1zm0 2e1v1e1h5e1v-1e1h-5e1z"></path></svg></a><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc3.txt" target="_blank" download="" title="Download text file (65KB)"><span class="anchor-text">Download : <span class="download-link-title">Download text file (65KB)</span></span></a></span><span class="article-attachment"><a class="icon-link" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc4.txt" title="Download text file (66KB)" target="_blank" rel="noreferrer noopener"><svg focusable="false" viewBox="0 0 94 128" width="17.625" height="24" class="icon icon-text-document"><path d="m35.6 1e1c-5.38 0-10.62 1.92-14.76 5.4-9.1 7.68-18.84 20.14-18.84 32.1v70.5h9e1v-15.99-2.01-4e1 -17.64-32.36h-56.4zm0 1e1h46.4v22.36 17.64 4e1 2.01 5.99h-7e1v-49c0-6.08 4.92-11 11-11h17v-2e1h-6c-2.2 0-4 1.8-4 4v6h-7c-3.32 0-6.44 0.78-9.22 2.16 2.46-5.62 7.28-11.86 13.5-17.1 2.34-1.98 5.3-3.06 8.32-3.06zm-13.6 38v1e1h5e1v-1e1h-5e1zm0 2e1v1e1h5e1v-1e1h-5e1z"></path></svg></a><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc4.txt" target="_blank" download="" title="Download text file (66KB)"><span class="anchor-text">Download : <span class="download-link-title">Download text file (66KB)</span></span></a></span><span class="article-attachment"><a class="icon-link" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc5.txt" title="Download text file (5KB)" target="_blank" rel="noreferrer noopener"><svg focusable="false" viewBox="0 0 94 128" width="17.625" height="24" class="icon icon-text-document"><path d="m35.6 1e1c-5.38 0-10.62 1.92-14.76 5.4-9.1 7.68-18.84 20.14-18.84 32.1v70.5h9e1v-15.99-2.01-4e1 -17.64-32.36h-56.4zm0 1e1h46.4v22.36 17.64 4e1 2.01 5.99h-7e1v-49c0-6.08 4.92-11 11-11h17v-2e1h-6c-2.2 0-4 1.8-4 4v6h-7c-3.32 0-6.44 0.78-9.22 2.16 2.46-5.62 7.28-11.86 13.5-17.1 2.34-1.98 5.3-3.06 8.32-3.06zm-13.6 38v1e1h5e1v-1e1h-5e1zm0 2e1v1e1h5e1v-1e1h-5e1z"></path></svg></a><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc5.txt" target="_blank" download="" title="Download text file (5KB)"><span class="anchor-text">Download : <span class="download-link-title">Download text file (5KB)</span></span></a></span><span class="article-attachment"><a class="icon-link" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc6.xlsx" title="Download spreadsheet (15KB)" target="_blank" rel="noreferrer noopener"><svg focusable="false" viewBox="0 0 98 128" width="18.375" height="24" class="icon icon-interactive-case-insights"><path d="m2 1e1v1.1e2h94v-1.1e2h-94zm84 1e2h-74v-9e1h74v9e1zm-64-28h14v16h-14zm2e1 -18h14v34h-14zm2e1 8h14v26h-14zm-6.04-16.3l22.04-11.86v-11.36l-21.96 11.82-19.06-10.58-16.98 18.52v14.8l19.02-20.76z"></path></svg></a><a class="anchor download-link u-font-sans" href="https://ars.els-cdn.com/content/image/1-s2.0-S0098135414000398-mmc6.xlsx" target="_blank" download="" title="Download spreadsheet (15KB)"><span class="anchor-text">Download : <span class="download-link-title">Download spreadsheet (15KB)</span></span></a></span></span></span></p></section></div></div>