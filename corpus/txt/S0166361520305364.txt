Smart product service system (PSS) has emerged as the mainstream strategy employed by the manufacturers to achieve higher market competiveness, customer satisfaction and environmental sustainability in the era of smart plus (Zheng et al., 2019; Saunila et al., 2019). Smart PSS comprises a smart connected product (SCP) and various high-valued smart product service (SPS) which are delivered to meet customers’ personalized requirements as an extension of product (Zheng et al., 2019; Song et al., 2015). These SPS solutions are provided on the basis of application of smart technologies in the product operation, such as smart maintenance service, smart updating service, smart sharing service and smart recovery service (Chen et al., 2020a). The revolutionary development of the advanced smart technologies (e.g. smart sensing, Internet of Things (IoT), cyber-physical system (CPS), digital-twin (DT), virtual- / augmented- reality (VR/AR), artificial intelligence (AI)) enable most of the components in a smart PSS to be perceptible, communicable, diagnosable, interpretable, predictable, controllable and optimizable (Chen et al., 2020a; Siow et al., 2018; Rymaszewska et al., 2017). These critical characteristics empower the smart PSS present higher potential to agilely satisfy the dynamic requirements or needs of various multiple stakeholders (Chowdhury et al., 2018; Chen et al., 2020b) and flexibly response to the rapid changes in the external environment (Saunila et al., 2019). Although the potential of smart PSS to meet personalized requirements has been widely acknowledged (Valencia et al., 2015; Lerch and Gotsch, 2015; Chang et al., 2019), it does not imply that smart PSS would inherently have this capability. The development, implementation, and operation of smart PSS are still challenging (Zheng et al., 2019).
Modularization of product service is acknowledged as a promising approach to coping with the current requirement for efficient service customization, reduced development cost, decreased lead-times, easier portfolios of service modules and increased flexibility to response rapid market change (Geng et al., 2019; Fargnoli et al., 2019; Song and Sakao, 2017; Sakao et al., 2017). However, most the existing research mainly focuses on the modularization of physical product service, while containing scant study of SPS modularization. In addition, the emerging characteristics of SPS components with the application of smart technologies have also brought about new challenges to the SPS modularization. Therefore, it is necessary to take a deep exploration of SPS modularization in the context of smart PSS.
According to the literature review results, the service modularization process of PSS can be divided into three typical phases: identification of service components, evaluation of correlation between service components and partition of service module (Song et al., 2015; Geng et al., 2019; Sakao et al., 2017; Yu et al., 2008). Compared with the service modularization for traditional PSS, SPS modularization for smart PSS presents some differences in the three phases. First, the identification of SPS components is more complicated in practice due to the service process intangibility and the complex interactive interrelationship between service components. Not only the material flow, function interdependence and physical activity interaction exist between the service components (Song et al., 2015; Sakao et al., 2017), but also a large amount of data, knowledge and wisdom frequently flow across the service components and the cyber-physical service space (Zheng et al., 2018; Maleki et al., 2018; Wiesner et al., 2017). The identification of service components in the context of smart PSS should thus consider the specific service operation process and complex interaction between the physical operation space and cyber operation space. The used tools or methods in the realm of pure product design or physical product service design are not suitable to solve the problem of SPS components identification, since they do not fully take the new characteristics of SPS components into account. Therefore, it is necessary to develop a feasible tool to identify SPS components for smart PSS.
Second, after the various SPS components are identified, the subsequent task is to evaluate the correlation among them, which provides critical basis to organize service components into appropriate service modules (Song et al., 2015). The correlation evaluation to great extends affects the formation way of the service components combined into modules. Therefore, it is necessary to accurately and objectively calculate the correlation between each pair of service components. The evaluation is usually conducted by inviting a group of experts to fill the questionnaires (Geng et al., 2019; Sakao et al., 2017). In this process, two types of uncertainty are involved (Wu and Mendel, 2010), namely, intrapersonal uncertainty caused by the individual linguistic vagueness and interpersonal uncertainty resulted from the group preference subjectivity, both which may lead to inaccurate evaluation results (Chen et al., 2020c). However, most the existing research on PSS modularization contains scant study of the simultaneous manipulation of these uncertainties.
Third, for the SPS module partition based on the obtained correlation evaluation results, the efficiency of the previous partition methods, such as fuzzy clustering algorithm (Sun et al., 2017), mapping matrix (Li et al., 2012), fuzzy graph (Song et al., 2015; Song and Sakao, 2017), transitive closure method (Geng et al., 2019; Sheng et al., 2017) and morphological matrix (Li et al., 2018), would markedly decrease and easily suffered in local optima (Sayama et al., 2013). Most of these methods cannot be capable to acquire optimal SPS module partition schemes in terms of a larger calculation scale and workload, and to provide a visualization way to directly understand the partition process. Moreover, most the existing methods rarely offer measurement for evaluating the quality of partition schemes, so that the optimal scheme cannot be accurately selected.
Based on the description above, three research issues are identified as follows: (1) Research issue I: How to accurately identify the SPS components in the context of smart PSS which involves more complicated interaction between service components over traditional PSS? (2) Research issue II: How to precisely evaluate correlation between SPS components under intrapersonal and interpersonal uncertain environments? (3) Research issue III: How to visualize and measure the SPS module partition process with large calculation workload?
Therefore, to solve the issues discussed above, the current study proposes a hybrid framework for SPS modularization, which includes three parts: SPS components identification using the CPS-based SPS blueprint, SPS correlation evaluation with the rough-fuzzy number, and SPS module partition based on the weighted complex network and the modified Girvan-Newman (GN) algorithm. The proposed CPS-based SPS blueprint can provide a holistic description of the cyber and physical service operation process and a visual representation of the complex interaction between each pair of SPS components. With this tool, the embedded service components can be clearly and accurately identified by the service designers. In addition, the proposed correlation evaluation method combines the strength of fuzzy set in handling intrapersonal linguistic vagueness and the merit of rough set in manipulating interpersonal preference diversity. Moreover, the application of complex network theory and GN algorithm provides a visualized representation of the correlation between all pairs of SPS components through the transformation of the correlation matrix into a weighted complex network and optimal SPS module partition scheme. Finally, the proposed framework is applied in a case of smart gearbox maintenance service to illustrate the practical implementation process. The feasibility and validity are demonstrated through comparison with other approaches.
The remainder of this paper is arranged like this: Section 2 reviews some literatures concerning smart PSS and the process and methods for product service modularization. Section 3 describes the proposed integrated framework for SPS modularization. Section 4 presents a case study of application of the proposed framework. Section 5 shows comparisons of proposed approaches with some related methods. Finally, the implications, conclusions and limitations are summarized in Section 6.
Kuhlenkötter, et al. (Kuhlenkötter et al., 2017) indicated that smart PSS is an socio-technical PSS integrating smart connected products (SCPs) and smart service systems for the purpose of providing new functionalities. Zheng, et al. (Zheng et al., 2018) presented a CPS structure of smart PSS in which SCPs are considered as an interactive interface to connect the physical product / service operation space and the cyber product / service space. Liu, et al. (Liu et al., 2019a) exhibited an evolution of future structure of smart PSS which address main attentions on the achievement of excellent experience and high personalization in customer scenarios. In the context of smart PSS, smart products are connected to each other via the technological infrastructure with forming networked physical platforms (Li et al., 2017; Porter and Heppelmann, 2014). A large amount of data generated from the operation of SCPs is converted to smart data (knowledge or wisdom) using big data analytic tool and artificial intelligence (Rymaszewska et al., 2017; Ding et al., 2019). These smart data can provide insightful description, diagnosis, prediction and decision-making to optimize the physical product service operation performance (Siow et al., 2018). In this respect, the operation process of SPS involves not only the specific physical service activities but also the interaction of smartness (i.e. data, information, wisdom) across the physical-cyber system (Chen et al., 2020a). A whole SPS operation process can be described as a process in which the service resources support the service flow under the guidance of smartness to achieve expected service function (Zheng et al., 2019). Such a process consists of various working service components that are defined as a basic element to constitute a product service (Song et al., 2015). The service operation process and the relationships between the service components have significantly changed with the deep application of smart technologies (Chen et al., 2020c). The interaction between the physical service domain and the cyber service domain adds more complexity and multidimensionality to the service representation and description. Not only the visible material flow, activity flow and resource flow, but also the invisible data flow, information flow and knowledge flow are involved in the service operation process (Maleki et al., 2018; Wiesner et al., 2017). These complex interactions bring with new challenges towards the SPS modularization, so it is urgently necessary to take more exploration on developing adaptive and feasible modularization method for smart PSS.
The notion of product service modularization is first proposed by Aurich, et al. (Aurich et al., 2006a) who leverage the product modularization thinking (Bonvoisin et al., 2016) as a basic enabler to build systematic design framework for PSS. A lifecycle-oriented design process for technical PSS is then proposed with considering the product modularization and service modularization as two independent engineering activities within an integrated PSS development project (Aurich et al., 2006b). Yu, et al. (Yu et al., 2008) described a service modularization process for PSS including four phases: service process modeling, standardization of service process, generation of service module repository and service modules selection and combination. Wang, et al. (Wang et al., 2011) exhibited a W-type modular development framework of PSS which contains three parts: service modularization, functional modularization and product modularization. In this work, descriptive implementation steps are provided in the framework, while the operable and mathematic tools or methods are not included. Li, et al. (Li et al., 2012) established an interactive modular design process for integrated product service based on the analysis of the interrelationship between physical module and product module. This framework consists of service module partition process, product module partition process and module partition method. These studies indeed bring valuable knowledge on PSS modularization, but most of them are carried out from the conceptual perspective while containing scant quantitative methods. a mathematic approach to product-extension service modularization was proposed by Song, et al. (Song et al., 2015), it consists of three phases: service components identification, correlation evaluation for service components and service module partition. Then, Sakao, et al. (Sakao et al., 2017) presented a general process for service modularization including five steps, namely, describe customers’ needs, determine level of granularity, gather service components, assign interactions and create service modules. Sheng, et al. (Sheng et al., 2017) introduced three parts, i.e. service module division, product-service integration and configuration of product-service system to constitute a holistic framework for PSS module partition and configuration. Larsen, et al. (Larsen et al., 2018) summarized a descriptive framework for PSS modularization without providing quantitative methods through literature review. Li, et al. (Li et al., 2018) presented a methodological framework including four steps: service needs acquisition, principal solution seeking, principal solution combination and modular solution evaluation. Although this methodology provides a logical, operable and mathematical procedure for the PSS modularization, it lacks of considering the specific operation process of product service. Liu, et al. (Liu et al., 2019b) introduced an approach to concurrent product design and service module planning using a simulation-based evaluation method. Fargnoli, et al. (Fargnoli et al., 2019) provides a valuable framework that covers PSS components definition, services’ modules definition and PSS optimization. However, the approach is only adaptive to the physical PSS while not revealing the characteristics of smart technology-enabled PSS. In addition, because this approach is more conceptual without offering specific mathematic procedure to illustrate the implementation process, it cannot be easily used and verified.
According to these studies, a general service modularization process can be divided into four typical phases, i.e. service components identification, correlation evaluation for service components, service module partition, and partition module evaluation. Therefore, in the current study, the proposed SPS modularization process is organized based on this general process.
Although the research on modularization process has been widely explored in the existing literature, the supporting tools or mathematical methods to implement the modularization have been often omitted. Some studies have explored the related methods to practically realize the PSS modularization. For instance, Li, et al. (Li et al., 2012) suggested to use the Quality Function Deployment (QFD) to identify PSS components and applying mapping matrix for module partition. Song, et al. (Song et al., 2015) developed a product-extension service blueprint (PES) for service components identification, and then evaluated the comprehensive correlation between service components based on interdependence matrix, as well as applied the fuzzy graph theory for service module partition. Sakao, et al. (Sakao et al., 2017) developed a new practical method that supports designers to create service modules by extending the design structure matrix (DSM). Sheng, et al. (Sheng et al., 2017) used directed graph to describe the relationship between service activities, and applied DSM for service activity identification, employed the transitive closure method to cluster service module and product module. Sun, et al. (Sun et al., 2017) applied functional requirement analysis (FRA) to identify PSS components which are clustered into service modules using the fuzzy clustering algorithm. Zheng, et al. (Zheng et al., 2017) employed the DSM to evaluate correlation between service components and applied the graph theory to generate initial service modules. Then, the generated modularization scheme is evaluated using a multi-objective optimization model. Li, et al. (Li et al., 2018) applied the morphological matrix method to obtain modular service portfolios and used an optimization method (cost and profit method) to evaluate module division schemes. Geng, et al. (Geng et al., 2019) developed a result-oriented PSS modular design method based on Fuzzy DSM. In this study, a weighted directed graph is used to represent the relationships between service activities, and the absolute value reciprocal method is applied to cluster the service modules. Fargnoli, et al. (Fargnoli et al., 2019) suggested to use the QFD and Delphi methods to identify PSS components, applying the Axiomatic Design theory to define service modules and employing the service blueprint for definition of new solutions.
Although these studies discussed above brought valuable exploration for the implementing methods of PSS modularization, most of them have not yet considered some critical characteristics of smart PSS modularization. Table 1 shows the comparative features of the previously used methods. The listed literatures are searched out by using keywords “PSS and modularization”, “modularization of product extension service”, “modularization of product related service”, “modularization of product service” and “modularization of smart product service” from the “Scopus” and “Google Scholar” database. First, the majority of the previous methods for service component identification do not consider the service operation process and emerging smart product service characteristics. These characteristics refer to the smart capabilities of service components (e.g. perceptible, communicable, diagnosable, predictable and optimizable) (Chen et al., 2020b) and the complex interaction (e.g. material flow, function correlation, data flow, information flow and wisdom flow) between the service components (Song et al., 2015; Zheng et al., 2018). These novel characteristics make the identification of SPS components to be more complicated in practice. However, the used methods for identification of traditional service components are not suitable for SPS component identification. For example, the QFD and DSM cannot be used to describe the specific operation process of a product service activity in which the interaction between service components in terms of cyber and physical flow are involved. Moreover, although the weighted directed graph and service blueprint consider the interrelationship between service components, they cannot be capable of representing the flow of data, information and wisdom across the cyber and physical service space. Second, most the previous methods for correlation evaluation do not consider the evaluation uncertainty involved in the group decision process, which may lead to inaccurate correlation results and partition schemes. In addition, the efficiency of the previous partition methods, such as clustering algorithm, mapping matrix, fuzzy graph, transitive closure method and morphological matrix, will markedly decrease and easily suffer in local optima. Moreover, such methods cannot provide a visualized index as an easy way to understand the partition process and to select the optimal scheme.
This paper proposes a hybrid framework for SPS modularization, integrating the CPS-based SPS blueprint for SPS components identification (Research issue I), rough-fuzzy number for evaluating correlation between SPS components (Research issue II) and complex network theory for SPS module partition (Research issue III). The framework consists of three stages (see Fig. 1). Stage I mainly focuses on developing the CPS-based SPS blueprint in order to identify SPS components. As mentioned above, the previous used product-extension service blueprint (Song et al., 2015) is feasible to represent the operation process of conventional product service, but not effective to model the SPS operation process because of the more complex interaction between SPS components. Therefore, this stage proposes a general CPS-based SPS blueprint by integrating the basic structure of cyber-physical product service system (Wiesner et al., 2017; Zheng et al., 2016) and traditional product service blueprint (Song et al., 2015; Bitner et al., 2008). The proposed CPS-based SPS blueprint can provide a holistic description of the cyber and physical service operation process and a visual representation of the complex interaction between each pair of SPS components. With this tool, the embedded service components can be clearly and accurately identified by the service designers. Moreover, the evaluation process of correlation between SPS components involves intrapersonal linguistic vagueness and interpersonal preference diversity which would lead to inaccurate correlation and partition results. However, the previous research rarely fully consider these hybrid uncertainties. Therefore, Stage II proposes a correlation evaluation method based on the rough-fuzzy number with simultaneously considering the intrapersonal linguistic vagueness and interpersonal preference diversity. In addition, the efficiency of the previous partition methods would markedly decrease and easily suffer in local optima. Consequently, Stage III firstly applies the complex network theory and modified GN algorithm for SPS module partition. The complex network theory is applied to establish a SPS network model and the GN algorithm is modified to be feasible for visual SPS partition. Then, a measurement index called as modularity is introduced to evaluate the quality of service module partition schemes and select the optimal one. The detailed description of the proposed framework is introduced in the following sections.
In accordance with the PSS modularization thinking (Song et al., 2015; Song and Sakao, 2017), a product service can be broken down into multiple service modules, and a service module can be decomposed into multiple service components. A service component is defined as a basic element to constitute a product-extension service. In the context of smart PSS, a service component can be considered as a service activity (e.g., digital twin-based simulation, physical product disassembly, fault prediction) or service resource (e.g. digital twin system, cyber service system, physical service resources) that results in a unique function of the whole smart product service. In addition, a service module generally consists of a set of service components among which there exist strong correlation. The service components belonged to different modules have a lower interdependence or connection than the components belonged to the same module. This feature provides a basis to solve the problem of service module partition by applying the community detection method of complex network theory.
To construct SPS module, the first task is breaking down the target service into multiple service components. However, it is difficult to accurately describe and quantitatively represent the service process, service function and service activity due to the intangibility of product-extension service. Furthermore, the service operation process and the relationships between the service components have significantly changed with the deep application of smart technologies. The interaction between the physical service domain and the cyber service domain adds more complexity and multidimensionality to the service representation and description. Not only the visible material flow, activity flow and resource flow, but also the invisible data flow, information flow and knowledge flow are involved in the service operation process. An identification tool of smart service components named CPS-based SPS blueprint is provided. This tool is applied to holistically describe the cyber and physical service operation. Through the visual representation of the entire operation process, all the related service elements are covered and presented. Thus, the embedded service components can be clearly and accurately identified by the service designers.
This section proposed a general CPS-based SPS blueprint by integrating the basic structure of cyber-physical product service system (Wiesner et al., 2017; Zheng et al., 2016) and traditional product service blueprint (Song et al., 2015; Bitner et al., 2008). As shown in Fig. 2, the SPS blueprint incorporates five main domains, namely, physical SCP operation domain, physical service operation domain, physical resource domain, cyber PSS operation domain, and cyber resource domain. The domain of physical SCP operation is implemented to realize the specific SCP’s function that supports both the cyber service and physical service. The domain of cyber PSS operation is established to achieve smart functions (Chen et al., 2020b) such as real-time perception, interactive connection, dynamic monitor, informative diagnostic, accurate prediction, optimal decision-making, and smart prescription, etc. It includes four sub-domains, namely, SCP data management domain, SCP digital twin domain, data analytic domain and cyber service domain. The domain of cyber resource is designed to provide the requested virtual resources such as communication network, computing infrastructure, virtual platform and system, information system, knowledge base, algorithm base, etc. It is foundation of the domain of cyber PSS operation and the domain of physical service operation, since it provides the underlying service resources to facilitate the product and service towards expected smart capabilities. The domain of physical service operation is set to take the physical service action, and achieve the goal and function of the physical service function. In addition, the physical resource domain mainly aims to provide support for the physical service-related activities occurred in the domain of physical service operation. With this SPS blueprint, the designers can clearly understand and acquire the SPS structure.
It can be seen in Fig. 2, the SPS blueprint is split into eight functional areas by six boundaries. These boundaries are respectively named as boundary between product and service, boundary between physical activity and cyber activity, boundary between activity and cyber resource, boundary between activity and physical resource, boundary between data and simulation, and boundary between data and cyber service. The service elements are classified into seven types, i.e. product-related activities (PRA), service-related activities (SRA), users-involved PRA, users-involved SRA, cyber product-related resource, cyber service-related resource, and physical resource. All the elements are represented by unique and standard symbols (see Fig. 2). The arrow between the elements denotes their interaction, which can be identified as the flow of smartness (e.g. data, information, knowledge) or service, or the correlation of function or resource. The detailed description of the boundary and split function area are introduced as follows.
First, the boundary between the product and service divides the whole SPS blueprint into product operation domain and service operation domain, which reflects the different scopes of the product and service. In the product operation domain, the boundary between physical activity and cyber activity divides the product-related activity domain into physical product activity domain and cyber product activity domain. In addition, the cyber product operation domain can be split to management domain of product data and simulation domain of product digital twin by the boundary between data and simulation. Several main activities are inherently taken place in the data domain, such as collection, processing and storage of operational data. In the digital twin activity domain, the real-time mapping and visualization of the physical product operation are regarded as necessary activities in a cyber product space. Thus, we list these elements in their domains as typical obligatory components. The physical product operation domain include product-related activities and users involved PRA of which examples could be the product adjustment.
Second, in the left side of the boundary between product and service, there are five domains related with service operation. The boundary between data and cyber service divides the cyber service activity domain into data analytic domain and cyber service domain, which describes the interaction between core data analytic capability and smart service function. The activities of descriptive analytics, diagnostic analytics, predictive analytics and prescriptive analytics are identified as the core smart service components, since they provide basis to deliver product extension service in a smarter way. Furthermore, the service activities in cyber service domain provide smart decision-making for the execution of physical service activities, with integrating the data analytic capability and the product-related professional knowledge. This integration is conducted in the big data analytic platform, which is considered as basic component in the cyber resource domain. Corresponding to each activity element in the domain of cyber service, there is a supporting cyber resource system to achieve expected smart service results in the domain of cyber resource domain. In addition, the domain of physical operation domain includes invisible physical service activities and visible service activities which users. These physical service activities are supported by the key physical service resources, such as, spare parts, service tools, service engineers, etc., which are provided in the domain of physical resource.
With application of the proposed CPS-based SPS blueprint, the smart service components can be easily identified and their interrelationship can be also visually described. The different boxes in Fig. 2 separately denote different service components to be identified. This blueprint can provide not only the approach to modeling of smart product service, but also the detailed description of the specific operation process. This tool is thus feasible to assist the designers to identify all types of service components, and analyze the interaction between the identified components.
In this section, the rough-fuzzy number proposed by Chen, et al. (Chen et al., 2020a) is applied into the evaluation of correlation between the smart service components, with objective of simultaneously manipulating the intrapersonal linguistic vagueness and interpersonal preference subjectivity.
The operation process of smart product service involves not only the specific physical service activities but also the interaction of smartness (i.e. data, information, wisdom) across the physical-cyber system. A whole smart product service process can be described as a process in which the service resources (input) support the service flow (process) under the guidance of smartness (decision) to achieve expected service function (output). Therefore, in this study, the evaluation criteria for correlation between service components include function correlation, service-flow correlation, smartness-flow correlation and resource correlation. The description for these criteria are presented as follows:
Function correlation: The service module assembled with the service components that have stronger function correlation can achieve higher functional independence and thus obtain higher exchangeability. Thus, the service components that implement the relevant or similar function should be aggregated into one service module to enhance the functional dependency of the module and decrease the functional redundancy of the smart product service.
Service-flow correlation: In the physical operation domain, the interaction between service components can be presented in the transfer process of a set of physical activities or materials. The service-flow correlation between two components can be identified if output of one component flow into the other one.
Smartness-flow correlation: In the cyber operation domain, the interaction between service components are exhibited in the transmission of data, information and knowledge. This type of transfer interaction is named as smartness-flow correlation. If there exist exchange of data, information and knowledge between two service modules, they are regarded to be smartness-flow correlated.
Resource correlation: In the smart product service process, two service components may work based on the same physical or cyber resource. They can be considered to be resource dependent. For instance, fault monitor and fault diagnosis share the same cyber resource: big data analytic platform, so they are resource correlated.
In this section, an approach integrated with fuzzy set and rough set is proposed to evaluate the correlation between service components. The function correlation, service-flow correlation, smartness-flow correlation and resource correlation can be respectively calculated by the following procedures. The procedure is described by taking function correlation as examples.
A decision group consisting of R DMs is invited to evaluate the function correlation among n service components (SCs). A set of linguistic variables are used by the DMs to judge the correlation strength (see Table 2).
The linguistic correlation matrix Csf<math><mrow is="true"><msubsup is="true"><mi is="true">C</mi><mi is="true">s</mi><mi is="true">f</mi></msubsup></mrow></math> which is made by the sth DM is established as follows:(1)Csf=0c12fs⋯c1nfsc21fs0⋯c2nfs⋮⋮⋱⋮cn1fscn2fs⋯0<math><mrow is="true"><msubsup is="true"><mi is="true">C</mi><mi is="true">s</mi><mi is="true">f</mi></msubsup><mo is="true">=</mo><mfenced open="[" close="]" is="true"><mrow is="true"><mtable columnalign="center" displaystyle="true" is="true"><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mn is="true">12</mn><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mn is="true">21</mn><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋱</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd></mtr></mtable></mrow></mfenced></mrow></math>where cijfs<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math> represents the linguistic correlation strength between SCi and SCj, and cijfs=cjifs<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo is="true">=</mo><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">j</mi><mi is="true">i</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math> (i ≠ j), and s = 1, 2, …, R.
Following the fuzzy scale in Table 2, the element cijfs<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math> of the linguistic correlation matrix Csf<math><mrow is="true"><msubsup is="true"><mi is="true">C</mi><mi is="true">s</mi><mi is="true">f</mi></msubsup></mrow></math> is converted to c˜ijfs=(lijs,mijs,uijs)<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>, where lijs<math><mrow is="true"><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup></mrow></math>, mijs<math><mrow is="true"><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup></mrow></math> and uijs<math><mrow is="true"><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup></mrow></math> denotes the low boundary, medium boundary and up boundary of the TFN, respectively. Then, the fuzzy correlation matrix C˜sf<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">C</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mi is="true">s</mi><mi is="true">f</mi></msubsup></mrow></math> is established as follows:(2)C˜sf=0c˜12fs⋯c˜1nfsc˜21fs0⋯c˜2nfs⋮⋮⋱⋮c˜n1fsc˜n2fs⋯0<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">C</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mi is="true">s</mi><mi is="true">f</mi></msubsup><mo is="true">=</mo><mfenced open="[" close="]" is="true"><mrow is="true"><mtable columnalign="center" displaystyle="true" is="true"><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mn is="true">12</mn><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mn is="true">21</mn><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋱</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd></mtr></mtable></mrow></mfenced></mrow></math>
By gathering the fuzzy correlation matrices that are constructed by R DMs into a supermatrix, the group fuzzy matrices Cˆf<math><mrow is="true"><msup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">C</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mi is="true">f</mi></msup></mrow></math> can be formed as follows:(3)Cˆf=0cˆ12f⋯cˆ1nfcˆ21f0⋯cˆ2nf⋮⋮⋱⋮cˆn1fcˆn2f⋯0<math><mrow is="true"><msup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">C</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mi is="true">f</mi></msup><mo is="true">=</mo><mfenced open="[" close="]" is="true"><mrow is="true"><mtable columnalign="center" displaystyle="true" is="true"><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mn is="true">12</mn><mi is="true">f</mi></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow><mi is="true">f</mi></msubsup></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mn is="true">21</mn><mi is="true">f</mi></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow><mi is="true">f</mi></msubsup></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋱</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow><mi is="true">f</mi></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow><mi is="true">f</mi></msubsup></mrow></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd></mtr></mtable></mrow></mfenced></mrow></math>where cˆijf=(lˆij,mˆij,uˆij)<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">l</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">m</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">u</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math> lˆij=lij1,…,lijs,…,lijR<math><mrow is="true"><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">l</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">=</mo><mfenced open="{" close="}" is="true"><mrow is="true"><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mn is="true">1</mn></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">R</mi></msubsup></mrow></mfenced></mrow></math>, mˆij=mij1,…,mijs,…,mijR<math><mrow is="true"><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">m</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">=</mo><mfenced open="{" close="}" is="true"><mrow is="true"><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mn is="true">1</mn></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">R</mi></msubsup></mrow></mfenced></mrow></math>, uˆij=uij1,…,uijs,…,uijR<math><mrow is="true"><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">u</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">=</mo><mfenced open="{" close="}" is="true"><mrow is="true"><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mn is="true">1</mn></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">R</mi></msubsup></mrow></mfenced></mrow></math>, and the group TFNs can also be expressed as cˆijf=c˜ijf1,…,c˜ijfs,…,c˜ijfR<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo is="true">=</mo><mfenced open="{" close="}" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mn is="true">1</mn></mrow></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">R</mi></mrow></msubsup></mrow></mfenced></mrow></math>.
The group fuzzy TFNs cˆijf<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup></mrow></math> can be converted to rough-fuzzy number following the operation proposed by Chen, et al. (Chen et al., 2020a). The calculation steps are as follows:
(1) Step 4.1: Obtain the lower and upper approximations of each TFN
For the group TFNs cˆijf=c˜ijf1,…,c˜ijfs,…,c˜ijfR<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo is="true">=</mo><mfenced open="{" close="}" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mn is="true">1</mn></mrow></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">R</mi></mrow></msubsup></mrow></mfenced></mrow></math>, the lower and upper approximations of the sth TFN c˜ijfs<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math> can be obtained as follows:
Lower approximation:(4)Apr_(c˜ijfs)=∪c˜ijft∈cˆijf/c˜ijft≤c˜ijfs<math><mrow is="true"><munder is="true"><mrow is="true"><mi is="true">A</mi><mi is="true">p</mi><mi is="true">r</mi></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mo is="true">∪</mo><mfenced open="{" close="}" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">t</mi></mrow></msubsup><mo is="true">∈</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo is="true">/</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">t</mi></mrow></msubsup><mo is="true">≤</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mfenced></mrow></math>
Upper approximation:(5)Apr¯(c˜ijfs)=∪c˜ijft∈cˆijf/c˜ijft≥c˜ijfs<math><mrow is="true"><mover accent="true" is="true"><mrow is="true"><mi is="true">A</mi><mi is="true">p</mi><mi is="true">r</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mo is="true">∪</mo><mfenced open="{" close="}" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">t</mi></mrow></msubsup><mo is="true">∈</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo is="true">/</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">t</mi></mrow></msubsup><mo is="true">≥</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></mfenced></mrow></math>where Apr_(c˜ijfs)<math><mrow is="true"><munder is="true"><mrow is="true"><mi is="true">A</mi><mi is="true">p</mi><mi is="true">r</mi></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></math> and Apr¯(c˜ijfs)<math><mrow is="true"><mover accent="true" is="true"><mrow is="true"><mi is="true">A</mi><mi is="true">p</mi><mi is="true">r</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></math> denotes the lower and the upper approximation of the TFN a˜ijs<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">a</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup></mrow></math>, respectively.
(2) Step 4.2: Obtain the lower limit and the upper limit of each TFN
Then the lower limit and the upper limit of TFN c˜ijfs<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math> are defined as Lim_(c˜ijfs)<math><mrow is="true"><munder is="true"><mrow is="true"><mstyle mathvariant="italic" is="true"><mi is="true">Lim</mi></mstyle></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></math> and Lim¯(c˜ijfs)<math><mrow is="true"><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></math> as follows:(6)Lim_(c˜ijfs)=(Lim_(lijs),Lim_(mijs),Lim_(uijs))=1NsL∑k=1NsLxkl,1NsL∑k=1NsLxkm,1NsL∑k=1NsLxku<math><mtable columnalign="left" displaystyle="true" is="true"><mtr is="true"><mtd is="true"><munder is="true"><mrow is="true"><mstyle mathvariant="italic" is="true"><mi is="true">Lim</mi></mstyle></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><munder is="true"><mrow is="true"><mstyle mathvariant="italic" is="true"><mi is="true">Lim</mi></mstyle></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><munder is="true"><mrow is="true"><mstyle mathvariant="italic" is="true"><mi is="true">Lim</mi></mstyle></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><munder is="true"><mrow is="true"><mstyle mathvariant="italic" is="true"><mi is="true">Lim</mi></mstyle></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">)</mo></mtd></mtr><mtr is="true"><mtd is="true"><mo is="true">=</mo><mfenced open="(" close=")" is="true"><mrow is="true"><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">L</mi></msubsup></mrow></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">k</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">L</mi></msubsup></mrow></munderover><mrow is="true"><msubsup is="true"><mi is="true">x</mi><mi is="true">k</mi><mi is="true">l</mi></msubsup></mrow><mo is="true">,</mo><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">L</mi></msubsup></mrow></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">k</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">L</mi></msubsup></mrow></munderover><mrow is="true"><msubsup is="true"><mi is="true">x</mi><mi is="true">k</mi><mi is="true">m</mi></msubsup></mrow><mo is="true">,</mo><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">L</mi></msubsup></mrow></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">k</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">L</mi></msubsup></mrow></munderover><mrow is="true"><msubsup is="true"><mi is="true">x</mi><mi is="true">k</mi><mi is="true">u</mi></msubsup></mrow></mrow></mfenced></mtd></mtr></mtable></math>(7)Lim¯(c˜ijfs)=(Lim¯(lijs),Lim¯(mijs),Lim¯(uijs))=1NsU∑k=1NsUykl,1NsU∑k=1NsUykm,1NsU∑k=1NsUyku<math><mtable columnalign="left" displaystyle="true" is="true"><mtr is="true"><mtd is="true"><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">)</mo></mtd></mtr><mtr is="true"><mtd is="true"><mo is="true">=</mo><mfenced open="(" close=")" is="true"><mrow is="true"><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">U</mi></msubsup></mrow></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">k</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">U</mi></msubsup></mrow></munderover><mrow is="true"><msubsup is="true"><mi is="true">y</mi><mi is="true">k</mi><mi is="true">l</mi></msubsup></mrow><mo is="true">,</mo><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">U</mi></msubsup></mrow></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">k</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">U</mi></msubsup></mrow></munderover><mrow is="true"><msubsup is="true"><mi is="true">y</mi><mi is="true">k</mi><mi is="true">m</mi></msubsup></mrow><mo is="true">,</mo><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">U</mi></msubsup></mrow></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">k</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">U</mi></msubsup></mrow></munderover><mrow is="true"><msubsup is="true"><mi is="true">y</mi><mi is="true">k</mi><mi is="true">u</mi></msubsup></mrow></mrow></mfenced></mtd></mtr></mtable></math>where xkl<math><mrow is="true"><msubsup is="true"><mi is="true">x</mi><mi is="true">k</mi><mi is="true">l</mi></msubsup></mrow></math>, xkm<math><mrow is="true"><msubsup is="true"><mi is="true">x</mi><mi is="true">k</mi><mi is="true">m</mi></msubsup></mrow></math>, and xku<math><mrow is="true"><msubsup is="true"><mi is="true">x</mi><mi is="true">k</mi><mi is="true">u</mi></msubsup></mrow></math> are respectively the elements of lower approximation for low boundary, medium boundary, and up boundary of TFN c˜ijfs<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math>, ykl<math><mrow is="true"><msubsup is="true"><mi is="true">y</mi><mi is="true">k</mi><mi is="true">l</mi></msubsup></mrow></math>, ykm<math><mrow is="true"><msubsup is="true"><mi is="true">y</mi><mi is="true">k</mi><mi is="true">m</mi></msubsup></mrow></math>, and yku<math><mrow is="true"><msubsup is="true"><mi is="true">y</mi><mi is="true">k</mi><mi is="true">u</mi></msubsup></mrow></math> are respectively the elements of upper approximation for low boundary, medium boundary, and up boundary of TFN c˜ijfs<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math>, NsL<math><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">L</mi></msubsup></mrow></math> and NsU<math><mrow is="true"><msubsup is="true"><mi is="true">N</mi><mi is="true">s</mi><mi is="true">U</mi></msubsup></mrow></math> are the number of objects included in the lower approximation and upper approximation of TFN c˜ijfs<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math>.
(3) Step 4.3: Convert each TFN into rough-fuzzy form
The rough-fuzzy number form RF(c˜ijfs)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></math> of c˜ijfs<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup></mrow></math> can be described as follows:(8)RF(c˜ijfs)=c˜ijfsL,c˜ijfsU=(lijsL,mijsL,uijsL),(lijsU,mijsU,uijsU)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mfenced open="[" close="]" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow></mfenced><mo is="true">=</mo><mfenced open="[" close="]" is="true"><mrow is="true"><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></mfenced></mrow></math>(9)c˜ijfsL,c˜ijfsU=Lim_(c˜ijfs),Lim¯(c˜ijfs)<math><mrow is="true"><mfenced open="[" close="]" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow></mfenced><mo is="true">=</mo><mfenced open="[" close="]" is="true"><mrow is="true"><munder is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></mfenced></mrow></math>(10)(lijsL,mijsL,uijsL)=(Lim_(lijs),Lim_(mijs),Lim_(uijs))<math><mrow is="true"><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><munder is="true"><mrow is="true"><mstyle mathvariant="italic" is="true"><mi is="true">Lim</mi></mstyle></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><munder is="true"><mrow is="true"><mstyle mathvariant="italic" is="true"><mi is="true">Lim</mi></mstyle></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><munder is="true"><mrow is="true"><mstyle mathvariant="italic" is="true"><mi is="true">Lim</mi></mstyle></mrow><mo stretchy="true" is="true">_</mo></munder><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">)</mo></mrow></math>(11)(lijsU,mijsU,uijsU)=(Lim¯(lijs),Lim¯(mijs),Lim¯(uijs))<math><mrow is="true"><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mover accent="true" is="true"><mrow is="true"><mi is="true">L</mi><mi is="true">i</mi><mi is="true">m</mi></mrow><mo stretchy="true" is="true">¯</mo></mover><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">)</mo></mrow></math>where c˜ijfsL<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup></mrow></math> and c˜ijfsU<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow></math> are the lower limit and upper limit of rough-fuzzy number RF(c˜ijfs)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>; lijsL<math><mrow is="true"><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup></mrow></math> and lijsU<math><mrow is="true"><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow></math> are the lower limit and upper limit of rough number RN(lijs)<math><mrow is="true"><mi is="true">R</mi><mi is="true">N</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>; mijsL<math><mrow is="true"><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup></mrow></math> and mijsU<math><mrow is="true"><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow></math> are the lower limit and upper limit of rough number RN(mijs)<math><mrow is="true"><mi is="true">R</mi><mi is="true">N</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>; uijsL<math><mrow is="true"><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup></mrow></math> and uijsU<math><mrow is="true"><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow></math> are the lower limit and upper limit of rough number RN(uijs)<math><mrow is="true"><mi is="true">R</mi><mi is="true">N</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">s</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>.
(4) Step 4.4: Obtain rough-fuzzy interval number of group TFNs
The rough-fuzzy interval number RF(cˆijf)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math> of the group TFNs cˆijf=c˜ijf1,…,c˜ijfs,…,c˜ijfR<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo is="true">=</mo><mfenced open="{" close="}" is="true"><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mn is="true">1</mn></mrow></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">s</mi></mrow></msubsup><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">˜</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">R</mi></mrow></msubsup></mrow></mfenced></mrow></math> can be acquired by using rough computation principles as follows:(12)RF(cˆijf)=cijfL,cijfU<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mfenced open="[" close="]" is="true"><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">U</mi></mrow></msubsup></mrow></mfenced></mrow></math>(13)cijfL=(lijL,mijL,uijL)=1R∑s=1RlijsL,1R∑s=1RmijsL,1R∑s=1RuijsL<math><mtable columnalign="left" displaystyle="true" is="true"><mtr is="true"><mtd is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">L</mi></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">L</mi></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">L</mi></msubsup><mo stretchy="false" is="true">)</mo></mtd></mtr><mtr is="true"><mtd is="true"><mo is="true">=</mo><mfenced open="(" close=")" is="true"><mrow is="true"><mfrac is="true"><mn is="true">1</mn><mi is="true">R</mi></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">s</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">R</mi></munderover><mrow is="true"><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup></mrow><mo is="true">,</mo><mfrac is="true"><mn is="true">1</mn><mi is="true">R</mi></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">s</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">R</mi></munderover><mrow is="true"><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup></mrow><mo is="true">,</mo><mfrac is="true"><mn is="true">1</mn><mi is="true">R</mi></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">s</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">R</mi></munderover><mrow is="true"><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">L</mi></mrow></msubsup></mrow></mrow></mfenced></mtd></mtr></mtable></math>(14)cijfU=(lijU,mijU,uijU)=1R∑s=1RlijsU,1R∑s=1RmijsU,1R∑s=1RuijsU<math><mtable columnalign="left" displaystyle="true" is="true"><mtr is="true"><mtd is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">U</mi></mrow></msubsup><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">U</mi></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">U</mi></msubsup><mo is="true">,</mo><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">U</mi></msubsup><mo stretchy="false" is="true">)</mo></mtd></mtr><mtr is="true"><mtd is="true"><mo is="true">=</mo><mfenced open="(" close=")" is="true"><mrow is="true"><mfrac is="true"><mn is="true">1</mn><mi is="true">R</mi></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">s</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">R</mi></munderover><mrow is="true"><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow><mo is="true">,</mo><mfrac is="true"><mn is="true">1</mn><mi is="true">R</mi></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">s</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">R</mi></munderover><mrow is="true"><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow><mo is="true">,</mo><mfrac is="true"><mn is="true">1</mn><mi is="true">R</mi></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">s</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">R</mi></munderover><mrow is="true"><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">U</mi></mrow></msubsup></mrow></mrow></mfenced></mtd></mtr></mtable></math>where cijfL<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">L</mi></mrow></msubsup></mrow></math> and cijfU<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">f</mi><mi is="true">U</mi></mrow></msubsup></mrow></math> are the lower and upper limit of rough-fuzzy interval number RF(cˆijf)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>; lijL<math><mrow is="true"><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">L</mi></msubsup></mrow></math> and lijU<math><mrow is="true"><msubsup is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">U</mi></msubsup></mrow></math> are the lower and upper limit of rough interval RN(lˆij)<math><mrow is="true"><mi is="true">R</mi><mi is="true">N</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">l</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math>; mijL<math><mrow is="true"><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">L</mi></msubsup></mrow></math> and mijU<math><mrow is="true"><msubsup is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">U</mi></msubsup></mrow></math> are the lower and upper limit of rough interval RN(mˆij)<math><mrow is="true"><mi is="true">R</mi><mi is="true">N</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">m</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math>; uijL<math><mrow is="true"><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">L</mi></msubsup></mrow></math> and uijU<math><mrow is="true"><msubsup is="true"><mi is="true">u</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">U</mi></msubsup></mrow></math> are the lower and upper limit of rough interval RN(uˆij)<math><mrow is="true"><mi is="true">R</mi><mi is="true">N</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">u</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math>.
(5) Step 4.5: Obtain rough-fuzzy correlation matrix
After the group TFNs cˆijf<math><mrow is="true"><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup></mrow></math> are aggregated into a rough-fuzzy number RF(cˆijf)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>, the group fuzzy correlation matrix Cˆf<math><mrow is="true"><msup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">C</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mi is="true">f</mi></msup></mrow></math> can be converted to rough-fuzzy correlation matrix RF(Cˆf)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">C</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mi is="true">f</mi></msup><mo stretchy="false" is="true">)</mo></mrow></math> as follows:(15)RF(Cˆf)=0RF(cˆ12f)⋯RF(cˆ1nf)RF(cˆ21f)0⋯RF(cˆ2nf)⋮⋮⋱⋮RF(cˆn1f)RF(cˆn2f)⋯0<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">C</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mi is="true">f</mi></msup><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mfenced open="[" close="]" is="true"><mrow is="true"><mtable columnalign="center" displaystyle="true" is="true"><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd><mtd columnalign="center" is="true"><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mn is="true">12</mn><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mn is="true">21</mn><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></mtd><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋱</mo></mtd><mtd columnalign="center" is="true"><mo is="true">⋮</mo></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></mtd><mtd columnalign="center" is="true"><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></mtd><mtd columnalign="center" is="true"><mo is="true">⋯</mo></mtd><mtd columnalign="center" is="true"><mn is="true">0</mn></mtd></mtr></mtable></mrow></mfenced></mrow></math>
The weights of the four criteria of correlation between service components are obtained by applying the rough-fuzzy pair-wise comparison method proposed by Chen, et al. (Chen et al., 2019). The weights are satisfied with the following condition:(16)wf+wse+wsm+wr=1<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mi is="true">f</mi></msub><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">s</mi><mi is="true">e</mi></mrow></msub><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">s</mi><mi is="true">m</mi></mrow></msub><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mi is="true">r</mi></msub><mo is="true">=</mo><mn is="true">1</mn></mrow></math>where wf<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mi is="true">f</mi></msub></mrow></math>, wse<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">s</mi><mi is="true">e</mi></mrow></msub></mrow></math>, wsm<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">s</mi><mi is="true">m</mi></mrow></msub></mrow></math> and wr<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mi is="true">r</mi></msub></mrow></math> separately denotes weight of function correlation, weight of service-flow correlation, weight of smartness-flow correlation and weight of resource correlation.
The rough-fuzzy comprehensive correlation matrix RF(Cˆf)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">C</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mi is="true">f</mi></msup><mo stretchy="false" is="true">)</mo></mrow></math> can be acquired by weighted sum of the corresponding element of the four rough-fuzzy correlation matrices as follows:(17)RF(cˆij)=wfRF(cˆijf)+wseRF(cˆijse)+wsmRF(cˆijsm)+wrRF(cˆijr)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><msub is="true"><mi is="true">w</mi><mi is="true">f</mi></msub><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">f</mi></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">s</mi><mi is="true">e</mi></mrow></msub><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">e</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">s</mi><mi is="true">m</mi></mrow></msub><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">m</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mi is="true">r</mi></msub><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">r</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>where RF(cˆij)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math> represents the rough-fuzzy correlation strength between the ith service component and the jth one; RF(cˆijse)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">e</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></math>, RF(cˆijsm)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">s</mi><mi is="true">m</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo></mrow></math> and RF(cˆijr)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msubsup is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">r</mi></msubsup><mo stretchy="false" is="true">)</mo></mrow></math> separately denotes element of rough-fuzzy correlation matrix of service-flow, smartness-flow and resource, which are calculated using Eq. (1)∼(15).
To apply the complex network theory to modularize the service components, the comprehensive correlation strength should be transformed to crisp form. According to Chen, et al. (Chen et al., 2019), the crisp comprehensive correlation strength cij<math><mrow is="true"><msub is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></math> can be obtained as follows:(18)cij=(cijlL+4cijmL+cijuL+cijlU+4cijmU+cijuU)/12<math><mrow is="true"><msub is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">l</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">+</mo><mn is="true">4</mn><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">m</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">+</mo><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">u</mi><mi is="true">L</mi></mrow></msubsup><mo is="true">+</mo><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">l</mi><mi is="true">U</mi></mrow></msubsup><mo is="true">+</mo><mn is="true">4</mn><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">m</mi><mi is="true">U</mi></mrow></msubsup><mo is="true">+</mo><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">u</mi><mi is="true">U</mi></mrow></msubsup><mo stretchy="false" is="true">)</mo><mo is="true">/</mo><mn is="true">12</mn></mrow></math>where cijlL<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">l</mi><mi is="true">L</mi></mrow></msubsup></mrow></math>, cijmL<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">m</mi><mi is="true">L</mi></mrow></msubsup></mrow></math> and cijuL<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">u</mi><mi is="true">L</mi></mrow></msubsup></mrow></math> separately denotes the low boundary, medium boundary and up boundary of the lower limit of RF(cˆij)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math>; cijlU<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">l</mi><mi is="true">U</mi></mrow></msubsup></mrow></math>, cijmU<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">m</mi><mi is="true">U</mi></mrow></msubsup></mrow></math> and cijuU<math><mrow is="true"><msubsup is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mrow is="true"><mi is="true">u</mi><mi is="true">U</mi></mrow></msubsup></mrow></math> respectively denotes the low boundary, medium boundary and up boundary of the upper limit of RF(cˆij)<math><mrow is="true"><mi is="true">R</mi><mi is="true">F</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mover accent="true" is="true"><mi is="true">c</mi><mo stretchy="true" is="true">ˆ</mo></mover></mrow><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="false" is="true">)</mo></mrow></math>.
In this section, the comprehensive strength matrix of smart service components is used to inform a complex unidirectional weighted network model (Strogatz, 2001), since the matrix is a symmetric adjacency matrix. Then, the GN algorithm (Newman, 2006; Newman and Girvan, 2004) is modified for SPS module partition based on the community detection technique in complex network theory.
In this section, the crisp comprehensive correlation matrix is regarded as the adjacency matrix of a weighted unidirectional complex network model. This network model is represented by follows:(19)GSPS=(V,E,W)<math><mrow is="true"><msub is="true"><mi is="true">G</mi><mrow is="true"><mi is="true">S</mi><mi is="true">P</mi><mi is="true">S</mi></mrow></msub><mo is="true">=</mo><mo stretchy="false" is="true">(</mo><mi is="true">V</mi><mo is="true">,</mo><mi is="true">E</mi><mo is="true">,</mo><mi is="true">W</mi><mo stretchy="false" is="true">)</mo></mrow></math>where V={SC1,SC2,…,SCn}<math><mrow is="true"><mi is="true">V</mi><mo is="true">=</mo><mo stretchy="false" is="true">{</mo><mi is="true">S</mi><msub is="true"><mi is="true">C</mi><mn is="true">1</mn></msub><mo is="true">,</mo><mi is="true">S</mi><msub is="true"><mi is="true">C</mi><mn is="true">2</mn></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><mi is="true">S</mi><msub is="true"><mi is="true">C</mi><mi is="true">n</mi></msub><mo stretchy="false" is="true">}</mo></mrow></math> is a nodes set of the identified service components set, in which the node SCi<math><mrow is="true"><mi is="true">S</mi><msub is="true"><mi is="true">C</mi><mi is="true">i</mi></msub></mrow></math> denotes the ith service component; E={e12,…,e1i,…,eij,…,enn−1}<math><mrow is="true"><mi is="true">E</mi><mo is="true">=</mo><mo stretchy="false" is="true">{</mo><msub is="true"><mi is="true">e</mi><mn is="true">12</mn></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mi is="true">e</mi><mrow is="true"><mn is="true">1</mn><mi is="true">i</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mi is="true">e</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mi is="true">e</mi><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi><mo is="true">−</mo><mn is="true">1</mn></mrow></msub><mo stretchy="false" is="true">}</mo></mrow></math> is a set of edges between the service component nodes, in which the edge eij<math><mrow is="true"><msub is="true"><mi is="true">e</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></math> represents the link between SCi and SCj; and W={w12,…,w1i,…,wij,…,wnn−1}<math><mrow is="true"><mi is="true">W</mi><mo is="true">=</mo><mo stretchy="false" is="true">{</mo><msub is="true"><mi is="true">w</mi><mn is="true">12</mn></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mn is="true">1</mn><mi is="true">i</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi><mo is="true">−</mo><mn is="true">1</mn></mrow></msub><mo stretchy="false" is="true">}</mo></mrow></math> is a set of edges’ weights, in which the weight wij<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></math> is the value of the comprehensive correlation between SCi and SCj, i.e., wij=cij<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">=</mo><msub is="true"><mi is="true">c</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></math>, and it is also an real number attached to the edge eij<math><mrow is="true"><msub is="true"><mi is="true">e</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></math>. Fig. 3 depicts an example diagram of complex network model of the smart product service. The red node represents a service component, and the black line between two service components shows the link between the two components. The width of the line presents the correlation strength between the two linked nodes.
In this section, the traditional GN algorithm (Newman and Girvan, 2004) is modified to find the proper service module for smart product service network. First, the basic form of the GN algorithm is described as follows: (1) determine the edge betweenness score of all edges within the SPS network, and (2) find the edge that has the largest betweenness and eliminate this edge from the network, then (3) reload determination of edge betweenness for all unremoved edges, and (4) repeat from step 2 until the expected service module number is acquired or the maximum modularity is reached. Based on this procedure, the GN algorithm is modified with redefining the edge betweenness by introducing the edge weight (i.e., the comprehensive correlation between each pair of service components) in the calculation of betweenness. In the traditional GN algorithm, the edges with larger betweenness are selected to be removed, which means the connection between the pair of nodes linked with this edge is weaker. However, in the case of SPS network, the larger edge weight implies a stronger connection between this pair of service components, and thereby the edge should not be eliminated. If the edge weight is considered as a positive factor in the calculation of edge betweenness, the edges with higher weight will be removed, which is reversed with the actual situation of SPS modularization. To solve this problem, a modification method is proposed. First, the initial edge betweenness is obtained by using the original shortest-path betweenness method without considering the edge weight. Then, a new betweenness can be calculated through dividing the original betweenness by the edge weight. This new betweenness can serve to be the criterion to remove the edge. With this operation, the edge between the service components with a stronger correlation strength has a smaller possibility to be removed. Based on this modification, a revised GN algorithm is described as follows:
By repeating the process depicted in Algorithm 1 for all n source vertices (service components) in the SPS complex network, the score value for all vertices are assigned. Fig. 4(a) ∼ (b) present an example process to assign values i.e., distance and weight, to each vertex in an example network consisting of eight vertices among which vs is the source vertex.
Download : Download high-res image (225KB)Download : Download full-size image
By repeating the process depicted in Algorithm 2 for all n source vertices (service components) in the SPS complex network, the initial betweenness can be determined. Fig. 4(b) ∼ (c) present an example process to calculate the edge betweenness. Generally, in the traditional GN algorithm, the edge with the highest initial betweenness will be removed approaching to a partitioned SPS network. However, as mentioned above, in order to handle the actual situation of the SPS network, a new betweenness will be proposed based on the initial edge betweenness in the next step.
Download : Download high-res image (203KB)Download : Download full-size image
The revised edge betweenness is determined by follows:(20)BijR=Bij/wij<math><mrow is="true"><msubsup is="true"><mi is="true">B</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">R</mi></msubsup><mo is="true">=</mo><msub is="true"><mi is="true">B</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">/</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></math>where BijR<math><mrow is="true"><msubsup is="true"><mi is="true">B</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">R</mi></msubsup></mrow></math> is the revised edge betweenness and wij<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></math> is the edge weight.
Based on the output results of preceding step, the edge with the largest revised betweenness BijR<math><mrow is="true"><msubsup is="true"><mi is="true">B</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow><mi is="true">R</mi></msubsup></mrow></math> is identified and thus to be removed.
All the remaining edges and vertices in step 4 can be deemed an updated network, then this step is to reload determination of edge betweenness for all unremoved edges by repeating step 1 ∼ 3.
The output of the modified algorithm is in the form of a dendrogram which describes a global hierarchy of the possible module partitions for the SPS network (Newman and Girvan, 2004). The issue to be solved is how to recognize the best one from the possible partitions, i.e. where the dendrogram should be cut to acquire an optimal division of the network. According to (Newman, 2006; Newman and Girvan, 2004), the concept of modularity is proposed as a critical criterion to evaluate the quality of a specific partition of a network. Generally, the optimal partition is acquired when the corresponding modularity is the largest one over other partitions. The used modularity Q (Newman, 2006) in this section is defined as follows:(21)Q=14m∑ijAij−kikj2m(sisj+1)<math><mrow is="true"><mi is="true">Q</mi><mo is="true">=</mo><mfrac is="true"><mn is="true">1</mn><mrow is="true"><mn is="true">4</mn><mi is="true">m</mi></mrow></mfrac><munder is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></munder><mrow is="true"><mfenced open="(" close=")" is="true"><mrow is="true"><msub is="true"><mi is="true">A</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">−</mo><mfrac is="true"><mrow is="true"><msub is="true"><mi is="true">k</mi><mi is="true">i</mi></msub><msub is="true"><mi is="true">k</mi><mi is="true">j</mi></msub></mrow><mrow is="true"><mn is="true">2</mn><mi is="true">m</mi></mrow></mfrac></mrow></mfenced><mo stretchy="false" is="true">(</mo><msub is="true"><mi is="true">s</mi><mi is="true">i</mi></msub><msub is="true"><mi is="true">s</mi><mi is="true">j</mi></msub><mo is="true">+</mo><mn is="true">1</mn><mo stretchy="false" is="true">)</mo></mrow></mrow></math>where Aij is the element of the unweighted matrix of the adjacency matrix (i.e. comprehensive correlation matrix), which is calculated using Eq. (22); ki and kj separately denotes the degree of the vertex i (SCi) and vertex j (SCj), which can be determined as ki=∑jAij<math><mrow is="true"><msub is="true"><mi is="true">k</mi><mi is="true">i</mi></msub><mo is="true">=</mo><msub is="true"><mo is="true">∑</mo><mi is="true">j</mi></msub><mrow is="true"><msub is="true"><mi is="true">A</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></mrow></math>; m represents the total number of edges in the original network, which is equal to ∑iki/2<math><mrow is="true"><msub is="true"><mo is="true">∑</mo><mi is="true">i</mi></msub><mrow is="true"><msub is="true"><mi is="true">k</mi><mi is="true">i</mi></msub></mrow><mo is="true">/</mo><mn is="true">2</mn></mrow></math>; and sisj = 1 if the vertex i and vertex j are in the same module, otherwise sisj=-1.(22)Aij=1,ifwij≠0;0,ifwij=0.<math><mrow is="true"><msub is="true"><mi is="true">A</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">=</mo><mfenced open="{" close="" is="true"><mrow is="true"><mtable columnalign="center" displaystyle="true" is="true"><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><mn is="true">1</mn><mo is="true">,</mo></mrow></mtd><mtd columnalign="center" is="true"><mrow is="true"><mi is="true">i</mi><mi is="true">f</mi><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">≠</mo><mn is="true">0</mn><mo is="true">;</mo></mrow></mtd></mtr><mtr columnalign="center" is="true"><mtd columnalign="center" is="true"><mrow is="true"><mn is="true">0</mn><mo is="true">,</mo></mrow></mtd><mtd columnalign="center" is="true"><mrow is="true"><mi is="true">i</mi><mi is="true">f</mi><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">=</mo><mn is="true">0.</mn></mrow></mtd></mtr></mtable></mrow></mfenced></mrow></math>
Finally, by following the six steps above, a SPS component network can be completely partitioned into several SPS modules with the best modularity. The obtained partition scheme will provide basis for the further smart PSS configuration work.
In this section, the feasibility and effectiveness of the proposed modularization method are demonstrated through the method’s application into the design of smart maintenance service system for the gearbox of port container crane (PCC). A PCC manufacturer Z is a world class manufacturer of heavy construction machinery, who is committed to providing port customers with various types of port container cranes and the related service. The deep convergence of advanced smart technologies and traditional crane industry has boosted the company Z to transform its value propositions from product-sold to service-sold so as to obtain higher competiveness and increase the customers’ experience. PCC is a critical facility for the port, since its performance determine the operation condition of the port. Unexpected stoppage of the gearbox will cause high risk and operation cost for the PCC in the transportation of the goods between the freighters and ports. Timely repair and predictive maintenance can markedly reduce the occurrence frequency of the unexpected stoppage and their caused cost. Owing to the application of smart technologies, a smart maintenance service can be provided with the port operator in order to effectively prevent the unexpected failure and optimize PCC operation. However, the design of personalized maintenance service for each individual PCC customer is not an economic way. Therefore, company Z attempts to apply the SPS modularization method to acquire the optimal partition scheme for the smart gearbox maintenance service (SGMS) modules. The purpose of the application of the proposed method in the case study is to present its calculation process and validate its feasibility through some comparisons with other methods. The case study includes three parts: identification of SGMS components, correlation evaluation for SGMS components and partition of SGMS modules. The identification of SGMS components is conducted by field surveying the practical service process of the smart maintenance of company Z. Then, the proposed SPS blueprint is used for representing the SGMS operation process into detailed diagram. From the established CPS-based smart gearbox maintenance service blueprint, all the necessary SGMS components are thus identified. For the correlation evaluation for SGMS components, in order to collect the opinions from multiple stakeholders, a decision team consisting of 5 DMs is invited to conduct the evaluation. These DMs include 2 experienced PCC designers, 2 service experts and 1 PCC operator. After the questionnaires are collected, the rough-fuzzy comprehensive correlation matrix is constructed by transforming the group linguistic correlation judgement to rough-fuzzy numbers. Then, the rough-fuzzy matrix is converted into a complex network model by using the proposed method, and the final SGMS partition result is obtained by using the modified GN algorithm.
Considering the actual service process and resource of the smart gearbox maintenance of company Z, the CPS-based SPS blueprint is applied to display the general and typical operation process of smart gearbox maintenance service, as shown in Fig. 5. Fifty four SGMS components are identified with the proposed SPS blueprint, as shown in Table 3.
The proposed rough-fuzzy method is used to assess the correlation between each pair of the service components identified in Table 3. By applying Eq. (1)∼(15), the group linguistic evaluation matrices of the function correlation, service-flow correlation, smartness-flow correlation and resource correlation are separately transformed to the form of rough-fuzzy correlation matrix. Then, using the rough-fuzzy pair-wise comparison method, the weights of the function correlation, service-flow correlation, smartness-flow correlation and resource correlation are determined as 0.176, 0.494, 0.226 and 0.104, respectively. Finally, by using Eq. (17)∼(18), the crisp comprehensive correlation between each couple of service components is acquired in Table 4.
In accordance with the description in section 3.4.1, the obtained comprehensive correlation matrix of SGMS components can be used as the adjacency matrix of a weighted complex network model, as shown in Fig. 6. The node symbols refer to the SGMS components, and the edges denote the link between each pair of nodes. The correlation strength between the components is represented by the width of the edge in the network model. The greater the width, the stronger the correlation strength is.
By calculating the modified GN algorithm in MATLAB R2019a, the dendrogram of the SGMS modules and the partition modularity are presented in Fig. 7. The modularity variance graph shows that the modularity increase with the divisions’ number before the optimal division scheme is reached. One global peak appear at the optimal partition scheme, and then the modularity decreases with the increasing partitions. In this section, the modularization schemes with modularity Q2 = 0.223, Q4 = 0.220, Q6 = 0.320, Q8 = 0.277 and Q10 = 0.265 are presented in Table 5, where the subscript i of the symbol Q implies that there are i partitioned service modules in this scheme. The results show that the modularization scheme of SGMS modules with Q6 = 0.320 is the optimal one, and the corresponding partition diagram is shown in Fig. 9(a).
In this section, the feasibility and effectiveness of the proposed modularization framework is demonstrated through three comparisons with other methods. The first comparison is conducted to present the differences between the identification of SPS components with conventional service blueprint (Bitner et al., 2008), the product-extension service (PSE) blueprint (Song et al., 2015) and the proposed SPS blueprint. The second comparison serves to illustrate the different partition results caused by different correlation evaluation methods (i.e. crisp number-based, fuzzy number-based, rough number-based and the proposed rough-fuzzy number-based). The third comparison aims to uncover the differences between the modularization results of the classical GN algorithm (Newman and Girvan, 2004) and the proposed modified GN algorithm.
Compared with the traditional service blueprint (Bitner et al., 2008) and the PSE blueprint (Song et al., 2015), the proposed CPS-based SPS blueprint embeds the properties of smart capabilities and considers the changes of service operation under the application of smart technologies. The proposed blueprint can reflect the complex interactions between the physical product / service operation space and cyber product / service operation space. The comparative results in Table 6 shows that the proposed SPS blueprint presents more adaptiveness and feasibility to identify the smart service components in the context of smart PSS from three key aspects: blueprints structures, interaction presentation and application scope, compared with the traditional service blueprint and PSE blueprint.
This comparison mainly reveals the strength of the proposed rough-fuzzy number-based evaluation method in the manipulation of intrapersonal linguistic uncertainty and interpersonal preference diversity comparing with the crisp-based, fuzzy number-based and rough-based methods in the same case. The linguistic responses from multiple experts are respectively converted into an average number, triangular fuzzy number, rough number and rough-fuzzy number. In crisp-based approach, the judgements entered into the evaluation process are the arithmetical means of the five DMs’ initial scores. In the fuzzy-based approach, the group average fuzzy intervals number is acquired by calculating the arithmetical mean value of the group fuzzy judgements. Moreover, a rough procedure is adopted for aggregating group crisp judgements to inform the group average rough intervals number in the rough-based method.
Fig. 8 presents the relationship between the modularity and the modularization schemes with different methods. The abscissa MSi represents the modularization scheme with i service modules, and the ordinate denotes the modularity of the obtained partition scheme. The distribution curve marked as “rough-fuzzy correlation and modified GN” is obtained by using the proposed rough-fuzzy number-based evaluation method and the proposed modified GN algorithm. Similarly, the curves marked as crisp, fuzzy and rough correlation and modified GN are separately acquired by using the crisp number-based, fuzzy number-based and rough number-based evaluation methods, with the same modified GN algorithm. The results show that the modularity presented with the four evaluation methods have a similar change trend, i.e. the parabola going downwards in one direction. However, the optimal modularity obtained in the proposed rough-fuzzy method emerges at the modularization scheme with six service modules, while the optimal one acquired in the other three methods uniformly occur at the modularization schemes with four service modules. In addition, as shown in Fig. 9 (a), (c) and (d), the optimal modularization scheme with the proposed rough-fuzzy method is different with the ones obtained with the other three methods. For instance, the optimal scheme with the rough-fuzzy method have six service modules, among which the SGMS components SC43 and SC44 emerge in the same independent module. However, all the optimal schemes with the crisp-based, fuzzy-based and rough-based methods have four modules, among which SC43 and SC44 emerge in different modules. This difference is caused by the different evaluation results for the service components correlation with the four methods. Furthermore, the evaluation results are led by the different uncertainty manipulation mechanisms. According to Chen, et al. (Chen et al., 2020a), the group average rough-fuzzy interval comprehensively reflects the actual situation of both the range of intrapersonal linguistic vagueness and interpersonal preference diversity, while neither the single fuzzy method nor the single rough method can simultaneously manipulate the two types of uncertainty. It can be concluded that the proposed rough-fuzzy method allows for a more accurate and realistic description of the correlation between each pair of service components.
This comparison mainly uncovers the feasibility of the proposed modified GN algorithm for SPS modules partition. As shown in Fig. 8, the modularity with the modified GN presents totally different changing trend with the classical GN (Newman and Girvan, 2004). For the modified GN, the obtained modularity curve develop in a form of parabola going downwards in one direction and reach the largest peak value as 0.320 at the scheme with six modules. However, for the classical GN algorithm, the acquired modularity sharply rises to the largest peak value as 0.262 at the scheme with four modules and then fluctuates in a whole decreasing trend. In addition, the optimal modularization scheme with classical GN is determined as: Module 1 {SC11, SC13, SC14, SC15, SC17, SC18, SC19, SC20, SC21, SC22, SC23, SC24, SC25, SC26, SC27, SC28, SC29, SC30, SC31, SC32, SC33, SC34, SC35, SC36, SC37, SC40, SC44}, Module 2 {SC1, SC2, SC3, SC4, SC5, SC6, SC7, SC8, SC9, SC10, SC12, SC16, SC43, SC52}, Module 3 {SC38, SC39, SC41, SC42, SC46, SC47, SC48, SC49, SC50, SC51, SC53, SC54} and Module 4 {SC45} (see Fig. 9(b)). This scheme is totally different with the one obtained using the proposed modified GN, since the classical GN does not take the comprehensive correlation between the SPS components into account. In the classical GN algorithm, the initial edge betweenness without considering the edge weight are used to repeat the elimination of edge with highest betweenness. This operation is not suitable in the case of SPS modules partition, because it is contrary with the actual situation that the edge between the service components with a stronger correlation strength has a smaller possibility to be removed. Therefore, it can concluded that the proposed modified GN algorithm present more feasibility and accuracy to modularizing the SPS modules compared with the classical GN algorithm.
This study proposes a SPS modularization framework based on CPS-based SPS blueprint and weighted complex network theory. The CPS-based SPS blueprint is firstly applied to describe a whole SPS operation scenario and identify the SPS components. Then, the rough set theory and fuzzy set theory are integrated to analyze the actual comprehensive correlation between SPS components under an environment of intrapersonal and interpersonal uncertainties. The obtained comprehensive correlation matrix is converted into a weighted complex network model. It is notable that the complex network theory is firstly applied in the modularization of product service system. After that, a modified GN algorithm is developed to divide the network model into optimal partitions. Finally, the proposed framework is applied in a real case of smart gearbox service and thus verified to be feasible and effective through comparisons with other methods. The proposed SPS modularization framework has presented the following advantages. The proposed CPS-based SPS blueprint can reflect the complex interactions between the physical product / service operation space and cyber product / service operation space and thus facilitate the designers to fully discover the service components and identify their interdependences. The smartness-flow correlation is added as an evaluation criterion with considering both the physical material flow and the knowledge flow between the SPS components. The application of rough-fuzzy number combines the strength of fuzzy set in handling the intrapersonal linguistic vagueness and the merits of rough set in manipulating the interpersonal preference diversity. The presented evaluation method can provide a more accurate and realistic analysis results of the actual correlation. The established SPS components network model by using complex network theory provides a visualized representation of the correlation between all pairs of SPS components. This modeling method appear firstly in the field of product service modularization. Moreover, the proposed modified GN algorithm is adaptive and feasible to modularize the SPS components into optimal modules.
Although the proposed modularization framework presents several advantages, it still has some research limitation to be solved. Firstly, more empirical cases should be explored to acquire better validity of the CPS-based SPS blueprint for SPS components identification. Secondly, the individual weight of each expert is not considered in the correlation evaluation for service components. One future work can be carried out to integrate the weight into the evaluation process. Also, the robustness and dynamics of the SPS network can be explored to address the dynamic features of product service requirement. In addition, the proposed framework can be implemented as a computer software for convenient practical application and spreads in industry.
The authors report no declarations of interest.
The author would like to thank National Science and Technology Major Project of China (Grant No. 2017-I-0007-0008, Grant No. 2017-I-0011-0012), National Natural Science Foundation of China (Grant No. 71632008) and China Scholarship Council (Grant No. 201906230054) for the funding support to this research. In addition, the authors also appreciate the editor and anonymous reviewers for their helpful comments and suggestions on this article.