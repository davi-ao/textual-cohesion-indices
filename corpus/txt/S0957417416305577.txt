When analyzing multi-typed objects and multi-typed relations in complex information networks, identifying rare, interesting and outstanding objects, patterns or subgraphs is at least, or even more meaningful and significant than knowing the common data distribution or models. Outlier detection, as an important branch in the field of data mining, can be applied to extract the objects, patterns or subgraphs which significantly deviate from others in the network. One of the widely accepted definition of outlier is provided by Hawkins (1980): An outlier is an observation that deviates so much from other observations as to arouse suspicion that it is generated by a different mechanism. Most traditional outlier detection methods are only applicable to single-typed networks. When it comes to complex networks (Gupta et al., 2012a, Gupta et al., 2012b, Dalmia et al., 2015, Gupta et al., 2014), there are multi-typed objects instead of single-typed objects and each type of objects can be an outlier. For example, in bibliographic network, either an author or a research area can be an outlier.
Quite different from most existing work that identifying outliers in networks (Aggarwal and Sathe, 2015, Angiulli and Fassetti, 2016, Dufrenois and Noyer, 2016, Fusters et al., 2013, Maervoet et al., 2012), our proposed work aims at discovering outlier pairs. Compared with the definition of outlier, we provide a definition of outlier pair. An outlier pair is two specific objects whose link structure similarity deviates so much from semantic relationship similarity as to arouse suspicion that they are generated by a different mechanism. When mining information from complex networks, it is essential to consider the link relation between objects and capture their semantic relations. How about there is vast difference of two objects between link structure and semantic relationship? Either of the two objects in an outlier pair may be normal from the perspective of link structure or semantic relationship. The two objects are suspicious when their structure similarity and semantic similarity are quite different. For example, when detecting communities or extracting domain experts, we probably treat link structure and the contents in the network as the major considerations in the process of data analysis. If two authors often collaborate on a paper and their research areas are almost the same, the two authors, of course, can be partitioned to the same community. Likewise, if two actors often co-star in a movie, and the film types, that the actors are good at, are similar, then the two actors can be classified into the same group. However, once there is vast difference between link structure similarity and semantic relationship similarity, say, two authors often collaborate on a paper but their research areas are totally different, at this time, the two authors can be regarded as an outlier pair, instead of an outlier. Perhaps two authors’ research areas are almost the same but they never collaborate on a paper, then we can recommend them to each other to see whether they can carry out academic exchanges. The two authors are also regarded as an outlier pair.
Motivated by the above ideas, we propose an outlier pair detection method in complex network. We first formalize the outlier pair detection problem w.r.t the vast differences between link structure and semantic relationship. Then, we introduce a novel notion of link structure model to measure the proximity among objects based on their structural distribution. To calculate the semantic similarity among objects, a k-step index algorithm is proposed to obtain the term weighting for each object. Finally, the Frobenius norm of a matrix and linear transformation are combined to rank the outlierness of objects in the complex networks. We conduct several experiments on AMiner and Yahoo!Movies to verify the effectiveness of the proposed LSOutPair based on link structure and semantic relationship. The experimental results show that our proposed LSOutPair can achieve high accuracy.
The contributions of this paper are summarized as follows.
We introduce the notion of outlier pair detection in complex network by combining the link structure and semantic relationship among objects.
The concept called k-step index is defined to calculate the term weighting of the target objects in the complex network.
We propose an LSModel to rank the candidates’ differences between link structure and semantic relationship and obtain the top-K outlier pairs.
Extensive experiments on two real datasets demonstrate the effectiveness of our proposed method.
The rest of this paper is organized as follows. We discuss the related work in Section 2. Section 3 presents the definitions and concepts used in this paper. The overall framework of our proposed LSOutPair is also illustrated in Section 3. We discuss the link structure model and semantic relationship model in Section 4. Section 5 describes how to detect the outlier pairs using the LSModel. Several comprehensive experiments are performed to evaluate the effectiveness and efficiency of our proposed method in Section 6 in which the experiment settings, performance metrics, datasets and results are all provided. Section 7 discusses the main advantages and limitations of LSOutPair in comparison with the existing methods. Section 8 draws the conclusions.
Outlier detection plays an important role in complex network. Most existing work discovers outliers in the form of single vertex or subgraphs in such networks. In what follows, we give an overview of previous work on outlier detection and its applications.
Mining outlier of single vertex. For this kind of outliers, their attributes or community distribution may be different from others. The following techniques can be used to detect outliers in form of single vertex. Yao, Mark, and Rabbat (2012) described an anomaly detection method combining PageRank algorithm and proximity graphs. They utilized a variant of the PageRank algorithm to generate an outlier score and judge whether each data point was anomalous. Rossi, Gallagher, Neville, and Henderson (2013) proposed a dynamic outlier detection approach which studied the temporal behavior of nodes in the graph. According to the temporal behaviors of individual nodes, this model can detect anomalous transitions and interesting patterns. Gupta, Gao, Aggarwal, and Han (2013a) defined a novel concept called Community Distribution Outliers (CDOutliers) which used non-negative matrix factorization to detect objects whose community distribution did not follow other popular community distribution patterns. They also extracted outliers in the form of single vertex in heterogeneous networks. Cao, Wei, Yang, and Rundensteiner (2015) presented an online outlier exploration platform, called ONION, that could detect individual outliers over large datasets.
Mining outlier of subgraphs. There are about two kinds of outliers in the form of subgraphs. The one is that any one of objects in the subgraph is a normal object but multiple objects showing the same property can be regarded as outliers. The other one is the outliers in a subgraph can be affected by the connectivity structure. The following techniques can be applied to detect these kinds of outliers. Akoglu, Tong, and Koutra (2014) made a comprehensive survey about graph-based anomaly detection. The survey described lots of the state-of-the-art methods for outlier data represented as graphs. Zhuang et al. (2014) proposed a query-based subnetwork outlier detection method for heterogeneous networks. They defined the notion of subnetwork similarity and ranked subnetworks according to the outlierness. The outliers are represented by subgraphs.
There are also other forms of outliers such as outlier patterns (Dai, Zhu, Lim, & Pang, 2015), outlier correlations (Karppa, Kaski, & Kohonen, 2016), video anomaly detection (Zhang, Lu, Zhang, & Ruan, 2016) and so on. Dai et al. (2015) defined extreme rank anomaly collection (ERAC) to discover objects exhibiting similar extreme behaviors. It discovered top-K anomalous collections in the datasets. Karppa et al. (2016) proposed a faster subquadratic algorithm to find outlier correlations of vectors. They computed the inner product of vectors to find outlier pairs. Representing multi-typed objects using one vector is not applicable during the process of calculation. Therefore, the algorithm can be used in single-typed networks instead of multi-typed networks. Angiulli, Basta, Lodi, and Sartori (2013) proposed a distributed outlier detection method. The method applied parallel computation to increase the efficiency when performing outlier detection. The experimental results show that their algorithm has good scalability with the increasing number of nodes. In addition, outlier detection has a wide variety of applications such as intrusion detection (Kim, Lee, & Kim, 2014), anomalous maritime trajectory (Lei, 2016), spam detection (Dai et al., 2015, Xie et al., 2007), and database activity monitoring (Aydin et al., 2015, Kim et al., 2013), and so on.
Although there are many attempts and achievements on outlier detection in the form of single vertex or subgraphs, few of them perform outlier pair detection. The proposed work in this paper detects outlier pairs in complex network combining the link structure and semantic relationship. The vast differences between link structure similarity and semantic similarity can be applied to rank outlierness of outlier pairs in the network.
In this section, we start with some formalized problem definitions and some preliminary concepts. Then, we describe the overall framework of our proposed outlier pair detection model.
Definition 1

(Linear Transformation) (Leon, 2011). A Mapping M from a vector space X into a vector space Y is said to be a linear transformation if M(αx1+βx2)=αM(x1)+βM(x2)<math><mrow is="true"><mi is="true">M</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">x</mi><mn is="true">1</mn></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">x</mi><mn is="true">2</mn></msub></mrow><mo stretchy="true" is="true">)</mo></mrow><mo is="true">=</mo><mi is="true">α</mi><mspace width="0.33em" is="true"></mspace><mi is="true">M</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><msub is="true"><mi is="true">x</mi><mn is="true">1</mn></msub><mo stretchy="true" is="true">)</mo></mrow><mo is="true">+</mo><mi is="true">β</mi><mi is="true">M</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><msub is="true"><mi is="true">x</mi><mn is="true">2</mn></msub><mo stretchy="true" is="true">)</mo></mrow></mrow></math>for all x1, x2 ∈ X and all scalars α and β.
(Linear Transformation) (Leon, 2011). A Mapping M from a vector space X into a vector space Y is said to be a linear transformation if M(αx1+βx2)=αM(x1)+βM(x2)<math><mrow is="true"><mi is="true">M</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">x</mi><mn is="true">1</mn></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">x</mi><mn is="true">2</mn></msub></mrow><mo stretchy="true" is="true">)</mo></mrow><mo is="true">=</mo><mi is="true">α</mi><mspace width="0.33em" is="true"></mspace><mi is="true">M</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><msub is="true"><mi is="true">x</mi><mn is="true">1</mn></msub><mo stretchy="true" is="true">)</mo></mrow><mo is="true">+</mo><mi is="true">β</mi><mi is="true">M</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><msub is="true"><mi is="true">x</mi><mn is="true">2</mn></msub><mo stretchy="true" is="true">)</mo></mrow></mrow></math>for all x1, x2 ∈ X and all scalars α and β.
Definition 2

(Outlier Pair). Given an object pair (i, j), the link structure similarity of (i, j) is represented by lij and the semantic relationship similarity is represented by sij. An object pair (i, j) is said to be an outlier pair if the difference between lij and sij, that is, |lij−sij|<math><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">−</mo><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mrow is="true"><mo is="true">|</mo></mrow></mrow></math>, deviates so much from other object pairs’ differences between link structure similarity and semantic relationship similarity.
(Outlier Pair). Given an object pair (i, j), the link structure similarity of (i, j) is represented by lij and the semantic relationship similarity is represented by sij. An object pair (i, j) is said to be an outlier pair if the difference between lij and sij, that is, |lij−sij|<math><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">−</mo><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mrow is="true"><mo is="true">|</mo></mrow></mrow></math>, deviates so much from other object pairs’ differences between link structure similarity and semantic relationship similarity.
Given n objects in a complex network as input, calculate link structure similarity and semantic relationship similarity, respectively. Find the top-K values of the differences between link structure similarity and semantic relationship similarity of two objects i and j. The top-K pairs (i, j) are considered to be outlier pairs.
Definition 3

(Outlier Pair Matrix). Assume L=(lij)<math><mrow is="true"><mi is="true">L</mi><mo is="true">=</mo><mo is="true">(</mo><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">)</mo></mrow></math> and S=(sij)<math><mrow is="true"><mi is="true">S</mi><mo is="true">=</mo><mo is="true">(</mo><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">)</mo></mrow></math> are both n × n matrices representing link structure similarity and semantic relationship similarity, respectively. In addition, ɛ∥αLn×n∥F−∥βSn×n∥F<ɛ<math><mrow is="true"><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">−</mo><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">β</mi><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">&lt;</mo><mrow is="true"><mi is="true">ɛ</mi></mrow></mrow></math>. Outlier pair matrix Mos=(mij)nn<math><mrow is="true"><msub is="true"><mi is="true">M</mi><mrow is="true"><mi is="true">o</mi><mi is="true">s</mi></mrow></msub><mo is="true">=</mo><msub is="true"><mrow is="true"><mo is="true">(</mo><msub is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">)</mo></mrow><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi></mrow></msub></mrow></math> is the absolute value of αL−βS<math><mrow is="true"><mi is="true">α</mi><mi mathvariant="bold-italic" is="true">L</mi><mo is="true">−</mo><mi is="true">β</mi><mi mathvariant="bold-italic" is="true">S</mi></mrow></math> whose (i, j) entry is |lij−sij|<math><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><mrow is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">−</mo><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow><mrow is="true"><mo is="true">|</mo></mrow></mrow></math> for each ordered pair (i, j). α and β are two scalars which adjust the values in L and S.
(Outlier Pair Matrix). Assume L=(lij)<math><mrow is="true"><mi is="true">L</mi><mo is="true">=</mo><mo is="true">(</mo><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">)</mo></mrow></math> and S=(sij)<math><mrow is="true"><mi is="true">S</mi><mo is="true">=</mo><mo is="true">(</mo><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">)</mo></mrow></math> are both n × n matrices representing link structure similarity and semantic relationship similarity, respectively. In addition, ɛ∥αLn×n∥F−∥βSn×n∥F<ɛ<math><mrow is="true"><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">−</mo><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">β</mi><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">&lt;</mo><mrow is="true"><mi is="true">ɛ</mi></mrow></mrow></math>. Outlier pair matrix Mos=(mij)nn<math><mrow is="true"><msub is="true"><mi is="true">M</mi><mrow is="true"><mi is="true">o</mi><mi is="true">s</mi></mrow></msub><mo is="true">=</mo><msub is="true"><mrow is="true"><mo is="true">(</mo><msub is="true"><mi is="true">m</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">)</mo></mrow><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi></mrow></msub></mrow></math> is the absolute value of αL−βS<math><mrow is="true"><mi is="true">α</mi><mi mathvariant="bold-italic" is="true">L</mi><mo is="true">−</mo><mi is="true">β</mi><mi mathvariant="bold-italic" is="true">S</mi></mrow></math> whose (i, j) entry is |lij−sij|<math><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><mrow is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">−</mo><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow><mrow is="true"><mo is="true">|</mo></mrow></mrow></math> for each ordered pair (i, j). α and β are two scalars which adjust the values in L and S.
For example, IfL3×3=[237951648]andS3×3=[1532212193](α=β=1),<math><mrow is="true"><mi is="true">If</mi><mspace width="0.16em" is="true"></mspace><msub is="true"><mi is="true">L</mi><mrow is="true"><mn is="true">3</mn><mo is="true">×</mo><mn is="true">3</mn></mrow></msub><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd is="true"><mn is="true">2</mn></mtd><mtd is="true"><mn is="true">3</mn></mtd><mtd is="true"><mn is="true">7</mn></mtd></mtr><mtr is="true"><mtd is="true"><mn is="true">9</mn></mtd><mtd is="true"><mn is="true">5</mn></mtd><mtd is="true"><mn is="true">1</mn></mtd></mtr><mtr is="true"><mtd is="true"><mn is="true">6</mn></mtd><mtd is="true"><mn is="true">4</mn></mtd><mtd is="true"><mn is="true">8</mn></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow><mspace width="0.16em" is="true"></mspace><mi is="true">and</mi><mspace width="0.16em" is="true"></mspace><mspace width="0.33em" is="true"></mspace><msub is="true"><mi is="true">S</mi><mrow is="true"><mn is="true">3</mn><mo is="true">×</mo><mn is="true">3</mn></mrow></msub><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd is="true"><mn is="true">1</mn></mtd><mtd is="true"><mn is="true">5</mn></mtd><mtd is="true"><mn is="true">3</mn></mtd></mtr><mtr is="true"><mtd is="true"><mn is="true">2</mn></mtd><mtd is="true"><mn is="true">2</mn></mtd><mtd is="true"><mn is="true">12</mn></mtd></mtr><mtr is="true"><mtd is="true"><mn is="true">1</mn></mtd><mtd is="true"><mn is="true">9</mn></mtd><mtd is="true"><mn is="true">3</mn></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow><mrow is="true"><mo is="true">(</mo><mi is="true">α</mi><mo is="true">=</mo><mi is="true">β</mi><mo is="true">=</mo><mn is="true">1</mn><mo is="true">)</mo></mrow><mo is="true">,</mo></mrow></math>then Mos=[|2−1||3−5||7−3||9−2||5−2||1−12||6−1||4−9||8−3|]=[1247311555]<math><mrow is="true"><msub is="true"><mi is="true">M</mi><mrow is="true"><mi is="true">o</mi><mi is="true">s</mi></mrow></msub><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">2</mn><mo is="true">−</mo><mn is="true">1</mn></mrow><mo is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">3</mn><mo is="true">−</mo><mn is="true">5</mn></mrow><mo is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">7</mn><mo is="true">−</mo><mn is="true">3</mn></mrow><mo is="true">|</mo></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">9</mn><mo is="true">−</mo><mn is="true">2</mn></mrow><mo is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">5</mn><mo is="true">−</mo><mn is="true">2</mn></mrow><mo is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">1</mn><mo is="true">−</mo><mn is="true">12</mn></mrow><mo is="true">|</mo></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">6</mn><mo is="true">−</mo><mn is="true">1</mn></mrow><mo is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">4</mn><mo is="true">−</mo><mn is="true">9</mn></mrow><mo is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo is="true">|</mo><mrow is="true"><mn is="true">8</mn><mo is="true">−</mo><mn is="true">3</mn></mrow><mo is="true">|</mo></mrow></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd is="true"><mn is="true">1</mn></mtd><mtd is="true"><mn is="true">2</mn></mtd><mtd is="true"><mn is="true">4</mn></mtd></mtr><mtr is="true"><mtd is="true"><mn is="true">7</mn></mtd><mtd is="true"><mn is="true">3</mn></mtd><mtd is="true"><mn is="true">11</mn></mtd></mtr><mtr is="true"><mtd is="true"><mn is="true">5</mn></mtd><mtd is="true"><mn is="true">5</mn></mtd><mtd is="true"><mn is="true">5</mn></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow></mrow></math>.
In the real world datasets, the matrix Mos is a symmetric matrix. The values on the diagonal line are zero. Fig. 1 shows the framework of our proposed LSOutPair. We calculate the similarity between objects in complex network from two perspectives. The first one is the link structure similarity between objects, which is shown in the left part of Fig. 1. The second one is the semantic relationship similarity between objects, which is shown in the right part of Fig. 1. Then, the Frobenius norm and linear transformation is combined to get the vast differences between matrices L and S. The top-K outlier pairs can be obtained through adjusting the parameters α and β.
Different from traditional outlier detection, which discovers objects whose attributes or data distribution are significantly different from others, we aim to detect outlier pairs. The definition outlier pairs represent a novel type of outliers considering both the link structure similarity and semantic relationship similarity. In this section, we detail the Link Structure Model and Semantic Relationship Model (LSModel), respectively. The outlier pair detection method using LSModel is devoted in Section 5.
Generally, multi-typed objects, connected by multi-typed edges representing relations between objects, can form complex information networks. Some researchers delve into the link structure to discover similar or anomalous objects from the whole network. Some other researchers use the content information related to the objects to explore the potential semantic relationship among them. However, once there is a link or a short path between two objects but there is almost no semantic relationship between them, we regard this kind of data pairs as outlier pairs. In what follows, we propose a link structure model to describe the link similarity between objects.
An adjacent square matrix L of length n on a network G consists of target objects and aims to obtain the link similarity according to their connection information. For example, in a bibliographic network, authors can be regarded as target objects. The link similarity between them can be obtained according to the co-author information. In a movie network, actors also can be regarded as target objects. We can get the link similarity between them according to their collaboration information. Assume that there are n authors in a bibliographic network. L is an n by n matrix that describes the link structure similarity between any two authors. Thus, Ln×n=[l1l2⋮ln]=[l11l12⋯l1nl21l22⋯l2n⋮⋮⋯⋮ln1ln2⋯lnn]<math><mrow is="true"><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd is="true"><mtable is="true"><mtr is="true"><mtd is="true"><msub is="true"><mi mathvariant="bold-italic" is="true">l</mi><mn is="true">1</mn></msub></mtd></mtr><mtr is="true"><mtd is="true"><msub is="true"><mi mathvariant="bold-italic" is="true">l</mi><mn is="true">2</mn></msub></mtd></mtr></mtable></mtd></mtr><mtr is="true"><mtd is="true"><mtable is="true"><mtr is="true"><mtd is="true"><mo is="true">⋮</mo></mtd></mtr><mtr is="true"><mtd is="true"><msub is="true"><mi mathvariant="bold-italic" is="true">l</mi><mi mathvariant="bold-italic" is="true">n</mi></msub></mtd></mtr></mtable></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd columnalign="left" is="true"><msub is="true"><mi is="true">l</mi><mn is="true">11</mn></msub></mtd><mtd is="true"><msub is="true"><mi is="true">l</mi><mn is="true">12</mn></msub></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow></msub></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><msub is="true"><mi is="true">l</mi><mn is="true">21</mn></msub></mtd><mtd is="true"><msub is="true"><mi is="true">l</mi><mn is="true">22</mn></msub></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow></msub></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow></msub></mtd><mtd is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow></msub></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow></mrow></math>where (1)lij={|δij||δi·∪δ·j|+1N∑r=1n|δir∪δrj||δr·|i≠j0i=j<math><mrow is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">{</mo><mtable is="true"><mtr is="true"><mtd is="true"><mrow is="true"><mfrac is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo stretchy="true" is="true">|</mo></mrow><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">i</mi><mo is="true">·</mo></mrow></msub><mo is="true">∪</mo><msub is="true"><mi is="true">δ</mi><mrow is="true"><mo is="true">·</mo><mi is="true">j</mi></mrow></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mfrac><mo is="true">+</mo><mfrac is="true"><mn is="true">1</mn><mi is="true">N</mi></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">r</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">n</mi></munderover><mfrac is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">i</mi><mi is="true">r</mi></mrow></msub><mo is="true">∪</mo><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">r</mi><mi is="true">j</mi></mrow></msub></mrow><mo stretchy="true" is="true">|</mo></mrow><mrow is="true"><mo stretchy="true" is="true">|</mo><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">r</mi><mo is="true">·</mo></mrow></msub><mo stretchy="true" is="true">|</mo></mrow></mfrac></mrow></mtd><mtd is="true"><mrow is="true"><mi is="true">i</mi><mo is="true">≠</mo><mi is="true">j</mi></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mn is="true">0</mn><mspace width="0.33em" is="true"></mspace></mrow></mtd><mtd is="true"><mrow is="true"><mi is="true">i</mi><mo is="true">=</mo><mi is="true">j</mi><mspace width="0.33em" is="true"></mspace></mrow></mtd></mtr></mtable></mrow></mrow></math>subject to the following conditionsr≠i,r≠jδir≠∅andδrj≠∅<math><mtable is="true"><mtr is="true"><mtd columnalign="left" is="true"><mrow is="true"><mi is="true">r</mi><mo is="true">≠</mo><mi is="true">i</mi><mo is="true">,</mo><mi is="true">r</mi><mo is="true">≠</mo><mi is="true">j</mi></mrow></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><mrow is="true"><mspace width="0.33em" is="true"></mspace><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">i</mi><mi is="true">r</mi></mrow></msub><mo is="true">≠</mo><mi is="true">∅</mi><mspace width="0.16em" is="true"></mspace><mi is="true">and</mi><mspace width="0.16em" is="true"></mspace><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">r</mi><mi is="true">j</mi></mrow></msub><mo is="true">≠</mo><mi is="true">∅</mi></mrow></mtd></mtr></mtable></math>δij denotes the set of paper ID that author ai and author aj appear together. δi · represents the set of paper ID including author ai. δ· j represents the set of paper ID including author aj. N is the sum of r that satisfies δir ≠ ∅ and δrj ≠ ∅. It can been seen from Eq. (1) that lij is equal to lji, so Ln × n is symmetric (LT=L<math><mrow is="true"><msup is="true"><mi is="true">L</mi><mi is="true">T</mi></msup><mo is="true">=</mo><mi is="true">L</mi></mrow></math>). |δij||δi·∪δ·j|<math><mfrac is="true"><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mrow is="true"><mo is="true">|</mo></mrow></mrow><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><mrow is="true"><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">i</mi><mo is="true">·</mo></mrow></msub><mo is="true">∪</mo><msub is="true"><mi is="true">δ</mi><mrow is="true"><mo is="true">·</mo><mi is="true">j</mi></mrow></msub></mrow><mrow is="true"><mo is="true">|</mo></mrow></mrow></mfrac></math> component reflects the importance of direct co-authors. The more papers two authors collaborate on, the higher link structure similarity they have. Then, ∑r=1n|δir∪δrj||δr·|<math><mrow is="true"><msubsup is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">r</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">n</mi></msubsup><mfrac is="true"><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><mrow is="true"><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">i</mi><mi is="true">r</mi></mrow></msub><mo is="true">∪</mo><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">r</mi><mi is="true">j</mi></mrow></msub></mrow><mrow is="true"><mo is="true">|</mo></mrow></mrow><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">r</mi><mo is="true">·</mo></mrow></msub><mrow is="true"><mo is="true">|</mo></mrow></mrow></mfrac></mrow></math> component measures the number of indirect collaboration between author ai and author aj. It reflects the probability of future academic exchanges between the two authors. That is, if ai and aj both collaborate with ar, ai and aj will probably carry on academic exchanges and collaborate on a paper sometime. For example, Table 1 lists 10 records representing 10 papers written by several authors. The link structure similarity between authors a3 and a6 is calculated as follows. Since lij is subject to the two conditions above, ∑r=1n|δir∪δrj||δr·|<math><mrow is="true"><msubsup is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">r</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">n</mi></msubsup><mfrac is="true"><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><mrow is="true"><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">i</mi><mi is="true">r</mi></mrow></msub><mo is="true">∪</mo><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">r</mi><mi is="true">j</mi></mrow></msub></mrow><mrow is="true"><mo is="true">|</mo></mrow></mrow><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><msub is="true"><mi is="true">δ</mi><mrow is="true"><mi is="true">r</mi><mo is="true">·</mo></mrow></msub><mrow is="true"><mo is="true">|</mo></mrow></mrow></mfrac></mrow></math> component of l3, 6 contains five parts (r = 1,2,4,7,11). l3,6={P8,P10}{P1,P8,P9,P10}∪{P3,P4,P8,P10}+15×{{{P1,P9,P10}∪{P4,P10}{P1,P2,P4,P9,P10}}r=1+{{P1,P9}∪{P4}{P1,P2,P4,P5,P6,P7,P9}}r=2+{{P1,P9}∪{P3,P4}{P1,P2,P3,P4,P7,P9}}r=4+{{P10}∪{P3,P10}{P3,P10}}r=7+{{P8}∪{P8}{P8}}r=11}=26+15{45+37+46+22+11}=1.11<math><mtable displaystyle="true" is="true"><mtr is="true"><mtd columnalign="right" is="true"><mrow is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mn is="true">3</mn><mo is="true">,</mo><mn is="true">6</mn></mrow></msub><mspace width="-0.16em" is="true"></mspace></mrow></mtd><mtd is="true"><mo is="true">=</mo></mtd><mtd columnalign="left" is="true"><mrow is="true"><mspace width="-0.16em" is="true"></mspace><mfrac is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">8</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow><mrow is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">8</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">9</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow><mo is="true">∪</mo><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">3</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">4</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">8</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow></mrow></mfrac><mo is="true">+</mo><mfrac is="true"><mn is="true">1</mn><mn is="true">5</mn></mfrac></mrow></mtd></mtr><mtr is="true"><mtd is="true"></mtd><mtd is="true"></mtd><mtd columnalign="left" is="true"><mrow is="true"><mspace width="-0.16em" is="true"></mspace><mo is="true">×</mo><mspace width="-0.16em" is="true"></mspace><mrow is="true"><mo stretchy="true" is="true">{</mo><mspace width="-0.16em" is="true"></mspace><mtable is="true"><mtr is="true"><mtd columnalign="left" is="true"><mrow is="true"><msub is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mfrac is="true"><mrow is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">9</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow><mo is="true">∪</mo><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">4</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow></mrow><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">2</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">4</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">9</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow></mfrac><mo stretchy="true" is="true">}</mo></mrow><mrow is="true"><mi is="true">r</mi><mo is="true">=</mo><mn is="true">1</mn></mrow></msub><mo is="true">+</mo><msub is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mfrac is="true"><mrow is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">9</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow><mo is="true">∪</mo><mrow is="true"><mo stretchy="true" is="true">{</mo><msub is="true"><mi is="true">P</mi><mn is="true">4</mn></msub><mo stretchy="true" is="true">}</mo></mrow></mrow><mrow is="true"><mo is="true">{</mo><msub is="true"><mi is="true">P</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">2</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">4</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">5</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">6</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mrow is="true"><mspace width="0.33em" is="true"></mspace><mn is="true">7</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">9</mn></msub><mo is="true">}</mo></mrow></mfrac><mo stretchy="true" is="true">}</mo></mrow><mrow is="true"><mi is="true">r</mi><mo is="true">=</mo><mn is="true">2</mn></mrow></msub></mrow></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><mrow is="true"><mo is="true">+</mo><mspace width="-0.16em" is="true"></mspace><msub is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mfrac is="true"><mrow is="true"><mrow is="true"><mo is="true">{</mo><msub is="true"><mi is="true">P</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">9</mn></msub><mo is="true">}</mo></mrow><mo is="true">∪</mo><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">3</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">4</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow></mrow><mrow is="true"><mo is="true">{</mo><msub is="true"><mi is="true">P</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">2</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">3</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">4</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mrow is="true"><mspace width="0.33em" is="true"></mspace><mn is="true">7</mn></mrow></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">9</mn></msub><mo is="true">}</mo></mrow></mfrac><mo stretchy="true" is="true">}</mo></mrow><mrow is="true"><mi is="true">r</mi><mo is="true">=</mo><mn is="true">4</mn></mrow></msub><mo is="true">+</mo><msub is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mfrac is="true"><mrow is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub><mo stretchy="true" is="true">}</mo></mrow><mo is="true">∪</mo><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">3</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow></mrow><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><msub is="true"><mi is="true">P</mi><mn is="true">3</mn></msub><mo is="true">,</mo><msub is="true"><mi is="true">P</mi><mn is="true">10</mn></msub></mrow><mo stretchy="true" is="true">}</mo></mrow></mfrac><mo stretchy="true" is="true">}</mo></mrow><mrow is="true"><mi is="true">r</mi><mo is="true">=</mo><mn is="true">7</mn></mrow></msub><mo is="true">+</mo><msub is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><mfrac is="true"><mrow is="true"><mrow is="true"><mo stretchy="true" is="true">{</mo><msub is="true"><mi is="true">P</mi><mn is="true">8</mn></msub><mo stretchy="true" is="true">}</mo></mrow><mo is="true">∪</mo><mrow is="true"><mo stretchy="true" is="true">{</mo><msub is="true"><mi is="true">P</mi><mn is="true">8</mn></msub><mo stretchy="true" is="true">}</mo></mrow></mrow><mrow is="true"><mo stretchy="true" is="true">{</mo><msub is="true"><mi is="true">P</mi><mn is="true">8</mn></msub><mo stretchy="true" is="true">}</mo></mrow></mfrac><mo stretchy="true" is="true">}</mo></mrow><mrow is="true"><mi is="true">r</mi><mo is="true">=</mo><mn is="true">11</mn></mrow></msub></mrow></mtd></mtr></mtable><mo stretchy="true" is="true">}</mo></mrow></mrow></mtd></mtr><mtr is="true"><mtd is="true"></mtd><mtd is="true"><mo is="true">=</mo></mtd><mtd columnalign="left" is="true"><mrow is="true"><mfrac is="true"><mn is="true">2</mn><mn is="true">6</mn></mfrac><mo is="true">+</mo><mfrac is="true"><mn is="true">1</mn><mn is="true">5</mn></mfrac><mrow is="true"><mo stretchy="true" is="true">{</mo><mrow is="true"><mfrac is="true"><mn is="true">4</mn><mn is="true">5</mn></mfrac><mo is="true">+</mo><mfrac is="true"><mn is="true">3</mn><mn is="true">7</mn></mfrac><mo is="true">+</mo><mfrac is="true"><mn is="true">4</mn><mn is="true">6</mn></mfrac><mo is="true">+</mo><mfrac is="true"><mn is="true">2</mn><mn is="true">2</mn></mfrac><mo is="true">+</mo><mfrac is="true"><mn is="true">1</mn><mn is="true">1</mn></mfrac></mrow><mo stretchy="true" is="true">}</mo></mrow><mo is="true">=</mo><mn is="true">1.11</mn></mrow></mtd></mtr></mtable></math>
Only considering link structure on a complex network is inaccurate and not comprehensive. In this subsection, we define k-step index to compute the term weighting and focus on how to use k-step index to construct semantic relationship model. The attributes compose one or several large graphs representing the closeness degree between them. The objects can have their own term weighting representation through calculating the frequency of attributes and the closeness degree between them.
We take the bibliographic network as an example. An adjacent square matrix S, which consists of the same target objects with matrix L, is built to store the semantic relationship similarity between target objects. Thus, Sn×n=[s1s2⋮sn]=[s11s12⋯s1ns21s22⋯s2n⋮⋮⋯⋮sn2sn2⋯snn]<math><mrow is="true"><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd is="true"><mtable is="true"><mtr is="true"><mtd is="true"><msub is="true"><mi mathvariant="bold-italic" is="true">s</mi><mn is="true">1</mn></msub></mtd></mtr><mtr is="true"><mtd is="true"><msub is="true"><mi mathvariant="bold-italic" is="true">s</mi><mn is="true">2</mn></msub></mtd></mtr></mtable></mtd></mtr><mtr is="true"><mtd is="true"><mtable is="true"><mtr is="true"><mtd is="true"><mo is="true">⋮</mo></mtd></mtr><mtr is="true"><mtd is="true"><msub is="true"><mi mathvariant="bold-italic" is="true">s</mi><mi mathvariant="bold-italic" is="true">n</mi></msub></mtd></mtr></mtable></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd columnalign="left" is="true"><msub is="true"><mi is="true">s</mi><mn is="true">11</mn></msub></mtd><mtd is="true"><msub is="true"><mi is="true">s</mi><mn is="true">12</mn></msub></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><msub is="true"><mi is="true">s</mi><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow></msub></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><msub is="true"><mi is="true">s</mi><mn is="true">21</mn></msub></mtd><mtd is="true"><msub is="true"><mi is="true">s</mi><mn is="true">22</mn></msub></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><msub is="true"><mi is="true">s</mi><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow></msub></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow></msub></mtd><mtd is="true"><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow></msub></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow></mrow></math>where sij represents the semantic relationship similarity between author ai and author aj. Then, we detail how to calculate sij using our proposed k-step index algorithm. Table 2 shows ten paper ID and the corresponding keywords represented by capitals A to L. The keywords constitutes the whole network G′=(V′,E′<math><mrow is="true"><msup is="true"><mi is="true">G</mi><mo is="true">′</mo></msup><mrow is="true"><mo is="true">=</mo><mo is="true">(</mo></mrow><msup is="true"><mi mathvariant="script" is="true">V</mi><mo is="true">′</mo></msup><mo is="true">,</mo><msup is="true"><mrow is="true"><mi mathvariant="script" is="true">E</mi></mrow><mo is="true">′</mo></msup></mrow></math>) as shown in Fig. 2. The edge weight is the times that two keywords appear at the same paper. Suppose author ap published papers P1 and P2, the term weighting of any keyword q that has direct correlation with ap is calculated using Eq. (2). (2)wpq=N(p)·D(pq)K(p)·log(NsP(q)+1)<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">p</mi><mi is="true">q</mi></mrow></msub><mo is="true">=</mo><mfrac is="true"><mrow is="true"><mi is="true">N</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mi is="true">p</mi><mo stretchy="true" is="true">)</mo></mrow><mo is="true">·</mo><mi is="true">D</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mrow is="true"><mi is="true">p</mi><mi is="true">q</mi></mrow><mo stretchy="true" is="true">)</mo></mrow></mrow><mrow is="true"><mi is="true">K</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mi is="true">p</mi><mo stretchy="true" is="true">)</mo></mrow></mrow></mfrac><mo is="true">·</mo><mi is="true">log</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mfrac is="true"><msub is="true"><mi is="true">N</mi><mi is="true">s</mi></msub><mrow is="true"><mi is="true">P</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mi is="true">q</mi><mo stretchy="true" is="true">)</mo></mrow><mo is="true">+</mo><mn is="true">1</mn></mrow></mfrac><mo stretchy="true" is="true">)</mo></mrow></mrow></math>where N(p) is the number of papers published by author ap. D(pq) is the number of keyword q appearing in the papers published by ap. Thus, the more a keyword appears in the papers published by ap, the more significant it is in ap’s term weighting. K(p) is the total keywords published by author ap. Ns is the total number of papers in the network. P(q) is the number of papers including keyword P(q). That is, if a keyword appears at many papers in the collection frequently, it is not considered to be particularly representative of this kind of papers. For example, the keyword “data mining” is a broad research area. If an author publishes a paper with this keyword, we probably do not know what research area this paper is related to. Once the keyword becomes more specific, such as temporal outlier detection, outlier pair detection and so on, the feature can be more representative in term weighting. Therefore, wp,C=2×26×log(107+1)=0.067<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">p</mi><mo is="true">,</mo><mi is="true">C</mi></mrow></msub><mo is="true">=</mo><mfrac is="true"><mrow is="true"><mn is="true">2</mn><mo is="true">×</mo><mn is="true">2</mn></mrow><mn is="true">6</mn></mfrac><mo is="true">×</mo><mi is="true">log</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mfrac is="true"><mn is="true">10</mn><mrow is="true"><mn is="true">7</mn><mspace width="0.33em" is="true"></mspace><mo is="true">+</mo><mspace width="0.33em" is="true"></mspace><mn is="true">1</mn></mrow></mfrac><mo stretchy="true" is="true">)</mo></mrow><mo is="true">=</mo><mn is="true">0.067</mn></mrow></math>
Only applying the attributes that have direct correlation with the target objects is not enough. The features, that have indirect correlation with the target objects, also need to be assigned with a term weighting. After obtaining the term weighting of keywords related to the authors directly, we perform k-step index to make the features be more complete. When k is zero, the subgraph of network G′ is described in the left part of Fig. 3. The nodes, which are available for calculating term weighting, include A, B, C, D, E and H (known as starting nodes). Since graph may include circles, each vertex can be marked using an auxiliary array to prevent graph traversal algorithms from infinite loops. Then, each vertex, that is adjacent to the starting nodes, is visited under the condition that k is equal to 1. The nodes which are available for calculating term weighting, are the ones shown in the middle part of Fig. 3 except for starting nodes. Likewise, when k is equal to 2, the nodes K and L are available to be assigned with a term weighting. The term weighting of any keyword q that has indirect correlation with ap is calculated using Eq. (3). (3)wpq=1k+1·∑u=1tφuq·wput<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">p</mi><mi is="true">q</mi></mrow></msub><mo is="true">=</mo><mfrac is="true"><mn is="true">1</mn><mrow is="true"><mi is="true">k</mi><mo is="true">+</mo><mn is="true">1</mn></mrow></mfrac><mo is="true">·</mo><mfrac is="true"><mrow is="true"><msubsup is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">u</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">t</mi></msubsup><msub is="true"><mi is="true">φ</mi><mrow is="true"><mi is="true">u</mi><mi is="true">q</mi></mrow></msub><mo is="true">·</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">p</mi><mi is="true">u</mi></mrow></msub></mrow><mi is="true">t</mi></mfrac></mrow></math>where k is the step number from starting nodes to q. The node u is visited when the step number is k−1<math><mrow is="true"><mi is="true">k</mi><mo is="true">−</mo><mn is="true">1</mn></mrow></math>. φuq is edge weight between node u and node q. t is the number of node u. Thus, the term weighting calculation formula is summarized in Eq. (4) as follows. Then, each element sij in matrix S representing the similarity between ai and aj is calculated by cosine similarity. (4)wpq={N(p)·D(pq)K(p)·log(NsP(q)+1)k=01k+1·∑u=1tφuq·wputk>0<math><mrow is="true"><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">p</mi><mi is="true">q</mi></mrow></msub><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">{</mo><mtable is="true"><mtr is="true"><mtd columnalign="left" is="true"><mrow is="true"><mfrac is="true"><mrow is="true"><mi is="true">N</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mi is="true">p</mi><mo stretchy="true" is="true">)</mo></mrow><mo is="true">·</mo><mi is="true">D</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mrow is="true"><mi is="true">p</mi><mi is="true">q</mi></mrow><mo stretchy="true" is="true">)</mo></mrow></mrow><mrow is="true"><mi is="true">K</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mi is="true">p</mi><mo stretchy="true" is="true">)</mo></mrow></mrow></mfrac><mo is="true">·</mo><mi is="true">log</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mfrac is="true"><msub is="true"><mi is="true">N</mi><mi is="true">s</mi></msub><mrow is="true"><mi is="true">P</mi><mrow is="true"><mo stretchy="true" is="true">(</mo><mi is="true">q</mi><mo stretchy="true" is="true">)</mo></mrow><mo is="true">+</mo><mn is="true">1</mn></mrow></mfrac><mo stretchy="true" is="true">)</mo></mrow></mrow></mtd><mtd columnalign="left" is="true"><mrow is="true"><mi is="true">k</mi><mo is="true">=</mo><mn is="true">0</mn></mrow></mtd></mtr><mtr is="true"><mtd columnalign="left" is="true"><mrow is="true"><mfrac is="true"><mn is="true">1</mn><mrow is="true"><mi is="true">k</mi><mo is="true">+</mo><mn is="true">1</mn></mrow></mfrac><mo is="true">·</mo><mfrac is="true"><mrow is="true"><msubsup is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">u</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">t</mi></msubsup><msub is="true"><mi is="true">φ</mi><mrow is="true"><mi is="true">u</mi><mi is="true">q</mi></mrow></msub><mo is="true">·</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">p</mi><mi is="true">u</mi></mrow></msub></mrow><mi is="true">t</mi></mfrac></mrow></mtd><mtd columnalign="left" is="true"><mrow is="true"><mspace width="0.33em" is="true"></mspace><mi is="true">k</mi><mo is="true">&gt;</mo><mn is="true">0</mn></mrow></mtd></mtr></mtable></mrow></mrow></math>
In addition, we set a threshold θ for index step k to prevent excessive time consumption. Once the parameter k reaches the threshold θ, the k-step index algorithm will terminate. We will detail how to choose θ in Section 6.3. Algorithm of Calculating Term Weighting Using k<math><mi is="true">k</mi></math>-step IndexInput: (1) a weighted indirect graph G′<math><msup is="true"><mi is="true">G</mi><mo is="true">′</mo></msup></math>, (2) a target node ap<math><msub is="true"><mi is="true">a</mi><mi is="true">p</mi></msub></math>, (3) a threshold θ<math><mi is="true">θ</mi></math>.Output: The term weighting of target node ap<math><msub is="true"><mi is="true">a</mi><mi is="true">p</mi></msub></math>.1. Initialize k<math><mi is="true">k</mi></math> to 02. Initialize array visited[graphsize]3. forv←0<math><mrow is="true"><mi is="true">v</mi><mo is="true">←</mo><mn is="true">0</mn></mrow></math> to graphsize4. visited[v<math><mi is="true">v</mi></math>]←0<math><mrow is="true"><mspace width="0.33em" is="true"></mspace><mo is="true">←</mo><mn is="true">0</mn></mrow></math>5. end for6. Search for the nodes related to ap<math><msub is="true"><mi is="true">a</mi><mi is="true">p</mi></msub></math> directly and mark the nodes as starting nodes v′<math><msup is="true"><mi is="true">v</mi><mo is="true">′</mo></msup></math>7. for each starting node v′<math><msup is="true"><mi is="true">v</mi><mo is="true">′</mo></msup></math>8.  calculating the term weighting wpv′<math><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">p</mi><msup is="true"><mi is="true">v</mi><mo is="true">′</mo></msup></mrow></msub></math> of ap<math><msub is="true"><mi is="true">a</mi><mi is="true">p</mi></msub></math> using Eq. (2)9.  w←getNumber(v′)<math><mrow is="true"><mi is="true">w</mi><mo is="true">←</mo><mi is="true">g</mi><mi is="true">e</mi><mi is="true">t</mi><mi is="true">N</mi><mi is="true">u</mi><mi is="true">m</mi><mi is="true">b</mi><mi is="true">e</mi><mi is="true">r</mi><mo is="true">(</mo><msup is="true"><mi is="true">v</mi><mo is="true">′</mo></msup><mo is="true">)</mo></mrow></math>// get the number of node v′<math><msup is="true"><mi is="true">v</mi><mo is="true">′</mo></msup></math>10.  visited[w<math><mi is="true">w</mi></math>]←1<math><mrow is="true"><mspace width="0.33em" is="true"></mspace><mo is="true">←</mo><mn is="true">1</mn></mrow></math>11. end for12. while((getNeighbor(v′)≠NULL)&&(k≤θ)<math><mrow is="true"><mrow is="true"><mo is="true">(</mo><mrow is="true"><mi is="true">g</mi><mi is="true">e</mi><mi is="true">t</mi><mi is="true">N</mi><mi is="true">e</mi><mi is="true">i</mi><mi is="true">g</mi><mi is="true">h</mi><mi is="true">b</mi><mi is="true">o</mi><mi is="true">r</mi><mo is="true">(</mo><msup is="true"><mi is="true">v</mi><mo is="true">′</mo></msup><mo is="true">)</mo><mo is="true">≠</mo><mi is="true">NULL</mi></mrow><mo is="true">)</mo></mrow><mo is="true">&#x26;</mo><mo is="true">&#x26;</mo><mrow is="true"><mo is="true">(</mo><mrow is="true"><mi is="true">k</mi><mo is="true">≤</mo><mi is="true">θ</mi></mrow><mo is="true">)</mo></mrow></mrow></math>)13. k←k+1<math><mrow is="true"><mspace width="1em" is="true"></mspace><mi is="true">k</mi><mo is="true">←</mo><mi is="true">k</mi><mo is="true">+</mo><mn is="true">1</mn></mrow></math>14.  for each node v′′<math><msup is="true"><mi is="true">v</mi><mrow is="true"><mo is="true">′</mo><mo is="true">′</mo></mrow></msup></math> in getNeighbor(v′)<math><mrow is="true"><mi is="true">g</mi><mi is="true">e</mi><mi is="true">t</mi><mi is="true">N</mi><mi is="true">e</mi><mi is="true">i</mi><mi is="true">g</mi><mi is="true">h</mi><mi is="true">b</mi><mi is="true">o</mi><mi is="true">r</mi><mo is="true">(</mo><msup is="true"><mi is="true">v</mi><mo is="true">′</mo></msup><mo is="true">)</mo></mrow></math>15.   w←getNumber(v′′)<math><mrow is="true"><mi is="true">w</mi><mo is="true">←</mo><mi is="true">g</mi><mi is="true">e</mi><mi is="true">t</mi><mi is="true">N</mi><mi is="true">u</mi><mi is="true">m</mi><mi is="true">b</mi><mi is="true">e</mi><mi is="true">r</mi><mo is="true">(</mo><msup is="true"><mi is="true">v</mi><msup is="true"><mrow is="true"></mrow><mrow is="true"><mo is="true">′</mo><mo is="true">′</mo></mrow></msup></msup><mo is="true">)</mo></mrow></math>16.   if(visited[w<math><mi is="true">w</mi></math>]==0<math><mrow is="true"><mo is="true">=</mo><mo is="true">=</mo><mn is="true">0</mn></mrow></math>)17.    calculating the term weighting wpv′′<math><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">p</mi><msup is="true"><mi is="true">v</mi><mrow is="true"><mo is="true">′</mo><mo is="true">′</mo></mrow></msup></mrow></msub></math> of ap<math><msub is="true"><mi is="true">a</mi><mi is="true">p</mi></msub></math> using Eq. (3)18.   end if19.  end for20.  v′←v′′<math><mrow is="true"><msup is="true"><mi is="true">v</mi><mo is="true">′</mo></msup><mo is="true">←</mo><msup is="true"><mi is="true">v</mi><mrow is="true"><mo is="true">′</mo><mo is="true">′</mo></mrow></msup></mrow></math>21. end while
In this section, we will present our outlier pair detection method using LSModel for LSOutPair detection.
According to Definition 1, let vector li be x1 and let si be x2. Then, we perform linear transformation to each vector in matrices Ln×n=[l1,l2,⋯,ln]T<math><mrow is="true"><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><mo is="true">=</mo><msup is="true"><mrow is="true"><mo is="true">[</mo><mrow is="true"><msub is="true"><mi mathvariant="bold-italic" is="true">l</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi mathvariant="bold-italic" is="true">l</mi><mn is="true">2</mn></msub><mo is="true">,</mo><mo is="true">⋯</mo><mo is="true">,</mo><msub is="true"><mi mathvariant="bold-italic" is="true">l</mi><mi mathvariant="bold-italic" is="true">n</mi></msub></mrow><mo is="true">]</mo></mrow><mi is="true">T</mi></msup></mrow></math> and Sn×n=[s1,s2,⋯,sn]T<math><mrow is="true"><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><mo is="true">=</mo><msup is="true"><mrow is="true"><mo is="true">[</mo><mrow is="true"><msub is="true"><mi mathvariant="bold-italic" is="true">s</mi><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mi mathvariant="bold-italic" is="true">s</mi><mn is="true">2</mn></msub><mo is="true">,</mo><mo is="true">⋯</mo><mo is="true">,</mo><msub is="true"><mi mathvariant="bold-italic" is="true">s</mi><mi mathvariant="bold-italic" is="true">n</mi></msub></mrow><mo is="true">]</mo></mrow><mi is="true">T</mi></msup></mrow></math> and get the final similarity matrix Wn × n using Eq. (5) as follows. (5)Wn×n=[αl11+βs11αl12+βs12⋯αl1n+βs1nαl21+βs21αl22+βs22⋯αl2n+βs2n⋮⋮⋯⋮αln1+βsn1αln2+βsn2⋯αlnn+βsnn]=αLn×n+βSn×n<math><mtable displaystyle="true" is="true"><mtr is="true"><mtd columnalign="right" is="true"><msub is="true"><mi is="true">W</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mtd><mtd is="true"><mo is="true">=</mo></mtd><mtd columnalign="left" is="true"><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mn is="true">11</mn></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mn is="true">11</mn></msub></mrow></mtd><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mn is="true">12</mn></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mn is="true">12</mn></msub></mrow></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow></msub></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mn is="true">21</mn></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mn is="true">21</mn></msub></mrow></mtd><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mn is="true">22</mn></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mn is="true">22</mn></msub></mrow></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow></msub></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow></msub></mrow></mtd><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow></msub></mrow></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi></mrow></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi></mrow></msub></mrow></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow></mtd></mtr><mtr is="true"><mtd is="true"></mtd><mtd is="true"><mo is="true">=</mo></mtd><mtd columnalign="left" is="true"><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><mo is="true">+</mo><mi is="true">β</mi><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow></mtd></mtr></mtable></math>subject toɛ∥αLn×n∥F−∥βSn×n∥F<ɛ<math><mrow is="true"><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">−</mo><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">β</mi><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">&lt;</mo><mrow is="true"><mi is="true">ɛ</mi></mrow></mrow></math>,
At this time, the outlier pair matrix Mos can be calculated using the established α and β in Eq. (6) as follows. Mos is the absolute value of αL−βS<math><mrow is="true"><mi is="true">α</mi><mi mathvariant="bold-italic" is="true">L</mi><mo is="true">−</mo><mi is="true">β</mi><mi mathvariant="bold-italic" is="true">S</mi></mrow></math> whose (i, j) entry is |lij−sij|<math><mrow is="true"><mrow is="true"><mo is="true">|</mo></mrow><mrow is="true"><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><mo is="true">−</mo><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow><mrow is="true"><mo is="true">|</mo></mrow></mrow></math> for each ordered pair (i, j). (6)Mos=[|αl11−βs11||αl12−βs12|⋯|αl1n−βs1n||αl21−βs21||αl22−βs22|⋯|αl2n−βs2n|⋮⋮⋮⋮|αln1−βsn1||αln2−βsn2|⋯|αlnn−βsnn|]<math><mrow is="true"><msub is="true"><mi is="true">M</mi><mrow is="true"><mi is="true">o</mi><mi is="true">s</mi></mrow></msub><mo is="true">=</mo><mrow is="true"><mo stretchy="true" is="true">[</mo><mtable is="true"><mtr is="true"><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mn is="true">11</mn></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mn is="true">11</mn></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mn is="true">12</mn></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mn is="true">12</mn></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mn is="true">1</mn><mi is="true">n</mi></mrow></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mn is="true">21</mn></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mn is="true">21</mn></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mn is="true">22</mn></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mn is="true">22</mn></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mn is="true">2</mn><mi is="true">n</mi></mrow></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd><mtd is="true"><mo is="true">⋮</mo></mtd></mtr><mtr is="true"><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mn is="true">1</mn></mrow></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mn is="true">2</mn></mrow></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd><mtd is="true"><mo is="true">⋯</mo></mtd><mtd is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">l</mi><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi></mrow></msub><mo is="true">−</mo><mi is="true">β</mi><msub is="true"><mi is="true">s</mi><mrow is="true"><mi is="true">n</mi><mi is="true">n</mi></mrow></msub></mrow><mo stretchy="true" is="true">|</mo></mrow></mtd></mtr></mtable><mo stretchy="true" is="true">]</mo></mrow></mrow></math>
Using the outlier pair matrix described above, we can obtain the maximum difference between link structure and semantic relationship of two target objects. The purpose of the condition ɛ∥αLn×n∥F−∥βSn×n∥F<ɛ<math><mrow is="true"><mrow is="true"><mo is="true">∥</mo><mi is="true">α</mi></mrow><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub><mo is="true">−</mo><msub is="true"><mrow is="true"><mo is="true">∥</mo><mi is="true">β</mi><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub><mo is="true">&lt;</mo><mrow is="true"><mi is="true">ɛ</mi></mrow></mrow></math> is to make sure that the link structure similarity and the semantic relationship similarity have the same order of magnitude. Once the values of L(S) matrix are too high or too low, the matrix Mos will not get outlier pairs with good performance. Thus, we use parameters α and β to adjust that the Frobenius norm of matrix αLn × n and the Frobenius norm of matrix βSn × n are almost the same, which can make the two matrices αLn × n and βSn × n have the same order of magnitude. We first calculate the Frobenius norm of matrices L and S, respectivevly. If ||L||F is greater than ||S||F, then α is set to 1. We increase β by 0.1 each time and iteratively compute ∥αLn×n∥F−∥βSn×n∥F<math><mrow is="true"><mrow is="true"><mo is="true">∥</mo><mi is="true">α</mi></mrow><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub><mo is="true">−</mo><msub is="true"><mrow is="true"><mo is="true">∥</mo><mi is="true">β</mi><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow></math> to judge whether the difference is smaller than the threshold ɛ. On the contrary, we set β to 1 and increase α by 0.1 each time. The top-K values in Mos means the two target objects have the maximum difference between link structure and semantic relationship, which are regarded as outlier pairs in the whole complex network. At the same time, the matrix Wn × n, as a byproduct in the outlier pair detection process, also can be applied to data analysis. The top-K values in Wn × n show that the link structure similarity and semantic relationship similarity are both very high, the target objects can be used to mine domain experts and identify authority Web pages, etc. Algorithm of Outlier Pair Detection Using LSModelInput: (1) a link structure matrix L<math><mi is="true">L</mi></math>, (2) a semantic relationship matrix S<math><mi is="true">S</mi></math>Output: Top-K outlier pairs1. Initialize α<math><mi is="true">α</mi></math> to 12. Initialize β<math><mi is="true">β</mi></math> to 13. Calculating the Frobenius norm of matrix L<math><mi is="true">L</mi></math>, ∥L∥F<math><msub is="true"><mrow is="true"><mo is="true">∥</mo><mi is="true">L</mi><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></math>4. Calculating the Frobenius norm of matrix S<math><mi is="true">S</mi></math>, ∥S∥F<math><msub is="true"><mrow is="true"><mo is="true">∥</mo><mi is="true">S</mi><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></math>5. if∥L∥F≥∥S∥F<math><mrow is="true"><msub is="true"><mrow is="true"><mo is="true">∥</mo><mi is="true">L</mi><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub><mo is="true">≥</mo><msub is="true"><mrow is="true"><mo is="true">∥</mo><mi is="true">S</mi><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow></math> then6.  whileɛ∥αLn×n∥F−∥βSn×n∥F≥ɛ<math><mrow is="true"><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">−</mo><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">β</mi><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">≥</mo><mrow is="true"><mi is="true">ɛ</mi></mrow></mrow></math>7.   β←β+0.1<math><mrow is="true"><mi is="true">β</mi><mo is="true">←</mo><mi is="true">β</mi><mo is="true">+</mo><mn is="true">0.1</mn></mrow></math>8.  end while9. else10.   whileɛ∥αLn×n∥F−∥βSn×n∥F≥ɛ<math><mrow is="true"><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">α</mi><msub is="true"><mi is="true">L</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">−</mo><mrow is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mrow is="true"><mi is="true">β</mi><msub is="true"><mi is="true">S</mi><mrow is="true"><mi is="true">n</mi><mo is="true">×</mo><mi is="true">n</mi></mrow></msub></mrow><msub is="true"><mrow is="true"><mo is="true">∥</mo></mrow><mi is="true">F</mi></msub></mrow><mo is="true">≥</mo><mrow is="true"><mi is="true">ɛ</mi></mrow></mrow></math>11.   α←α+0.1<math><mrow is="true"><mi is="true">α</mi><mo is="true">←</mo><mi is="true">α</mi><mo is="true">+</mo><mn is="true">0.1</mn></mrow></math>12.  end while13. end if14. Outlier pair matrix Mos←<math><mrow is="true"><msub is="true"><mi is="true">M</mi><mrow is="true"><mi is="true">o</mi><mi is="true">s</mi></mrow></msub><mo is="true">←</mo></mrow></math> the absolute value of αL−βS<math><mrow is="true"><mi is="true">α</mi><mi mathvariant="bold-italic" is="true">L</mi><mo is="true">−</mo><mi is="true">β</mi><mi mathvariant="bold-italic" is="true">S</mi></mrow></math>15. The top-K values in Mos<math><msub is="true"><mi is="true">M</mi><mrow is="true"><mi is="true">o</mi><mi is="true">s</mi></mrow></msub></math> are regarded as the outlier pairs
As we known, it is always a challenging problem of evaluating outliers due to the lack of ground truth. In this section, we define an outlierness measure, called pOut, for evaluating outlier pairs in complex network (Section 6.1). precision and recall are also used to be performance metrics (Section 6.1). Then, two datasets AMiner and Yahoo!Movies are used to validate the effectiveness of the proposed LSOutPair (Section 6.2). Several experiments are performed in the remainder of this paper to verify whether calculating the vast differences between link structure and semantic relationship holds for mining outlier pairs in complex networks (Section 6.3).
In order to test the quality of our proposed outlier pair detection method, a novel performance metric is defined, which is called pOut. pOut can measure the number of object pairs that are marked wrongly or are missing. “Marked wrongly” means the object pair is a normal data but it is marked as an outlier pair. “Missing” means that the object pair should be an outlier pair but it does not exist in the top-K outlier pair set. The number of outlier pairs that are marked wrongly is denoted by W<math><mi mathvariant="script" is="true">W</mi></math>. The number of outlier pairs that are missing during the outlier detection process is denoted by M<math><mi mathvariant="script" is="true">M</mi></math>. outPair is the total outlier pairs that are annotated manually in the dataset. Accordingly, we define pOut using Eq. (7) as follows. (7)pOut=W+M2×|outPair|×100%<math><mrow is="true"><mi is="true">p</mi><mi is="true">O</mi><mi is="true">u</mi><mi is="true">t</mi><mo is="true">=</mo><mfrac is="true"><mrow is="true"><mi mathvariant="script" is="true">W</mi><mo is="true">+</mo><mi mathvariant="script" is="true">M</mi></mrow><mrow is="true"><mn is="true">2</mn><mo is="true">×</mo><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">o</mi><mi is="true">u</mi><mi is="true">t</mi><mi is="true">P</mi><mi is="true">a</mi><mi is="true">i</mi><mi is="true">r</mi></mrow><mo stretchy="true" is="true">|</mo></mrow></mrow></mfrac><mo is="true">×</mo><mn is="true">100</mn><mo is="true">%</mo></mrow></math>
Contrary to another popular evaluation metric, called accuracy, pOut uses two opposite situations: true negative and false positive, to test whether all the possible outlier pairs are identified during the process of detection. Another two common metrics, precision and recall, are also applied to reflect the availability of our proposed detection model (Liu, 2011). precision for outlier pair detection is the fraction of object pairs assigned that are identified as top-K outlier pairs in the outlier pair matrix, which measures how well it is doing at rejecting normal object pairs. recall is the fraction of object pairs assigned by the manual annotation data, which measures how well it is doing at finding all the outlier pairs. Therefore, precision and recall are calculated using Eqs. (8) and (9) as follows. (8)precision=|pairD|−W|pairD|×100%<math><mrow is="true"><mi is="true">p</mi><mi is="true">r</mi><mi is="true">e</mi><mi is="true">c</mi><mi is="true">i</mi><mi is="true">s</mi><mi is="true">i</mi><mi is="true">o</mi><mi is="true">n</mi><mo is="true">=</mo><mfrac is="true"><mrow is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">p</mi><mi is="true">a</mi><mi is="true">i</mi><mi is="true">r</mi><mi is="true">D</mi></mrow><mo stretchy="true" is="true">|</mo></mrow><mo is="true">−</mo><mi mathvariant="script" is="true">W</mi></mrow><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">p</mi><mi is="true">a</mi><mi is="true">i</mi><mi is="true">r</mi><mi is="true">D</mi></mrow><mo stretchy="true" is="true">|</mo></mrow></mfrac><mo is="true">×</mo><mn is="true">100</mn><mo is="true">%</mo></mrow></math>(9)recall=|pairD|−W|outPair|×100%<math><mrow is="true"><mi is="true">r</mi><mi is="true">e</mi><mi is="true">c</mi><mi is="true">a</mi><mi is="true">l</mi><mi is="true">l</mi><mo is="true">=</mo><mfrac is="true"><mrow is="true"><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">p</mi><mi is="true">a</mi><mi is="true">i</mi><mi is="true">r</mi><mi is="true">D</mi></mrow><mo stretchy="true" is="true">|</mo></mrow><mo is="true">−</mo><mi mathvariant="script" is="true">W</mi></mrow><mrow is="true"><mo stretchy="true" is="true">|</mo><mrow is="true"><mi is="true">o</mi><mi is="true">u</mi><mi is="true">t</mi><mi is="true">P</mi><mi is="true">a</mi><mi is="true">i</mi><mi is="true">r</mi></mrow><mo stretchy="true" is="true">|</mo></mrow></mfrac><mo is="true">×</mo><mn is="true">100</mn><mo is="true">%</mo></mrow></math>where pairD is the set of object pairs in the top-K outlier pairs of the outlier pair matrix. outPair is the total outlier pairs that are annotated manually in the dataset. F-Measure (Croft, Metzler, & Strohman, 2009), as the harmonic mean of precision and recall, is also used to measure the performance of our method. It is calculated using Eq. (10) as follows. (10)F−Measure=(γ+1)precision×recallγ2×precision+recall<math><mrow is="true"><mi is="true">F</mi><mo is="true">−</mo><mi is="true">M</mi><mi is="true">e</mi><mi is="true">a</mi><mi is="true">s</mi><mi is="true">u</mi><mi is="true">r</mi><mi is="true">e</mi><mo is="true">=</mo><mfrac is="true"><mrow is="true"><mrow is="true"><mo stretchy="true" is="true">(</mo><mrow is="true"><mi is="true">γ</mi><mo is="true">+</mo><mn is="true">1</mn></mrow><mo stretchy="true" is="true">)</mo></mrow><mi is="true">p</mi><mi is="true">r</mi><mi is="true">e</mi><mi is="true">c</mi><mi is="true">i</mi><mi is="true">s</mi><mi is="true">i</mi><mi is="true">o</mi><mi is="true">n</mi><mo is="true">×</mo><mi is="true">r</mi><mi is="true">e</mi><mi is="true">c</mi><mi is="true">a</mi><mi is="true">l</mi><mi is="true">l</mi></mrow><mrow is="true"><msup is="true"><mi is="true">γ</mi><mn is="true">2</mn></msup><mo is="true">×</mo><mi is="true">p</mi><mi is="true">r</mi><mi is="true">e</mi><mi is="true">c</mi><mi is="true">i</mi><mi is="true">s</mi><mi is="true">i</mi><mi is="true">o</mi><mi is="true">n</mi><mo is="true">+</mo><mi is="true">r</mi><mi is="true">e</mi><mi is="true">c</mi><mi is="true">a</mi><mi is="true">l</mi><mi is="true">l</mi></mrow></mfrac></mrow></math>where γ is a weight for reflecting the relative importance of precision and recall. Obviously, if γ > 1, then the recall value is more important than the precision value. In this paper, γ is assigned a constant 1.
We perform the experiments using two real datasets: AMiner (Tang et al., 2008) and Yahoo!Movies (Yahoo! webscope program, 2016).
We generate data from AMiner, which is a bibliographic information network. It has three main parts including AMiner-Author.txt, AMiner-Paper.txt, and AMiner-Coauthor.txt. It has 1,712,433 authors and 2,092,356 papers covering different areas in computer science. We choose 10,000 users and the corresponding information in the experiments. There are four types of nodes: paper, author, venue, and term and several types of edges: writing and written-by, publishing and published-by, using and used-by, constructing the whole information network. In order to detect outliers with higher accuracy, a supplement is added to the original dataset. The keywords of each paper are extracted using our crawler (denoted by #k) (Peng & Liu 2013), and they are added to the end of each record in AMiner-Paper.txt. There are one hundred outlier pairs data annotated manually in each dataset. The formats of AMiner-Author.txt and AMiner.Paper.txt are described as follows:
AMiner-Author.txt:
#index —- index id of this author
#n —- name (separated by semicolons)
#a —- affiliations (separated by semicolons)
#pc —- the count of published papers of this author
#cn —- the total number of citations of this author
#hi —- the H-index of this author
#pi —- the P-index with equal A-index of this author
#upi —- the P-index with unequal A-index of this author
#t —- extracted key terms of this author (separated by semicolons)
AMiner.Paper.txt:
#index —- index id of this paper
#*—- the title of this paper
#@ —- the author names of this paper
#o —- affiliations (separated by semicolons)
#t —- year of publication
#c —- publication name
Yahoo!Movies, as a part of rating and classification dataset, can be applied to in complex information network. This dataset includes six files: ydata-ymovies-user-movie-ratings-train-v1_0.txt, ydata-ymovies-user-movie-ratings-test-v1_0.txt, ydata-ymovies-user-demographics-v1_0.txt, ydata-ymovies-movie-content-descr-v1_0.txt, ydata-ymovies-mapping-to-mov ielens-v1_0.txt, ydata-ymovies-mapping-to-eachmovie-v1_0.txt, covering various information about movies, actors, movie rating and so on. The multi-typed vertices and the multi-typed relations between them can be used for classification, clustering or detecting outliers. The rating information can be used for predicting or recommendation system. For example, the format of “ydata-ymovies-movie-content-descr-v1_0.txt” is described as follows:
1 title
2 synopsis
3 running time
4 MPAA rating
5 reasons for the MPAA rating
……
We use three types of objects: actor, movie, genres and their relations: actor–starring–movie, movie–belonging to–genres, to construct the movie network. The whole dataset contains 7642 actors, but we only choose 5000 actors and their movie information in the experiments. Also, one hundred object pairs are added in the dataset as outlier pairs.
In this section, we conduct five experiments to examine the effectiveness and efficiency of our proposed outlier pair detection method. The first experiment is conducted to find the most suitable α and β when obtaining the outlier pair matrix. We carry on a large number of experiments with various parameter settings. When the Frobenius norm of matrix L is greater than the Frobenius norm of matrix S, we vary the parameter β. Otherwise, we vary the parameter α. Tables 3 and 4 show the results on two datasets and the corresponding parameter settings. Note that since we choose top-100 values and the corresponding object pairs as outlier pairs in the Table 3, |pairD| is the equal to |outPair| in this case, which makes the precision is the same as recall. In addition, the sum of pOut and precision is 1. We choose top-50 values in outlier pair matrix and the corresponding object pairs as outlier pairs in Table 4. Once the number of detected outlier pairs is changed, we can vary α and β to make F-Measure reach its peak. In Table 3, the results show that α and β should be set to 1 and 3.1 respectively in AMiner, and α and β should be set to 3.8 and 1 in Yahoo!Movies. It can be seen from the results that when the number of attributes of the object is considerable, α is usually less than β. For example, in bibliographic network, there are many term attributes of an author after k-step index. Then, α is less than β in AMiner. On the contrary, when the number of attributes of the object is relatively small, α is usually greater than β. In addition, the results of top-50 outlier pairs are listed in Table 4, the precision becomes higher than that in Table 3. However, recall decreases a lot because there are one hundred outlier pairs annotated manually beforehand, that is, |outPair|=2|pairD|<math><mrow is="true"><mo is="true">|</mo><mrow is="true"><mi is="true">o</mi><mi is="true">u</mi><mi is="true">t</mi><mi is="true">P</mi><mi is="true">a</mi><mi is="true">i</mi><mi is="true">r</mi></mrow><mo is="true">|</mo><mo is="true">=</mo><mn is="true">2</mn><mo is="true">|</mo><mrow is="true"><mi is="true">p</mi><mi is="true">a</mi><mi is="true">i</mi><mi is="true">r</mi><mi is="true">D</mi></mrow><mo is="true">|</mo></mrow></math>.
In the second experiment, we attempt to find the most appropriate θ during the process of k-step index. As described in Section 4.2, the greater the parameter k is, the more accurate the term weighting of an object is. However, taking one more index step will increase the time consumption. Then, we vary the parameter θ from 1 to 10. As we can see from Fig. 4, F-Measure almost stays unchanged when θ reaches 4 in AMiner. Similarly, the parameter θ should be set to 7 in Yahoo!Movies. Because the number of attributes in AMiner is much more than that in Yahoo!Movies, it needs a greater θ during the process of k-step index in Yahoo!Movies to get a more accurate term weighting of objects.
In the third experiment, we study the impact of threshold ɛ on the accuracy of results. The parameter ɛ is increased from 1000 to 10,000 in AMiner dataset (and ɛ is increased from 400 to 5000 in Yahoo!Movies dataset) to observe the F-Measure values of outlier pair detection. When the parameter ɛ is small, it means that the parameter ɛ has a high requirement on the difference between link structure similarity and semantic relationship similarity. However, the difference between link structure similarity and semantic relationship similarity, that is, the difference between the Frobenius norm L matrix and S matrix, may never be less than ɛ. This is why the value of F-Measure is zero when ɛ is equal or smaller than 1200. A high parameter ɛ may also cause the situation that two matrices do not have the same order of magnitude, which will impact the performance of our proposed method. According to the curves in Fig. 5, we set ɛ to 1300 and 700 in AMiner and Yahoo!Movies, respectively. Since different datasets have different size, it is almost impossible to make a fixed parameter epsilon (or theta) suitable for all datasets. But once we get the appropriate values of the thresholds, we do not need to run the proposed approach again when testing the new data.
In real situation, the Frobenius norms of link structure similarity and semantic relationship similarity are calculated first. According to the smaller value, we can estimate appropriate ɛ and θ to observe how α and β influence the final ranking. When α and β are fixed, we can optimize ɛ and θ.
In the fourth experiment, we verify the scalability of our proposed algorithm. In AMiner and Yahoo!Movies datasets, we increase the number of objects from 1000 to 4000, and then observe the running time. Fig. 6 shows that the execution time is almost linear growth instead of exponential growth with the linear growth of data volume.
The fifth experiment is conducted to compare the performance of our proposed method and three baseline algorithms (CDOutlier (Gupta et al., 2013a), EBC (Gupta, Gao, Yan, Cam, & Han, 2013b) and Query-based outlier detection (Kuck, Zhuang, Yan, Cam, & Han, 2015)). CDOutlier discovers popular community distribution patterns for all the object types based on joint non-negative matrix factorization. CDOutlier groups authors based their research area distributions. That is, it only considers the semantic information in the network. EBC groups the attributes of an object individually. Whether the object is marked as an outlier depends on the number of anomalous attributes. The number of the attributes in a dataset may influence the final performance of outlier detection. Query-based outlier detection finds anomalies according to the queries input by users. It considers more link information than semantic information in the whole process. According to the curves in Fig. 7, LSOutPair performs better than Query-based outlier detection, CDOutlier and EBC. The F-Measure increases slowly with the increasing number of objects. But, in LSOutPair, more objects are involved in the experiments means that the link similarity and semantic similarity should be more accurate. Table 5 provides a summary of LSOutPair and three baseline algorithms.
Most traditional outlier detection methods are used to identify single outlier or outlier subgraph in complex network or discover outliers in homogenous network. The outlier pairs in homogeneous network can be obtained only based on the statistic information. A lot of link information or semantic information is ignored. As described in Table 5, LSOutPair is an outlier pair detection method in complex network. The main advantages of LSOutPair are: (1) it considers the link structure and semantic relationship of the objects in the datasets, (2) using the difference between link structure similarity and semantic relationship similarity to detect outlier pair is a new attempt in data mining, (3) it combines multi-typed objects and multi-typed relations instead of only using single type objects. However, LSOutPair also has its limitations: when calculating link structure similarity, we just use two types of objects “author” and “paper”, and their link relations. At this time, the terms are ignored. When calculating semantic relationship similarity, we also use three types of objects “author”, “paper”, and “term”, and their link relations. Although we only deal with “term”, the “paper” information plays an important role in connecting “author” and “term”. In link similarity part, two types “writing” and “writing-by” are used. In semantic similarity part, four types “writing” and “writing-by”, “using” and “used-by” are used. Only utilizing “term” in the process of calculating semantic similarity may be a disadvantage of this paper. But multi-typed objects and multi-typed links are considered in the link model and semantic model. In future research, we may consider combines multi-typed objects in the process of feature representation. In addition, the users need to tune the four parameters to get the final results when training the data in a new dataset, which is another limitation of this method.
In this paper, we propose an outlier pair detection method for complex information networks based on link structure and semantic relationship. We define an LSModel, which includes Link part reflecting the link structure similarity between objects and Semantic part representing the semantic similarity between objects on the network. A k-step index algorithm is introduced to compute the term weighting of objects to obtain the semantic similarity. The linear transformation and Frobenius norm are combined to find differences between Link part and Semantic part and rank the outlierness for outlier pair. We also propose pOut, as a measurement for outlier pair, to evaluate effectiveness of the proposed LSOutPair. Experimental results show that our proposed outlier detection method, LSOutPair, can discover outlier pairs in c networks effectively and efficiently.
This work is supported by the National Natural Science Foundation of China under grant No. 60903098, the Project of Jilin Provincial Industrial Technology Research and Development (JF2012c016-2), and Graduate Innovation Fund of Jilin University (2016183, 2016184).