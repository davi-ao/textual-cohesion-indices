In recent years, with the Germany "industry 4.0″, "China manufacturing 2025″ and the America "Industry Internet +" as representative, upgrading manufacturing industry plans has been increasingly popular among academia and industry, of which "intelligent manufacturing" has become one of the advanced manufacturing modes developed by all countries in the world (Yanhong and Baicun, 2018). The purpose of intelligent manufacturing is to transform the data acquired in the product life cycle into manufacturing intelligence, so as to have a positive impact on all aspects of manufacturing. For process planning, an effective way to realize intelligence is to reuse the machining know-how embedded in the machining process data to help smart machines automatically update parameter settings. Currently, a large number of CAD models and associated NC process data (CAM model data) are generated and stored in the repository continuously, which becomes the effective digital carrier of knowledge, wisdom and experience of designers, and gradually forms big process data which provides abundant and easily accessible basic information sources for the development of process knowledge mining, management and application. On the other hand, although CAPP system, CAM system, process knowledge base technology and other technologies have been put forward and applied for many years, and the ideal model of creative CAPP in the field of process planning has also been put forward (Xu et al., 2011; Wang, 2015; Zhou et al., 2007; Xie and Xu, 2008; Mourtzis et al., 2016), due to the lack of effective breakthroughs in the study of the representation and acquisition of process knowledge for a long time, the current process planning still relies mainly on human-computer interaction and essentially depends on human Intelligence, not machine intelligence. In addition, the evolution of CAPP system, CAM system and process knowledge base mainly depends on the refinement and summary of new process experience and knowledge of designers. Therefore, how to solve the representation and acquisition of process knowledge has become an urgent problem to promote the intellectualization of process planning.
Recently, abundant research results have been achieved in the search of similar instances and the reuse of process information (Cardone et al., 2006; You et al., 2010; Zhang and Zhou, 2011; Li et al., 2015a; Huang et al., 2015a). However, in the aspect of process knowledge mining, the current methods still mainly use process semantics information in the process scheme, which is not related to the geometry of parts. Since the relationship between the NC process and the geometry is the most direct and effective reflection of the designer's process intention, it is impossible to capture the process design intention only from process semantics, thus affecting the reusable value of the extracted process knowledge. In addition, due to the particularity of process knowledge, the rationality of the extracted knowledge in the NC process cannot be effectively guaranteed only by the frequency index in computer field. Therefore, a comprehensive analysis and evaluation of the process skeleton is needed, which can not only abstractly reflect the key information of a instance family, but also reflect its NC process characteristics. Therefore, the current typical process is still difficult to support effectively adaptive reuse of NC process. In order to realize data-driven intelligent process planning and reduce the workload of designers, in macro process knowledge mining, some critical issues should be addresses: (1) how to characterize typical macro processes to support the discovery and reuse of implicit macro process knowledge, and (2) how to analyze and extract the implicit macro process knowledge in data instances to improve the predicament of the current NC process planning system that is "strongly dependent" on experienced designers.
In this paper, a novel complex network based NC process skeleton extraction approach is presented to overcome the abovementioned problems. First, the characteristics for a good process skeleton are analyzed and the structured model for representing typical macro process based on CAM model data is elaborated. Then, after constructing a NC machining process data network by using NC machining process instances, the topological metrics of the process data network is analyzed to judge the key process element nodes and generate candidate process skeletons. Finally, the final process skeletons are determined by choosing those candidate process skeletons with moderate granularity and conforming to the specific process. In practical NC machining, pockets frequently appear in different parts and take more than 80% of the total machining time of the part. Among them, the pockets with free-form surfaces, i.e. pockets that are machined with 3 axis milling or more, are usually machined with the stratifying method. Namely, a pocket with free-form surfaces can be seen as multilayer pockets machined with 2 1/2 axis milling, indicating that pockets machined with 2 1/2 axis milling are the research foundation of other machining methods. As a result, this paper mainly focuses on 2 1/2 axis milling.
The remainder of this paper is organized as follows. In Section 2, we give a brief review of related work about knowledge discovery and typical process route extraction. Section 3 describes process skeleton modeling, and Section 4 gives the details of the extraction approach of process skeletons. Then in Section 5, the experiments and discussion are provided. Finally, the research is concluded in Section 6.
With the rapid development of information technology and the rapid growth of data in recent years, extracting high-value knowledge from case databases has become a trend, and gradually replacing the interactive construction mode of knowledge base (Ma et al. (2010);Bai et al. (2016a)) presented a mature design pattern extraction method for CAD models based on high-level perspective, which was evaluated by five indicators: high cohesion, low coupling, moderate complexity, high frequency and sufficient information. (Qin et al., 2017) proposed a Requirement-Function-Behavior-Structure-Evolution (RFBSE) model for capturing Designers' knowledge and experience in product design process to construct the relationship between object knowledge and problem decision-making knowledge, and then to support intelligent decision-making in the product design process. The above methods are mainly for design reuse. In the field of product manufacturing, the optimization method of cutting parameters based on data acquisition and mining in the manufacturing field has been extensively studied. Its main idea is to realize the prediction of various physical quantities and physical states, such as deformation (Li et al., 2015b), tool wear (Nouri et al., 2015), and quality (Wuest et al., 2014), by collecting, analyzing and modeling the manufacturing data. Thus, the continuous optimization of cutting parameters can be realized. For robot belt grinding, (Ng et al., 2016) analyzed the grinding tool paths of the skilled operators to capture their embedded tacit knowledge, thus guiding the robot to automatically set tool direction, grinding parameters and generate grinding tool paths. The above methods have great inspiration to process knowledge mining, but they still cannot effectively support the structuralization of NC process knowledge, so they cannot be directly applied to the field of NC process design.
(Liu et al. (2007)) applied coding technology to structurally represent process instances and adopted a clustering analysis algorithm to mine typical process routes from process data. (Zhou and Dai, 2015a;Wang et al. (2016);Li et al. (2015c)) proposed a multi-dimensional manufacturing information based typical product process route discovery method by considering the influence of manufacturing information such as cutting tools and process parameters on process similarity. (Navaei and Elmaraghy, 2017) used a mixed integer programming model to generate a master operations sequence for a family of part variants, which improves the efficiency and consistency of typical process generation. The above methods further improve the extraction effect of typical macro processes, but they have not yet been associated with the geometry of parts, so it is difficult to capture the intention of designers in depth. However, the research on analyzing and mining of CAM model data is still in its infancy. The current works of our research team mainly realized the association between machining features and operations in CAM model instances (Huang et al., 2015b). The higher level and more abstract macro process knowledge in CAM model instances needs to be further excavated.
In process planning, a process skeleton is defined as a core process sequence in the NC process scheme, which can effectively reflect the macro process constraints. It is common to a part family with similar process characteristics and easy to reuse. Inspired by the characteristics of design patterns in product design field summarized in Ref. (Bai et al. (2016b)), and combined with the unique characteristics of NC process, we summarize the characteristics of a good process skeleton as follows:
Reusability: easy to reuse the original process skeleton in other query parts;
Correlation: easy to maintain the information in the process skeleton;
Critical: easy to reflect the core process information and the key geometric structure;
Rationality: conform to the specific characteristics of NC process.
Accordingly, the target for modeling and extracting the process skeleton of NC machining process data is to meet four characteristics wherever possible. Since the machining feature can effectively correlate the geometric information with the process information, before extracting process skeleton, CAM model data will be structured based on machining features. Furthermore, by analyzing the above characteristics of a good process skeleton, it can be concluded that a process skeleton is considered as high quality if the process skeleton satisfies the following conditions:
It has moderate information. Typical process routes mined by existing methods only contain step information described in one-dimensional natural language, which is too extensive for reuse. NC process scheme describes the complete process information, which can be retrieved less in accordance with the requirements. Moderate information reflects the adaptability and versatility of the process skeleton PS, which includes the part attribute information PA, key feature KMF and macro process information MP. It can be denoted as
It has high frequency. Frequency σ is the number of the process skeleton appearing in the NC process instances, which reflects that the process skeleton is often reused in the part family. From a statistical point of view, this attribute ensures that the process skeleton has a certain degree of reusability. It can be denoted as
It has close correlation, that is, there is a correlation between the NC process and the geometry. Based on this, we can analyze the machining process, and further excavate the relationship between the geometry and the cutting tool, the geometry and the process parameters, the cutting tool and the process parameters.
It has appropriate granularity. If the granularity of process skeleton is too coarse, there will be only a very short typical process sequence with less information and low reuse value; if the granularity of process skeleton is too fine, it will contain many insignificant nodes, and the workload of the modification will be greatly increased during reuse.
It has specific process. NC machining of different types of parts has its own characteristics, and has some specific processes. To ensure that the extracted process skeletons meet the expertise of experts, according to the typical working steps of parts, the following criteria are established:
Priority. In the process skeleton, each working step also needs to meet the specific design sequence. Such as, the machining of aircraft structural parts has a sequence: Rough Milling Inner Outer Shape→Finish Milling Bottom→Finish Milling Corner→Semi-finish Milling Inner Outer Shape→Finish Milling Inner Outer Shape, where "→" means "priority".
Existence. Typical parts have their own machining characteristics. To ensure that the process scheme meets the machining requirements, some working steps must exist in the process scheme. Such as, in the macro processes of structural parts, Rough Milling Inner Outer Shape, Finish Milling Bottom, and Finish Milling Inner Outer Shape must exist, while others may not exist.
Effectiveness. Each cutting tool must be able to participate in actual cutting and remove a certain amount of redundant material to ensure the effectiveness of the process scheme. The rules are as follows: Let WP be a working procedure, {WSk,1≤k≤n} be a working step set of WP, {CTk,1≤k≤n} and {Ak,1≤k≤n} be the corresponding the cutting tool set and the allowance set of working steps respectively. Then, in the machining of the same feature, the diameter and allowance of the cutting tool must satisfy the descending order principle: d(CTk)≥d(CTk+1), Ak≥Ak+1.
As the above subsection analysis showed, a good process skeleton could make reuse easier by different parts, and no further manual intervention is needed to edit the macro process of the query parts, hence a proper model for process skeleton must describe the master process semantics sequence; meanwhile, the model needs to include the key geometric topology and manufacturing semantics information. To this end, based on the NIST’s Core Product Model (CPM) (Fenves et al., 2008), we construct a consistent formal model for the process skeleton. As Fig. 1 shows, a process skeleton is composed of a set of machining process and their associated machining features with similar manufacturing characteristics. Compared with STEP-NC data model (ISO14649-10, 2004; ISO14649-11, 2004), the model pays more attention to the relations between process elements, such as the mapping relations between machining operations and machining features, and the introduction of the subpart (the element with larger granularity than the machining feature) to represent the relations between machining features, which can better support reuse. The descriptions of classes closely related to the process skeleton are the following:
Part is geometric entity of product to be machined. Its basic attributes (including type, stock and material) directly affect the process analysis or macro process, and can be divided into several subparts or machining features.
Subpart is defined as a set of machining features with coupling relations, which is a relatively independent local region. The coupling relations include five kinds of feature interaction relations, such as pattern, datum, adjacent, dependent and spatial. Pattern, datum, adjacent and dependent relation reflect the machining sequence among features, while spatial relation can reflect the clamping relationship.
MachiningFeature is the basic element of information organization of the structured model. In this paper, the machining features are classified based on ISO 14649 (STEP-NC) (ISO14649-10, 2004), and the classification is adjusted according to the machining process data in CAM systems. Finally, it is divided into two categories: main feature and auxiliary feature. The main features include 6 types, such as pocket and hole, and the auxiliary features include 3 types, such as leaf and boss, and can be further subdivided, such as hole is divided into blind hole and through hole. Process analysis of the query part is not only related to the basic attributes of the part, but also to the geometric and precision requirements of key features. Compared with the auxiliary features, the main features are more likely to be the key features of query parts.
ProcessSkeleton is the key working step sequence reflecting the macro process constraints in the NC process scheme. It can effectively reflect the core macro process of a part family. Meanwhile, the process skeleton is related to machining features and their coupling relations, which makes it easy to be reused by other parts, and easy to further analyze and excavate the relationship between the geometric attributes of parts and macro process.
WorkingStep is the part of the completed process by using the same cutting tool for the same kind of machining features. Working steps exist in the process skeleton in the form of semantic expression, which enables them to express higher-level process intentions, such as Finish Milling Thin-walled Pocket Side. In addition, working steps also contain macro-layer process information such as cutting tools and allowances.
MachiningOperation is composed of machining strategy, cutting tool and machining parameters, which is the basic element of NC process. Meanwhile, the mapping relationship between machining operation and machining feature is established by tool path, which is the basis of analyzing the relationship between the geometry and the NC process.
The relations closely related to the process skeleton class are the following:
Machining relation. The machining relation is the mapping relationship between machining features and machining operations, which constructs the relationship between the geometry and the NC process. In the process skeleton, the relationship between machining feature and working steps is considered.
Temporal relation. Temporal relations and working steps constitute the NC process part of the process skeleton, and the machining sequence relation between the steps is constructed.
Coupling relation. Coupling relations and machining feature constitute the geometric part of the process skeleton, and the interaction relationship between machining features is constructed.
As an example, Fig. 2 shows an instance diagram for a simple process skeleton instance.
Definition 1

Machining feature (F). Machining feature is a set of adjacent faces which can be associated with a set of machining operations. Some machining attributes (e.g. tool access direction (TAD), machining precision, and reasonable machining strategies) should be satisfied to generate a machining feature. It can be denoted as

<F>::=[MR]<G><G>::= BF | TF | SF | DFWhereMRis the manufacturing semantics associated with a machining featureF(e.g. tolerance, surface roughness, and material);Gis the constraint geometry, including bottom face (BF), side face (SF), top face (TF), and datum face (DF).

Definition 2

Machining operation (Op). Machining operation is the abstract description of machining method in a CAM system, this is, a tool path can be automatically calculated by using a cutting tool, and setting a set of machining parameters (e.g. tool access direction (TAD), machining precision). It can be denoted as

<Op>::=<t><MS><T><DG>Wheretis the type of machining operation, including Facing, Pocketing, Profile Contouring;Msis machining strategy, mainly including strategy parameters, speed parameters, engage and retract parameters, such as tool path style, spindle speed, engage mode;Tis the cutting tool, mainly including type, diameter, corner radius;DGis the drive geometry, and is the core parameter of tool path generation, including offset, drive element, constraint element.

Definition 3

Working step (WS). A working procedure (such as roughing, semi-finishing, finishing, etc.) is consisted of one or multiple WSs. A WS stands for a machining operation, or a set of operations where the same jig/fixture is used and the same machining configurations such as position, orientation, machined surface, tool, speed and feed rate are applied.

Definition 4

Process Element Attribute Adjacency Graph (PEAAG). The process element adjacency graph is a graph structure describing the coupling relations between features, the temporal relations between working steps and the machining relations between working steps and features, which can be expressed as < PPAAG>=(V, E); where node vi∈V={v1, v2,…} corresponding to working step WS and machining feature MF, the geometry and the NC process information are reflected respectively. Edge ei∈E={e1, e2,…} corresponds to the relationship between two nodes.

Definition 5

Machining process data structured model (MPDSM). A machining process data structured model is a multi-level tree-like structure composed of machining feature (F), subpart (C), machining operation (Op), working step (WS), and working procedure (WP), as shown in Fig. 3. It can be denoted as <FSCAM>::=({<F>|<C>|<Op>|<WS>|<WP>},R); where R is a set of relations, including parent-child relation, coupled relation, machining relation, and temporal relation. The data object studied in this paper is 3D CAD model and its associated NC process, namely CAM model. It is a programming file generated by CAM system, e.g. CATProcess file in CATIA, prt file in UG. In this paper, the structural representation of machining process instances is constructed by instantiating the MPDSM, so as to support the construction of process data network and the extraction of process skeleton.

Download : Download high-res image (270KB)Download : Download full-size imageFig. 3. Machining process data structured model.
Machining feature (F). Machining feature is a set of adjacent faces which can be associated with a set of machining operations. Some machining attributes (e.g. tool access direction (TAD), machining precision, and reasonable machining strategies) should be satisfied to generate a machining feature. It can be denoted as
Machining operation (Op). Machining operation is the abstract description of machining method in a CAM system, this is, a tool path can be automatically calculated by using a cutting tool, and setting a set of machining parameters (e.g. tool access direction (TAD), machining precision). It can be denoted as
Working step (WS). A working procedure (such as roughing, semi-finishing, finishing, etc.) is consisted of one or multiple WSs. A WS stands for a machining operation, or a set of operations where the same jig/fixture is used and the same machining configurations such as position, orientation, machined surface, tool, speed and feed rate are applied.
Process Element Attribute Adjacency Graph (PEAAG). The process element adjacency graph is a graph structure describing the coupling relations between features, the temporal relations between working steps and the machining relations between working steps and features, which can be expressed as < PPAAG>=(V, E); where node vi∈V={v1, v2,…} corresponding to working step WS and machining feature MF, the geometry and the NC process information are reflected respectively. Edge ei∈E={e1, e2,…} corresponds to the relationship between two nodes.
Machining process data structured model (MPDSM). A machining process data structured model is a multi-level tree-like structure composed of machining feature (F), subpart (C), machining operation (Op), working step (WS), and working procedure (WP), as shown in Fig. 3. It can be denoted as <FSCAM>::=({<F>|<C>|<Op>|<WS>|<WP>},R); where R is a set of relations, including parent-child relation, coupled relation, machining relation, and temporal relation. The data object studied in this paper is 3D CAD model and its associated NC process, namely CAM model. It is a programming file generated by CAM system, e.g. CATProcess file in CATIA, prt file in UG. In this paper, the structural representation of machining process instances is constructed by instantiating the MPDSM, so as to support the construction of process data network and the extraction of process skeleton.
Based on the above analysis of process skeleton of CAM model, we propose a process skeleton extraction approach. Fig. 4 shows the overview of the approach, which contains three main phases: (1) structuring the machining process instances, (2) constructing machining process data network, and (3) extracting process skeletons. Here we give a brief description of each phase respectively.
Structuring the machining process instances: Aiming at the CAM model data (machining process instance), the machining features of parts are recognized, and the machining operation information in NC process is analyzed. According to the relationship between the geometry and the NC process, the structured representation of CAM model data is realized, which lays a foundation for extracting process skeleton. This part directly adopts the previous works of our team (Huang et al., 2015b; Huang et al., 2014), which is not discussed in this paper.
Constructing machining process data network: After structuring the machining process data, process instances are represented as graphs. The machining features and working steps are taken as nodes, the machining relations, temporal relations and coupling relations are taken as edges of nodes, and the number of collaborations is taken as weights. The machining process data network is constructed by graph isomorphism.
Extracting process skeletons: According to the characteristics of process skeleton and mining requirements, the topological metrics of process data network are analyzed to support the determination of key nodes. On this basis, the candidate process skeletons are generated by using key process element nodes. To obtain a reasonable process skeleton, the candidate process skeletons are further checked by moderate granularity and conforming to the specific process.
The MPDSM model is constructed by analyzing the process instances. Thus the process instances exist in the form of structured graphs. To analyze the importance of process elements in part process data and obtain the core process nodes in process skeleton, based on complex network theory, all process instances are constructed into process data network by the graph isomorphism in graph theory. The graph isomorphism algorithm in Ref. (Huang et al. (2011)) is used in this paper.
Since different machining process data instances have different definitions of machining features and NC process, the parts will have different forming paths. If all process data instances are considered synthetically, their NC processes and geometry are abstracted as nodes of the network, and the relationship between nodes is abstracted as directed edges, then the process data network can be constructed.
According to the above analysis, the complex network is used to construct the process data network. It can be formally expressed as G=(V, E, W), where V=(v1, v2, …, vN) denotes a set of nodes, including machining features, working steps and process instances; E=(e1, e2, …, eM) denotes edge set, including coupling relations, machining relations, temporal relations and similarity relations; W=(w1, w2, …, wM) denotes similarity and weight set, wi is used to quantify and statistics the relationship between edge vi. Fig. 5 shows a two-layer process data network model, which is used to characterize the complex relationship between different process elements in the NC machining process. The detailed description is as follows:
Machining process instance layer (MPIL). It contains a series of part instance nodes and can be expressed as MPIL={CAM1, CAM2, …, CAMn}. The relationship between part instances is calculated by similarity δ(CAMi, CAMj). Each instance contains the geometry and the NC process information, which can be expressed as CAM={MF1, MF2,…, MFn, WS1, WS2, …, WSm}. By using similarity and given threshold σ, parts with similar process and geometric characteristics are divided into the same part family, so MPIL can be rewritten as {{CAM1,…,CAMk}, …, {CAMl, …, CAMn}}.
Machining process element layer (MPEL). It contains a series of machining feature nodes and working step nodes. Machining feature MF is used to describe the geometry and accuracy requirements of parts, and working step WS is used to characterize the NC process. The edge weight W indicates the reuse times of a working step and a temporal relation, or the occurrences number of coupling relations between features; where the coupling relation weight Wc is obtained by statistical method based on feature similarity.
The process instances accumulated in the enterprise process database (each instance contains 3D CAD model, accuracy requirements and NC process information) are analyzed and structured with machining features as basic units, and then transformed into attribute adjacency graphs. Then, at the macro level, the similarity between the processing instances is calculated to cluster the instances, and at the micro level, the instance information is fused through graph isomorphism, so that all the instances can be transformed into the process data network. Specifically, the method is divided into the following steps:Input: machining process instance set CAM={CAMi,1≤i≤n}Output: machining process data network G=(V, E, W)
Step 1: Define part instance CAMi, machining feature MF and working step WS as nodes. MFs are obtained by the feature recognition algorithm in Ref. (Huang et al. (2013)) or Ref. (Sunil et al. (2010)). For the machining features (such as surfaces) which are unconsidered or the regions that need not be machined (from casting or forging blanks), they are defined by human-computer interaction. WSs are obtained by traversing associated NC process tree information. For the instances without working step information, machining operation clustering and interactive definition is used to extract the WSs;
Step 2: Define the coupling relations RC between MFs, the machining relation RM between MFs and WSs and the temporal relations RT between WSs as edges. RC is obtained by the method of capturing the interaction between MFs in (Huang et al., 2014). RM is realized by constructing the mapping relationship between MFs and Ops. RT is the machining operation sequence in NC process tree;
Step 3: Define the weights of network edges WC, WM and WT and initialize to 0;
Step 4: At the element level, MFs and WSs are matched and fused. At the instance level, the instances are clustered by similarity. The specific steps are as follows:
Step 4.1: Calculate the similarity σ(F, C) between MFs in a part instance by formula (1). According to the similarity, MF nodes and associated edges are fused. Since the number of MFs does not affect the process, the weight remains unchanged after fusion.(1)σ(F,C)=exp−(n1−n2)22×1−|φ1(d)−φ2(d)|maxφ1(d),φ2(d)<math><mrow is="true"><mi is="true">σ</mi><mo stretchy="false" is="true">(</mo><mi is="true">F</mi><mo is="true">,</mo><mi is="true">C</mi><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mtext is="true">exp</mtext><mfenced open="[" close="]" is="true"><mrow is="true"><mo is="true">−</mo><mfrac is="true"><mrow is="true"><msup is="true"><mrow is="true"><mo stretchy="false" is="true">(</mo><msub is="true"><mi is="true">n</mi><mn is="true">1</mn></msub><mo is="true">−</mo><msub is="true"><mi is="true">n</mi><mn is="true">2</mn></msub><mo stretchy="false" is="true">)</mo></mrow><mn is="true">2</mn></msup></mrow><mn is="true">2</mn></mfrac></mrow></mfenced><mo is="true">×</mo><mfenced open="(" close=")" is="true"><mrow is="true"><mn is="true">1</mn><mo is="true">−</mo><mfrac is="true"><mrow is="true"><mo is="true">|</mo><msub is="true"><mi is="true">φ</mi><mn is="true">1</mn></msub><mo stretchy="false" is="true">(</mo><mi is="true">d</mi><mo stretchy="false" is="true">)</mo><mo is="true">−</mo><msub is="true"><mi is="true">φ</mi><mn is="true">2</mn></msub><mo stretchy="false" is="true">(</mo><mi is="true">d</mi><mo stretchy="false" is="true">)</mo><mo is="true">|</mo></mrow><mrow is="true"><mi is="true">max</mi><mfenced open="[" close="]" is="true"><mrow is="true"><msub is="true"><mi is="true">φ</mi><mn is="true">1</mn></msub><mo stretchy="false" is="true">(</mo><mi is="true">d</mi><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><msub is="true"><mi is="true">φ</mi><mn is="true">2</mn></msub><mo stretchy="false" is="true">(</mo><mi is="true">d</mi><mo stretchy="false" is="true">)</mo></mrow></mfenced></mrow></mfrac></mrow></mfenced></mrow></math>Where φ(d) can be represented using area or volume of machining region of MF; n1 and n2 are the number of connected domains in the machining region, which are related to the number of tool retractions.
Step 4.2: Firstly, the graph isomorphism method is used to match the MFs, WSs and their edges between the instances. Then, the WSs are fused directly, and the MFs are judged by calculating the similarity according to formula (1). Finally, the weights of the fused edges are increased to obtain the MPEL.
Step 4.3: For the machining process instance, the similarity η(I1, I2) between the instances is calculated by formula (2), and the similarity threshold δ is set. All the machining process instances are divided into parts family. The relationship between MPIL and MPEL is constructed by the inclusion relationship between working step, machining feature information and the instance, thus the initial network G0 is completed.(2)η(I1,I2)=∑FC∈I1,M(FC)∈I2ωFC×σ(FC,M(FC))σ(FC,M(FC))=σ(S(FC),S(M(FC)))<math><mtable columnalign="left" displaystyle="true" is="true"><mtr is="true"><mtd is="true"><mi is="true">η</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">I</mi></mstyle><mn is="true">1</mn></msub><mo is="true">,</mo><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">I</mi></mstyle><mn is="true">2</mn></msub><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><munder is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">F</mi><mi is="true">C</mi><mo is="true">∈</mo><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">I</mi></mstyle><mn is="true">1</mn></msub><mo is="true">,</mo><mi is="true">M</mi><mo stretchy="false" is="true">(</mo><mi is="true">F</mi><mi is="true">C</mi><mo stretchy="false" is="true">)</mo><mo is="true">∈</mo><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">I</mi></mstyle><mn is="true">2</mn></msub></mrow></munder><mrow is="true"><msub is="true"><mi is="true">ω</mi><mrow is="true"><mi is="true">F</mi><mi is="true">C</mi></mrow></msub><mo is="true">×</mo><mi is="true">σ</mi><mo stretchy="false" is="true">(</mo><mi is="true">F</mi><mi is="true">C</mi><mo is="true">,</mo><mi is="true">M</mi><mo stretchy="false" is="true">(</mo><mi is="true">F</mi><mi is="true">C</mi><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">)</mo></mrow></mtd></mtr><mtr is="true"><mtd is="true"><mi is="true">σ</mi><mo stretchy="false" is="true">(</mo><mi is="true">F</mi><mi is="true">C</mi><mo is="true">,</mo><mi is="true">M</mi><mo stretchy="false" is="true">(</mo><mi is="true">F</mi><mi is="true">C</mi><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mi is="true">σ</mi><mo stretchy="false" is="true">(</mo><mi is="true">S</mi><mo stretchy="false" is="true">(</mo><mi is="true">F</mi><mi is="true">C</mi><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mi is="true">S</mi><mo stretchy="false" is="true">(</mo><mi is="true">M</mi><mo stretchy="false" is="true">(</mo><mi is="true">F</mi><mi is="true">C</mi><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">)</mo></mtd></mtr></mtable></math>Where σ(FC,M(FC)) is the similarity of fused feature clusters, which is calculated by the similarity between the central instances of feature clusters S(FC) and S(M(FC)); ⍵FC is the weight, which is related to the machining stage.
Step 5: In addition to the data in the static case base, incremental clustering is used to add and adjust the new process instances for the newly added process instances. The specific steps are as follows:
Step 5.1: At MPIL, the distance between the new instance NI and the central instance CI of each part family is calculated and classified as the nearest part family; when the new instance is accumulated to a certain extent, that is, R=q/n>λ, where q is the number of new instances, n is the number of all instances, and λ is the threshold; restart step 4.3 to cluster all instances. The distance d(NI) is calculated as follows(3)di(NI)=d(NI,CIi),i=1,2,...,md(NI,CIi)=1−η(NI,CIi)ifdk(NI)=mini=1,2,...,mdi(NI),thenNI∈Ck<math><mrow is="true"><mtable columnalign="left" displaystyle="true" is="true"><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">d</mi></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mi is="true">I</mi><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mi is="true">d</mi><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mi is="true">I</mi><mo is="true">,</mo><msub is="true"><mstyle displaystyle="true" is="true"><mrow is="true"><mi is="true">C</mi><mi is="true">I</mi></mrow></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mi is="true">i</mi><mo is="true">=</mo><mn is="true">1</mn><mo is="true">,</mo><mn is="true">2</mn><mo is="true">,</mo><mn is="true">...</mn><mo is="true">,</mo><mi is="true">m</mi></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mi is="true">d</mi><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mi is="true">I</mi><mo is="true">,</mo><msub is="true"><mstyle displaystyle="true" is="true"><mrow is="true"><mi is="true">C</mi><mi is="true">I</mi></mrow></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mn is="true">1</mn><mo is="true">−</mo><mi is="true">η</mi><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mi is="true">I</mi><mo is="true">,</mo><msub is="true"><mstyle displaystyle="true" is="true"><mrow is="true"><mi is="true">C</mi><mi is="true">I</mi></mrow></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">)</mo></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mtext is="true">if</mtext><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">d</mi></mstyle><mi is="true">k</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mi is="true">I</mi><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><munder is="true"><mstyle displaystyle="true" is="true"><mi is="true">min</mi></mstyle><mrow is="true"><mi is="true">i</mi><mo is="true">=</mo><mn is="true">1</mn><mo is="true">,</mo><mn is="true">2</mn><mo is="true">,</mo><mn is="true">...</mn><mo is="true">,</mo><mi is="true">m</mi></mrow></munder><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">d</mi></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mi is="true">I</mi><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mtext is="true"> then</mtext><mi is="true">N</mi><mi is="true">I</mi><mo is="true">∈</mo><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">C</mi></mstyle><mi is="true">k</mi></msub></mrow></mtd></mtr></mtable></mrow></math>Where m is the number of part families, CIi is the central instance of the ith part family, Ck is the kth part family.
Step5.2. At MPEL, new process instances are matched within the family of parts, for the matched parts, the weight values on the edges are updated, for the unmatched part, new MF or WS nodes are added, and new connection edges are added between nodes, so as to obtain a new process data network G.
After constructing the process data network, according to the importance of process element nodes, the process skeleton is extracted directly from the corresponding parts family, and the final process skeleton is determined by high-quality evaluation. It mainly includes three parts: topological metrics analysis, candidate process skeleton generation and final process skeleton determination.
To evaluate the importance of the process elements in process data, it is necessary to analyze the topological metrics of process data network. According to the topological structure and physical meaning of the network, the topological metrics of the network are defined as follows:
Degree centrality
Degree centrality is the most direct measure of node importance. In the process data network, it reflects the frequency of feature occurrence or adoption a working step. The degree ki of node i has two components: in-degree and out-degree. To facilitate comparison, the centrality index is normalized. Thus, the degree centrality DCi of node i can be expressed as:ki(in)=∑jaji,ki(out)=∑kaikki=ki(in)+ki(out)DCi=kiN−1<math><mtable columnalign="left" displaystyle="true" is="true"><mtr is="true"><mtd is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">k</mi></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">i</mi><mi is="true">n</mi><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><msub is="true"><mo is="true">∑</mo><mi is="true">j</mi></msub><mrow is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">a</mi></mstyle><mrow is="true"><mi is="true">j</mi><mi is="true">i</mi></mrow></msub></mrow><mo is="true">,</mo><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">k</mi></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">o</mi><mi is="true">u</mi><mi is="true">t</mi><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><msub is="true"><mo is="true">∑</mo><mi is="true">k</mi></msub><mrow is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">a</mi></mstyle><mrow is="true"><mi is="true">i</mi><mi is="true">k</mi></mrow></msub></mrow></mtd></mtr><mtr is="true"><mtd is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">k</mi></mstyle><mi is="true">i</mi></msub><mo is="true">=</mo><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">k</mi></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">i</mi><mi is="true">n</mi><mo stretchy="false" is="true">)</mo><mo is="true">+</mo><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">k</mi></mstyle><mi is="true">i</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">o</mi><mi is="true">u</mi><mi is="true">t</mi><mo stretchy="false" is="true">)</mo></mtd></mtr><mtr is="true"><mtd is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mrow is="true"><mi is="true">D</mi><mi is="true">C</mi></mrow></mstyle><mi is="true">i</mi></msub><mo is="true">=</mo><mfrac is="true"><mrow is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">k</mi></mstyle><mi is="true">i</mi></msub></mrow><mrow is="true"><mi is="true">N</mi><mo is="true">−</mo><mn is="true">1</mn></mrow></mfrac></mtd></mtr></mtable></math>Where aji is the weight of the edge in which node j points to node i, aik is the weight of the edge in which node i points to node k, ki(in) and ki(out) are the in-degree and out-degree of node i respectively, and N is the total number of nodes in process data network.
Betweeness centrality
Betweeness centrality is an index to describe the importance of a node by the number of shortest paths passing through the node. In the process data network, it means the number of a working step involved in forming parts’ process schemes. Meanwhile, when the manufacturing resources are scarce, and the process route needs to be changed, it will be more difficult to change the working step with higher betweeness centrality. Therefore, the normalized betweeness of node i in a network containing N nodes is defined asBCi=2(N−1)(N−2)∑s≠i≠tnst(i)gst<math><mrow is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mrow is="true"><mi is="true">B</mi><mi is="true">C</mi></mrow></mstyle><mi is="true">i</mi></msub><mo is="true">=</mo><mfrac is="true"><mn is="true">2</mn><mrow is="true"><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mo is="true">−</mo><mn is="true">1</mn><mo stretchy="false" is="true">)</mo><mo stretchy="false" is="true">(</mo><mi is="true">N</mi><mo is="true">−</mo><mn is="true">2</mn><mo stretchy="false" is="true">)</mo></mrow></mfrac><munder is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">s</mi><mo is="true">≠</mo><mi is="true">i</mi><mo is="true">≠</mo><mi is="true">t</mi></mrow></munder><mrow is="true"><mfrac is="true"><mrow is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">n</mi></mstyle><mrow is="true"><mi is="true">s</mi><mi is="true">t</mi></mrow></msub><mo stretchy="false" is="true">(</mo><mi is="true">i</mi><mo stretchy="false" is="true">)</mo></mrow><mrow is="true"><msub is="true"><mstyle displaystyle="true" is="true"><mi is="true">g</mi></mstyle><mrow is="true"><mi is="true">s</mi><mi is="true">t</mi></mrow></msub></mrow></mfrac></mrow></mrow></math>Where gst is the number of shortest paths from node s to node t, and nst(i) is the number of the paths passing through node i in the shortest path from node s to node t.
Closeness centrality
For each node i in the network, the average shortest distance di between the node and all nodes in the network can be calculated. The relative value of di reflects the relative importance of a machining feature or working step in all process data instances. The reciprocal of di is used to represent the closeness centrality of node i.di=1N∑j=1NdijCCi=1di<math><mrow is="true"><mtable columnalign="left" displaystyle="true" is="true"><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><msub is="true"><mi is="true">d</mi><mi is="true">i</mi></msub><mo is="true">=</mo><mfrac is="true"><mn is="true">1</mn><mi is="true">N</mi></mfrac><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">j</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mi is="true">N</mi></munderover><msub is="true"><mi is="true">d</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mi is="true">C</mi><msub is="true"><mi is="true">C</mi><mi is="true">i</mi></msub><mo is="true">=</mo><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msub is="true"><mi is="true">d</mi><mi is="true">i</mi></msub></mrow></mfrac></mrow></mtd></mtr></mtable></mrow></math>Where dij is the shortest distance from node i to node j.
Clustering coefficient
Clustering coefficient reflects the degree of tightness between node i and its neighbors. For machining feature nodes, it means that machining features are related to each other and have good connectivity. For working step nodes, it indirectly reflects the priority of working step or working step sequence for machining a feature. Since the process data network is a weighted network, the clustering coefficients of node i are expressed as follows:Ci=1ki(ki−1)∑j,kwijkaijaikajk<math><mrow is="true"><msub is="true"><mi is="true">C</mi><mi is="true">i</mi></msub><mo is="true">=</mo><mfrac is="true"><mn is="true">1</mn><mrow is="true"><msub is="true"><mi is="true">k</mi><mi is="true">i</mi></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mi is="true">k</mi><mi is="true">i</mi></msub><mo is="true">−</mo><mn is="true">1</mn><mo stretchy="false" is="true">)</mo></mrow></mfrac><munder is="true"><mstyle displaystyle="true" is="true"><mo is="true">∑</mo></mstyle><mrow is="true"><mi is="true">j</mi><mo is="true">,</mo><mi is="true">k</mi></mrow></munder><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi><mi is="true">k</mi></mrow></msub><msub is="true"><mi is="true">a</mi><mrow is="true"><mi is="true">i</mi><mi is="true">j</mi></mrow></msub><msub is="true"><mi is="true">a</mi><mrow is="true"><mi is="true">i</mi><mi is="true">k</mi></mrow></msub><msub is="true"><mi is="true">a</mi><mrow is="true"><mi is="true">j</mi><mi is="true">k</mi></mrow></msub></mrow></math>
Where ki is the degree of node i, when nodes i, j and k are connected, aijaikajk = 1, otherwise, aijaikajk = 0.
Compared with non-key nodes, key nodes tend to connect with other key nodes, that is, key features are more commonly derived from feature coupling than auxiliary features, and key working steps are more involved in feature machining than non-key steps. Meanwhile, for the key features, there is usually a specific machining mode. As shown in Fig. 6, since F has a small corner radius, two roughing working steps are one of the commonly used process schemes. Therefore, this paper introduces the concept of motif to analyze the relationship between the geometry and the NC process implied in the process data. According to the principle that the nodes participating in the motifs may be more critical, the importance of process element nodes can be judged by analyzing the motifs and the above indicators.
Referring to the complex network theory, two indicators, frequency and Z-score, are used to determine effective motifs, which are expressed as follows:
Frequency of motifs
For subgraph G with n nodes, its frequency of occurrence is defined as fG.fG=nGN<math><mrow is="true"><msub is="true"><mi is="true">f</mi><mi is="true">G</mi></msub><mo is="true">=</mo><mfrac is="true"><mrow is="true"><msub is="true"><mi is="true">n</mi><mi is="true">G</mi></msub></mrow><mi is="true">N</mi></mfrac></mrow></math>Where nG represents the number of occurrences of subgraph G, while N represents the number of occurrences of all subgraph with n nodes.
Z-score of motifs
For each subgraph G, the statistical significance is described by Z-score:ZG=NG(MPDN)−NG(rand)σG(rand)<math><mrow is="true"><msub is="true"><mi is="true">Z</mi><mi is="true">G</mi></msub><mo is="true">=</mo><mfrac is="true"><mrow is="true"><msub is="true"><mi is="true">N</mi><mi is="true">G</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">M</mi><mi is="true">P</mi><mi is="true">D</mi><mi is="true">N</mi><mo stretchy="false" is="true">)</mo><mo is="true">−</mo><msub is="true"><mi is="true">N</mi><mi is="true">G</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">r</mi><mi is="true">a</mi><mi is="true">n</mi><mi is="true">d</mi><mo stretchy="false" is="true">)</mo></mrow><mrow is="true"><msub is="true"><mi is="true">σ</mi><mi is="true">G</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">r</mi><mi is="true">a</mi><mi is="true">n</mi><mi is="true">d</mi><mo stretchy="false" is="true">)</mo></mrow></mfrac></mrow></math>Where NG(MPDN) represents the occurrence number of the subgraph in MPDN, and NG(rand) and σG(rand) represent the mean and the standard deviation of occurrence number in the randomized network, respectively.
Since a feature can be coupled with other features or machined by different process schemes, feature nodes can participate in many different types of motifs in the process data network. When considering the motifs to identify the importance of machining features or working steps, we need to assign different weights to different subgraphs in which nodes participate because of the different importance of different subgraphs in the network. In this paper, we can represent them as the first-order extended subgraph density DG:DG=2E(G∪L)N(G∪L)2−N(G∪L)<math><mrow is="true"><msub is="true"><mi is="true">D</mi><mi is="true">G</mi></msub><mo is="true">=</mo><mfrac is="true"><mrow is="true"><mn is="true">2</mn><mi is="true">E</mi><mo stretchy="false" is="true">(</mo><mi is="true">G</mi><mo is="true">∪</mo><mi is="true">L</mi><mo stretchy="false" is="true">)</mo></mrow><mrow is="true"><mi is="true">N</mi><msup is="true"><mrow is="true"><mo stretchy="false" is="true">(</mo><mi is="true">G</mi><mo is="true">∪</mo><mi is="true">L</mi><mo stretchy="false" is="true">)</mo></mrow><mn is="true">2</mn></msup><mo is="true">−</mo><mi is="true">N</mi><mo stretchy="false" is="true">(</mo><mi is="true">G</mi><mo is="true">∪</mo><mi is="true">L</mi><mo stretchy="false" is="true">)</mo></mrow></mfrac></mrow></math>Where G is a subgraph instance of a certain motif, L is a set of neighbor nodes of G, E(G∪L) and N(G∪L) represent the number of edges and nodes in the first-order extended subgraph of G, respectively.
Then, the sum of the first-order extended subgraph densities of all the motifs in which the node participates is taken as the index to measure the importance of the node, that is:MEi=∑i∈GDG<math><mrow is="true"><msub is="true"><mrow is="true"><mi is="true">M</mi><mi is="true">E</mi></mrow><mi is="true">i</mi></msub><mo is="true">=</mo><msub is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">i</mi><mo is="true">∈</mo><mi is="true">G</mi></mrow></msub><msub is="true"><mi is="true">D</mi><mi is="true">G</mi></msub></mrow></math>
For each node, the importance is determined by calculating the topological metrics of the node and the weights of the participating motifs. All nodes are divided into key nodes and non-key nodes. For non-key nodes, due to their limited contribution to part family machining and limited reuse value, they cannot be used as part of the candidate process skeleton. The key nodes are retained according to the characteristics of process analysis. The expression for the importance calculation of node i is as followszi=wdcDCi+wbcBCi+wccCCi+wcCi+wmeMEiifziMax(zi)>λ,Type(i)=key,elseType(i)=non-key<math><mrow is="true"><mtable columnalign="left" displaystyle="true" is="true"><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><msub is="true"><mi is="true">z</mi><mi is="true">i</mi></msub><mo is="true">=</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">d</mi><mi is="true">c</mi></mrow></msub><mi is="true">D</mi><msub is="true"><mi is="true">C</mi><mi is="true">i</mi></msub><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">b</mi><mi is="true">c</mi></mrow></msub><mi is="true">B</mi><msub is="true"><mi is="true">C</mi><mi is="true">i</mi></msub><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">c</mi><mi is="true">c</mi></mrow></msub><mi is="true">C</mi><msub is="true"><mi is="true">C</mi><mi is="true">i</mi></msub><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mi is="true">c</mi></msub><msub is="true"><mi is="true">C</mi><mi is="true">i</mi></msub><mo is="true">+</mo><msub is="true"><mi is="true">w</mi><mrow is="true"><mi is="true">m</mi><mi is="true">e</mi></mrow></msub><mi is="true">M</mi><msub is="true"><mi is="true">E</mi><mi is="true">i</mi></msub></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mtext is="true">if</mtext><mfrac bevelled="true" is="true"><mrow is="true"><msub is="true"><mi is="true">z</mi><mi is="true">i</mi></msub></mrow><mrow is="true"><mtext is="true">Max</mtext><mo stretchy="false" is="true">(</mo><msub is="true"><mi is="true">z</mi><mi is="true">i</mi></msub><mo stretchy="false" is="true">)</mo></mrow></mfrac><mo is="true">&gt;</mo><mtext is="true">λ,</mtext><mi is="true">T</mi><mi is="true">y</mi><mi is="true">p</mi><mi is="true">e</mi><mo stretchy="false" is="true">(</mo><mi is="true">i</mi><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mtext is="true">key</mtext><mo is="true">,</mo><mtext is="true">else</mtext><mi is="true">T</mi><mi is="true">y</mi><mi is="true">p</mi><mi is="true">e</mi><mo stretchy="false" is="true">(</mo><mi is="true">i</mi><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><mtext is="true">non-key</mtext></mrow></mtd></mtr></mtable></mrow></math>Where wdc,wbc,wcc,wc and wme are the weights of the parameters respectively, which reflects the emphasis of each parameter in the calculation of node importance. Max(zi) is the biggest one during the importance values of all nodes, and λ is the threshold used to distinguish key and non-key process element.
After calculating the importance of each process element node, the key nodes Vk are extracted as the candidate process skeleton nodes in the k part families CAMs={{CAM11,…,CAM1m}, …, {CAMkl, …, CAMkn}} of MPIL. Then, these are checked to determine whether there are any kinds of paths Et, Em, Ec between key nodes, and if there are, they are connected to show the relations between skeleton nodes. Meanwhile, it is necessary to determine whether the weight of the path satisfies the threshold value before the connection, so as to judge the importance of the relationship between nodes. In addition, since there may be multiple process schemes, the NC process part in the process skeleton is not only in the form of process sequence, but also in the form of graph. Thus, k candidate process skeletons CPSs={CPS1, CPS2, …, CPSk} can be obtained; where CPS is expressed as followsCPS::=Vk,Et,Em,EcVk::=WS1,…,WSi,MF1,…,MFjEt::={WSi,WSj|(WSi→WtWSj)∧WSi,WSj∈Vk}Em::={MFi,WSj|(MFi→WmWSj)∧MFi,WSj∈Vk}Ec::={MFi,MFj|(MFi→WcMFj)∧MFi,MFj∈Vk}<math><mrow is="true"><mtable columnalign="left" displaystyle="true" is="true"><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mfenced open="〈" close="〉" is="true"><mrow is="true"><mi is="true">C</mi><mi is="true">P</mi><mi is="true">S</mi></mrow></mfenced><mo is="true">:</mo><mo is="true">:</mo><mo is="true">=</mo><mfenced open="(" close=")" is="true"><mrow is="true"><msub is="true"><mi is="true">V</mi><mi is="true">k</mi></msub><mo is="true">,</mo><msup is="true"><mi is="true">E</mi><mi is="true">t</mi></msup><mo is="true">,</mo><msup is="true"><mi is="true">E</mi><mi is="true">m</mi></msup><mo is="true">,</mo><msup is="true"><mi is="true">E</mi><mi is="true">c</mi></msup></mrow></mfenced></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mfenced open="〈" close="〉" is="true"><mrow is="true"><msub is="true"><mi is="true">V</mi><mi is="true">k</mi></msub></mrow></mfenced><mo is="true">:</mo><mo is="true">:</mo><mo is="true">=</mo><mfenced open="{" close="}" is="true"><mrow is="true"><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mn is="true">1</mn></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mo is="true">,</mo><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mn is="true">1</mn></msub><mo is="true">,</mo><mo is="true">…</mo><mo is="true">,</mo><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">j</mi></msub></mrow></mfenced></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mfenced open="〈" close="〉" is="true"><mrow is="true"><msup is="true"><mi is="true">E</mi><mi is="true">t</mi></msup></mrow></mfenced><mo is="true">:</mo><mo is="true">:</mo><mo is="true">=</mo><mo stretchy="false" is="true">{</mo><mfenced open="〈" close="〉" is="true"><mrow is="true"><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub></mrow></mfenced><mo is="true">|</mo><mo stretchy="false" is="true">(</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mover is="true"><mo is="true">→</mo><mrow is="true"><msup is="true"><mi is="true">W</mi><mi is="true">t</mi></msup></mrow></mover><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub><mo stretchy="false" is="true">)</mo><mo is="true">∧</mo><mfenced open="(" close=")" is="true"><mrow is="true"><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub></mrow></mfenced><mo is="true">∈</mo><msub is="true"><mi is="true">V</mi><mi is="true">k</mi></msub><mo stretchy="false" is="true">}</mo></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mfenced open="〈" close="〉" is="true"><mrow is="true"><msup is="true"><mi is="true">E</mi><mi is="true">m</mi></msup></mrow></mfenced><mo is="true">:</mo><mo is="true">:</mo><mo is="true">=</mo><mo stretchy="false" is="true">{</mo><mfenced open="〈" close="〉" is="true"><mrow is="true"><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">i</mi></msub><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub></mrow></mfenced><mo is="true">|</mo><mo stretchy="false" is="true">(</mo><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">i</mi></msub><mover is="true"><mo is="true">→</mo><mrow is="true"><msup is="true"><mi is="true">W</mi><mi is="true">m</mi></msup></mrow></mover><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub><mo stretchy="false" is="true">)</mo><mo is="true">∧</mo><mfenced open="(" close=")" is="true"><mrow is="true"><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">i</mi></msub><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub></mrow></mfenced><mo is="true">∈</mo><msub is="true"><mi is="true">V</mi><mi is="true">k</mi></msub><mo stretchy="false" is="true">}</mo></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mfenced open="〈" close="〉" is="true"><mrow is="true"><msup is="true"><mi is="true">E</mi><mi is="true">c</mi></msup></mrow></mfenced><mo is="true">:</mo><mo is="true">:</mo><mo is="true">=</mo><mo stretchy="false" is="true">{</mo><mfenced open="〈" close="〉" is="true"><mrow is="true"><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">i</mi></msub><mo is="true">,</mo><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">j</mi></msub></mrow></mfenced><mo is="true">|</mo><mo stretchy="false" is="true">(</mo><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">i</mi></msub><mover is="true"><mo is="true">→</mo><mrow is="true"><msup is="true"><mi is="true">W</mi><mi is="true">c</mi></msup></mrow></mover><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">j</mi></msub><mo stretchy="false" is="true">)</mo><mo is="true">∧</mo><mfenced open="(" close=")" is="true"><mrow is="true"><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">i</mi></msub><mo is="true">,</mo><mi is="true">M</mi><msub is="true"><mi is="true">F</mi><mi is="true">j</mi></msub></mrow></mfenced><mo is="true">∈</mo><msub is="true"><mi is="true">V</mi><mi is="true">k</mi></msub><mo stretchy="false" is="true">}</mo></mrow></mtd></mtr></mtable></mrow></math>Where Et, Em, Ec, Wt, Wm and Wc are the connection edges and weights corresponding to the temporal relation, machining relation and coupling relation, respectively.
Given a set of process data instances, they are composed of the part family CAMs and its candidate process skeleton CPSs. From the analysis results of the previous section, it can be seen that the high-quality process skeleton needs to meet five conditions. The moderate information is guaranteed by process skeleton modeling, and the close correlation and high frequency are satisfied by process data structuring and process data network construction respectively. Therefore, on the basis of generating candidate process skeleton, the final process skeleton can be obtained by evaluating whether it conforms to the moderate granularity and the specific process, thus deciding whether it can evolve into the process knowledge base. Specifically, defining CPSk as the process skeleton PS needs to satisfy the following conditions∀WSi∈CPSk,WSj∈CPSk,WSi∈TWS,WSj∈TWS∃WSi∈PS,WSj∈PS∀WSi→WSj∃WSi(PS)→WSj(PS),d<math><mrow is="true"><mtable columnalign="left" displaystyle="true" is="true"><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mo is="true">∀</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mo is="true">∈</mo><mi is="true">C</mi><mi is="true">P</mi><msub is="true"><mi is="true">S</mi><mi is="true">k</mi></msub><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub><mo is="true">∈</mo><mi is="true">C</mi><mi is="true">P</mi><msub is="true"><mi is="true">S</mi><mi is="true">k</mi></msub><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mo is="true">∈</mo><mi is="true">T</mi><mi is="true">W</mi><mi is="true">S</mi><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub><mo is="true">∈</mo><mi is="true">T</mi><mi is="true">W</mi><mi is="true">S</mi></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mo is="true">∃</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mo is="true">∈</mo><mi is="true">P</mi><mi is="true">S</mi><mo is="true">,</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub><mo is="true">∈</mo><mi is="true">P</mi><mi is="true">S</mi></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mo is="true">∀</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mo is="true">→</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub></mrow></mtd></mtr><mtr columnalign="left" is="true"><mtd columnalign="left" is="true"><mrow is="true"><mo is="true">∃</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">i</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">P</mi><mi is="true">S</mi><mo stretchy="false" is="true">)</mo><mo is="true">→</mo><mi is="true">W</mi><msub is="true"><mi is="true">S</mi><mi is="true">j</mi></msub><mo stretchy="false" is="true">(</mo><mi is="true">P</mi><mi is="true">S</mi><mo stretchy="false" is="true">)</mo><mo is="true">,</mo><mi is="true">d</mi></mrow></mtd></mtr></mtable></mrow></math>
where WSi and WSj represent two working steps, TWS represents the typical working steps of this kind of parts, d(WSi) and d(WSj) are the diameters of the cutting tools used by WSi and WSj, A(WSi) and A(WSj) are the allowances used by WSi and WSj, respectively. "→" means "priority".G(CPSk)=log2(Pk)>θ<math><mrow is="true"><mi is="true">G</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">C</mi><mi is="true">P</mi><mi is="true">S</mi></mrow><mi is="true">k</mi></msub><mo stretchy="false" is="true">)</mo><mo is="true">=</mo><msub is="true"><mtext is="true">log</mtext><mrow is="true"><mn is="true">2</mn></mrow></msub><mo stretchy="false" is="true">(</mo><msub is="true"><mi is="true">P</mi><mi is="true">k</mi></msub><mo stretchy="false" is="true">)</mo><mo is="true">&gt;</mo><mi is="true">θ</mi></mrow></math>Pk=∑l=1nφ(CPSk,CAMl)N(CAMl)<math><mrow is="true"><msub is="true"><mi is="true">P</mi><mi is="true">k</mi></msub><mo is="true">=</mo><mstyle displaystyle="true" is="true"><mrow is="true"><munderover is="true"><mo is="true">∑</mo><mrow is="true"><mi is="true">l</mi><mo is="true">=</mo><mn is="true">1</mn></mrow><mrow is="true"><mi is="true">n</mi></mrow></munderover></mrow></mstyle><mfrac is="true"><mrow is="true"><mi is="true">φ</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">C</mi><mi is="true">P</mi><mi is="true">S</mi></mrow><mi is="true">k</mi></msub><mo is="true">,</mo><msub is="true"><mrow is="true"><mi is="true">C</mi><mi is="true">A</mi><mi is="true">M</mi></mrow><mi is="true">l</mi></msub><mo stretchy="false" is="true">)</mo></mrow><mrow is="true"><mi is="true">N</mi><mo stretchy="false" is="true">(</mo><msub is="true"><mrow is="true"><mi is="true">C</mi><mi is="true">A</mi><mi is="true">M</mi></mrow><mi is="true">l</mi></msub><mo stretchy="false" is="true">)</mo></mrow></mfrac></mrow></math>Where φ(CPSk,CAMl) is the number of the same nodes in CPSk and CAMl, and N(CAMl) denotes the number of the nodes of process instance CAMl.
Since non-key nodes have been processed, only enough information is needed for appropriate granularity conditions. From the above formulas, it can be seen that if the G(CPSk) value is larger, the more nodes in CPSk is used, and the richer information is contained. Each candidate process skeleton is evaluated using the above conditions, and the final process skeleton is determined according to the satisfied conditions.
To verify the feasibility and effectiveness of our approach presented in this paper, we have developed a prototype system for complex network based NC process skeleton extraction approach on the platforms of Microsoft Visual Studio 2008 and CATIA V5 R21 component application architecture (CAA). The test is executed on a PC with Intel Core i3 CPU 3.40 GHz and 4 GB memories.

Machining process instance structuring
Fig. 7 shows an example of process data for an aircraft structural. The MFs of this instance includes 10 pockets and 6 holes. There are two kinds of coupling relations between the features: thin wall and spatial distribution. Meanwhile, the WSs of this instance contain 9 working steps, which consist of 85 machining operations. In the process of constructing the attribute adjacency graph of process elements, firstly, the features with the same process scheme and no significant difference in geometric attributes are clustered. Thus, F6 and F8 with narrow regions constitute a class of features P0009, F1, F2, F3, F4, F5, F7, F9 and F10 form a class of pockets P0010, and F11, F12, F13, F14, F15 and F16 form a class of holes H0005. The thin-walled structure is formed between P0009 and P0010. H0005, P0009 and P0010 form the spatial distribution relation respectively, and they are machined at the same working orientation. As shown in Fig. 8.
Graph isomorphism
Fig. 9 shows an example of isomorphism of process element attribute adjacency graph. Match Part and Matched Part are two-side parts, including A side and B side. Among them, F2 and F3 in Match Part constitute feature class P1, F1 constitutes feature class P2, and F4 constitutes feature class P3. Matched Part is divided into four categories: P11 (F5, F6, F7, F9, F10), P21 (F8), P31 (F13), and H11 (F11, F12). Graph isomorphism starts with machining features. Since P1, P2, P3 are compatible with the key geometric parameters of P11, P21 and P31, and the coupling relations between them are the same, then node pairs (P1, P11), (P2, P21), (P3, P31) can be used as candidate matching node pairs. Meanwhile, the features are related to the process nodes, and then the working step nodes are matched according to the sequence, such as, both RMP1 and RMP11 are Rough Milling Pocket, and both adopt the process parameters such as D20 cutting tool, 1 mm radial allowance and 1 mm axial allowance. Thus, the process parameters are compatible, and the related features are also matched, so RMP1 and RMP11 meet the matching requirements. In Fig. 9, there are 8 matching pairs of process elements between Match Part and Matched Part. Thus, the same nodes and connected edges between attribute adjacent graphs of process elements are fused by graph isomorphism, and the weight of edges is calculated.
Machining process data network construction
180 NC machining process instances of various parts are selected randomly and evenly from the process database, and the process instances are constructed into the attribute adjacency graphs of process elements by using the above structured method. Then the process data network (mainly for the second layer network MPEL) is established, as shown in Fig. 10. To reduce the complexity of process data network, the features of a single part are clustered according to geometry, accuracy and process similarity to preliminarily screen the key MF nodes. At the same time, in the process of network construction, process element nodes are merged by matching, and the weight is used to represent the number of instances. In Fig. 10, the completed process data network consists of 158 nodes, including 102 WS nodes (orange) and 56 MF nodes (blue).
The shortest path length of the MPEL is 3.173 and the clustering coefficient of the MPEL is 0.19. Meantime, The shortest path length and the clustering coefficient of a random network with the same size (N = 158) and average degree (k = 2) are 4.837 and 0.043, respectively. Since the MPEL has a smaller shortest path and a larger clustering coefficient than the random network, it has the small-world property (Watts and Strogatz, 1998). The small-world property reflects that the information transmission speed is faster in the network, and the changes of a few nodes can have a great impact on the performance of the whole network, that is, the importance or critical of nodes in small-world networks is more obvious.

Topological metrics analysis
Fig. 11 shows the degree centrality, betweeness centrality, closeness centrality and clustering coefficient of MPDN. As shown in Fig. 11(a), FMS0003 and RRMP0001 have the largest degree in WS nodes. Among them, RRMP0001 shows that it is common to use D12 cutting tool for re-roughing. In MF nodes, P0009 and P0010 nodes have a greater degree, because the structure with the most frequent occurrence in aircraft structure is two adjacent thin-walled pockets, and one of them (P0010) has a narrow region. In addition, P0002 (Min width: 27 mm, Area: 1267mm2) and H0008 (D(H) = 10 mm) also have a greater degree. Betweeness describes the uniqueness of working step sequences or working steps in a process scheme. As shown in Fig. 11(b), there are no alternative process schemes for the sequence of working steps D2 Counter Boring→D10 Drilling Hole (CB0001, DH0001), D16 Rough Milling Pocket→D12 Re-rough Milling Pocket (RMP0006, RRMP0001). In addition, D10 Finish Milling Side (FMS0003) is unique in the process scheme. Therefore, FMS0003, CB0001, DH0001, RMP0006, RRMP0001 have larger betweeness centrality. The nodes such as FMS0007, DH0003, FMS0011 and H0005 have larger closeness centrality, as shown in Fig. 11(c). The nodes with larger clustering coefficients are mainly WS nodes, including RMP0001, RRMP0002, MH0001, FMS0008; as shown in Fig. 11(d).
The three-node motifs detection of MPEL is achieved by Rand-ESU algorithm (Wernicke and Rasche, 2006), as shown in Table 1. As can be seen from the table, the subgraphs of No. 2, 6, 36, 38 and 140 are MPDN's 3-node modules. The motif No. 2 describes the typical process route, and the motif No. 6 is the typical process scheme of machining features. No. 36 and 38 represent the case of using the same working step when there is coupling relation between features and no coupling relation. In addition, the motif No. 38 has the highest Z-score, which indicates that the coupling relation between features will have a great impact on the process scheme. No. 140 reflects the subpart formed by the coupling of features. In addition to the characteristics of the general complex network, in the field of NC machining process design, the detected motifs can be subdivided according to the process knowledge of working step type, feature type and coupling relation type to support the important/critical calculation of process element nodes.
Critical Judgment of Nodes
Fig. 12 is an example of one-side frame parts family in the instance layer of process data network. It is a typical aircraft structural with thin-walled structure and similar process route. Table 3 gives the topological metrics of its process elements and calculation examples of one-dimensional extended subgraph density, as well as the final calculation results of node importance. From the table, RRMP0001, FMS0006, P0009 and P0010 are the key nodes in the process data, because their importance values are obviously greater than other nodes. Meanwhile, since not all parts need to deal with clearing angle and sag in the process instances, this makes FMSA0001, CA0001, RH0002 and other nodes less important in the process data network, and is not the core process elements, so these nodes are deleted. Although DH0003 and H0005 have large closeness centrality, the threshold λ of this paper is 1.5, they also are considered as non-critical nodes. This is because most of the parts using this process or structure are aircraft structural parts, and the key structure is the pocket. Therefore, the process elements nodes RMP0007, RRMP0001, FMB0005, FMC0001, FMS0006, P0009 and P0010 in Table 2 can be used to construct the candidate process skeleton of the single-side frame parts family.
Process skeleton extraction samples
Fig. 13 shows the process skeleton extraction results of five different part families. From the results of extraction, it can be seen that all process skeletons satisfy the conditions of moderate information, high frequency, close correlation, appropriate granularity and specific process, so as to effectively ensure that they have the characteristics of reusability, correlation, critical and rationality, which illustrates the effectiveness of the proposed method. It can be seen from the figure that group a and group b have similar graph topology structure, because the two types of parts are thin-walled structure, thus affecting the macro process of the parts. However, due to the large difference of feature sizes in parts, the attributes of process elements nodes are different. For example, in RMP working steps, group a is the cutting tool of D32, while group b is the cutting tool of D16. In addition, Group e has similar attributes with group a and group b. The difference is that group e is a double-side part, and the macro process has multiple working orientations. It can be seen that it has four working orientations, and the machining strategy of A→B is adopted iteratively, that is A→B→A→B. This is because in addition to the thin-walled structure of the profile, the bottom of the feature is also thin-walled, thus the pockets on different sides has the coupling relations. Group c parts are mainly composed of three types of pockets with different sizes, so the core working step reflects that different cutting tools are used. Unlike the neglect of holes in other parts, the pockets and holes of the parts in group d are equally important. Therefore, the process skeleton contains both holes and pockets. Meanwhile, this group of parts is also double-side parts, since the deformation caused by rough machining is not considered, its machining strategy is A→B, that is, one side is machined in place and then the other side is machined.
Fig. 14 shows an example of process skeleton reuse. The query part is a rib part, and its machining features are mainly pockets and large holes. By using the 3D model retrieval method in (Huang et al., 2018), the parts families with different similarities and their associated process skeletons can be found. According to the similarity value, process skeleton a is selected for reuse. As shown in Fig. 14b, the process skeleton a is used as the initial macro process of the query part, and the NC process of each feature is determined at the same time. Among them, because the radius of the pockets is small (r = 6 mm), besides the core working step, working step FMC (Finish Milling Corner) should be supplemented. F8, F2, F4, F5, F7, F16 are holes, which require hole machining operations, i.e., Milling Hole (the original size is generated by the blank, leaving only 1.5 mm for finishing). Thus, the macro process is extended to 6 working steps. In addition, in the process of feature process decision-making, since the minimum width of F9, F13 is 10 mm, the cutting tool of D8 can be used in roughing, which is incompatible with the process skeleton (or macro process). To reduce the number of tool changes, the D8 tool is used in the re-roughing working step, and the process skeleton information is modified. Therefore, when the process skeleton is reused, it can be extended or modified adaptively.
In order to illustrate the advantages of our approach, some comparisons between our approach and the typical existing methods are shown in Table 3 and Table 4. Existing knowledge discovery methods are usually divided into two categories: (1) typical process route extraction based on process semantics; (2) common design structure discovery based on geometric information. Our method synthesizes geometric and process information for modeling and extracting process skeleton, so as to support the effective reuse of macro process knowledge. Ref. (Navaei and Elmaraghy (2017)) uses operation sequence graph for representing process data structurally and modeling macro process knowledge. Geometric information is not taken into account in the representation method, thus the reusability is not high. Ref. (Zhou and Dai (2015b)) considers both geometric topology and process sequence information in the process of process data representation. However, the one-dimensional process semantics sequence still used in macro-process knowledge modeling, which make it cannot well support the reuse of macro process knowledge. Our method is based on the analysis of process data in CAM system and the construction of the relationship between the geometry and NC process to refine the multi-level representation of process data. Meanwhile, the process skeleton is evaluated and modeled from five perspectives, e.g. information, frequency and specific process. Thus, to determine whether the query part can reuse a process skeleton, we can check whether its geometric and precision attribute values are within the attribute values of the process skeleton node. In terms of eliminating non-key features, Ref. (Zhang et al. (2013a)) deletes or suppresses small features and free-form surfaces. However, it only considers the key features from the geometric level, and then it cannot be effectively applied to the field of NC machining process. Our method is to determine the key of process elements from the whole by analyzing all the process data instances, and it can be used for mining process skeleton very well.
On the other hand, at present, the reuse granularity of automatic process reuse research mainly concentrates on feature level, while the research on automatic process reuse of part level (i.e. macro process reuse) is less involved. The existing macro process reuse methods still rely heavily on engineers’ experience, and usually require a lot of user interactions to search and modify the reusable NC process case, or to construct the machining know-how database, e.g. process template library and heuristic rules, therefore, their modification workload is high. In our approach, the machining process knowledge is captured automatically from the existing successful CAM models, and the NC process reuse course is automatically realized with some user interactions.
In this paper, a complex network based NC process skeleton extraction approach is presented. First, to ensure the practical value of the excavated process knowledge, the good or high-quality process skeleton is analyzed and evaluated from four aspects: reusability, correlation, critical and rationality. Then, on the basis of the process skeleton model, the process data instance is transformed into the process element attribute adjacency graph. Meanwhile, according to complex network theory, process data network is constructed, and the importance of process element nodes is judged to support the automatic discovery of process skeleton. Finally, a prototype system for automatic mining of process skeleton is developed, and the performance of the prototype system is tested with real parts. The experimental results show that the method can effectively mine the high-quality process skeleton, thus effectively supporting the reuse of macro process knowledge.
In the near future, several issues could be further addressed to improve our approach: (1) research the implementation method of adaptive reuse based on the mining results to improve the intelligent level of NC process planning; (2) extend the method to other granularity process knowledge mining, such as the typical process extraction for machining feature, mining of new concepts/relations in NC process field, to improve the integrity and reusability of the mining results, and enrich the process knowledge base.
None.
The authors are grateful to the financial support from the National Science Foundation of China (No. 51875474, 51605142), and Equipment Pre-Research Domain Foundation of China (61409230102).